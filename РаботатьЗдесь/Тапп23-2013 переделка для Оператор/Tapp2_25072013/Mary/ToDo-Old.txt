Обозначения:
- намечено
+ сделано
Обозначения функций в коде:
NR- код не готов
NT- код готов, не тестирован
NFT- код тестирован частично
TE- код тестирован, надо документировать
TD- код тестирован и документирован



Jan 8, 2012
Начинаем ваять.
+набросаны классы
+сделано создание контейнера и доступ к бд. Проверено.
-лог пока не сделан. Открывается-закрывается и только.
-Исключения пока не сделаны. Используем одно общее, потом разработаем систему и все будет.
+создание ячейки - надо уточнить процессы с учетом всех вариантов. - done
+Версия движка - не имеет смысла держать ее в контейнере, она статическая и все равно недоступна из объекта.
  +удалена. Версия самостоятельно импортируется из сборки.
+сделано создание и поиск ячейки по идентификатору. Вроде работает.
+ Проверить, что ссылка на контейнер в ячейке функционирует нормально во всем коде.
  +она инициализируется в конструкторе контейнера, одна на все ячейки.
- Проверить, что ячейки обоих типов полностью соответствуют структуре.
! MCell.ModiTime.set аксессор используется при загрузке ячейки из таблицы, поэтому его придется оставить.
   Хотя он не нужен больше нигде.
- Набросаны функции для чтения/записи полей ячеек в MDbLayer. Надо придумать как их сделать быстрыми, и чтоб поменьше кода писать.
   + сделаны. Не очень быстрые, но пока пойдет. Если надо будет, переделаем на полностью индивидуальные функции.
   - по результатам тестов, тормозят всю работу, поскольку вызываются часто. Надо ускорить.
- Сделать функцию MDbLayer  MLinkCollection getCellLinks(uint m_cellid) Она одна осталась, для MCellA свойств.  
? Если ячейки нет, при попытке обновления ошибок вроде бы не выдается. Следует ли выкидывать исключение в этом случае?
+ Сделаны аксессоры для MCellB, с записью изменений с учетом флагов.
- Проверить работу аксессоров для версий MCell.
  -не все проверены на запись, все на чтение.
+ Сделать общую функцию сохранения ячейки для обоих случаев: новая ячейка и существующая. MDbLayer.SaveCell(). 
  - Надо выбрать наиболее быстрый вариант кода.
- Сделать и проверить: Создание ячейки, временной, отложенной записи. Удаление ячейки, выгрузка ячейки и памяти. Оптимизация поиска нового идентификатора.
? MCell.Delete() обязательно делать отдельной функцией? весь нужный код в проперти isActive, и он и там прекрасно выполняется.
- Сделана функция поиска ячеек в БД по шаблону. Ячейки создаются в двух вариантах, для большей гибкости.
  Надо тестировать.
+ Надо сделать функцию поиска в списке ячеек по шаблону. Просто отбирать подходящие ячейки в новый список.  
   internal bool CellMatch(MCell cell) - надо проверить работу при поиске mcell.Value данных.
   -сделано. Работает медленно если MCellA, быстро если MCellB. Value тоже проверено.
- Попробовал сделать оптимизацию получения нового идентификатора. Вроде наваял, но что-то кажется, что переборщил и сделал дублирующие ветви.
Надо бы осмотреть и переделать.

jan 10, 2012
- Можно попробовать заменить два поля Temporary и DelaySave одним енумом CellMode с вариантами
  Normal, Temporary, DelaySave. Надо просмотреть весь код, использующий поля, нет ли проблем.
  Разница между флагами Temporary и DelaySave: 
  - при создании отложенной ячейки она записывается в БД, временная нет;
  - сохранение обеих ячеек вручную, но отложенная записывается и при завершении работы.
  - при сохранении временная становится нормальной, отложенная остается отложенной.
  Согласно разработанного плана, переключать режимы можно между Default и DelaySave. 
   Это требуется при загрузке ячейки из бд, чтобы выключить на это время запись изменений полей ячейки.
  Режим Temporary нельзя сменить через проперти, поскольку временная ячейка не существует в БД.
  При попытке сменить будет исключение. Режим можно сменить только после записи ячейки в таблицу вызовом Save().
  При этом режим меняется на Default, и затем его можно установить DelaySave.
  Также режим Temporary нельзя установить через проперти, поскольку не имеет смысла делать временную ячейку из уже существующей.
  Хотя, это надо посмотреть, может, и потребуется...
  Режим можно установить через конструктор ячейки или внутри кода через переменную.
  -done. not tested.
  
+ Сделана функция сравнения массивов байт MCellTemplate public static bool CellValueEqual(byte[] b1, byte[] b2) 
 Проверена работа на пустых или заполненных массивах.
- Проверена работа ячеек MCellB частично. Поиск по шаблону быстрый.

+Добавить в шаблон ячейки поле CellSaveMode и поле LargeCell - только для поиска в памяти. В таблице этих полей нет.
  Сделать поиск в памяти и по ним тоже. Может пригодиться.
  - done
  
- Надо осмотреть весь код и набросать общий обзор кода проекта. Строение и иерархию классов, функции и особенности.
   Освежить представление проекта, чтобы проектировать связи уже с новой позиции.
   - пока не получается.
   
jan 12, 2012

- сделать функции таблицы связей
  - создание связи insertLink
  - поиск связи по шаблону

  Пока неясно, как идентифицировать связи для update и delete. Вероятно, придется часто использовать шаблоны.
  Надо бы по первичному ключу записи, но как его получить при создании записи?
  Кстати, поле описания в связи можно не загружать в память, а добывать отдельной функцией. 
   Это экономит память. Поле описания нужно только для пользователя.
    Однако как тогда записывать его в таблицу? Передавать отдельным параметром?
    -сейчас пока загружается в память.
    
- Свойство linkId добавлено в MLink и MLinkTemplate
+ В таблицу связей следует добавить таймштамп модификации, на случай появления дубликатов связей.
   Это поле сейчас не загружается в память, его нет в связи и в шаблоне связи, по нему не проводится поиск.
   Это поле должно обновляться при изменении записи.
   Значение можно получить отдельным запросом.
   + поле добавлено в таблицу, при создании и изменении записи пишется..   
- Сделаны, не тест   
   public bool MLinkTemplate.LinkMatch(MLink link) - компарер для фильтра
   public MLinkCollection MDbLayer.getLinks(MLinkTemplate tmp) - фильтрует связи в таблице
   internal int MDbLayer.insertLink(MLink link) - добавляет связь в таблицу
   public MLinkCollection MLinkCollection.getLinks(MLinkTemplate template) - фильтрует связи в списке
   public bool MLinkCollection.containsLink(MLinkTemplate template) - существуют ли связи в списке.
   MDbLayer:
   internal int deleteLink(int linkId) - удалить связь по ее ключу. Может и потребуется...
   public MLinkCollection getCellLinks(uint cellid, MAxisDirection axisDir) - получить связи ячейки, фильтровать по направлению
   private MLinkCollection readLinkResultSet(SqlDataReader rdr)- вспомогательная, превращает запрос в список связей и закрывает запрос.       
  
Jan 15, 2012
- Сделаны функции, не тест
   MDbLayer:
   public int getLinkID(uint dnCellId, uint upCellId, uint axis) - возвращает первичный ключ первой же подходящей записи
   public int getLinkID(MLink link) - возвращает первичный ключ первой же подходящей записи (другие аргументы)
   public int insertLinkGetId(MLink link) - Добавляет запись в таблицу связей и возвращает первичный ключ.
   internal int updateLink(MLink link) - Обновляет сразу все данные связи. Потом можно сделать функции на отдельные поля.
- Если будем вводить улучшенный поиск и индексы в список связей контейнера, надо создавать отдельный класс - 
   существующий класс коллекции связей используется во многих местах.   
- Сделано сохранение при изменениях свойств связи. Для блокировки сохранения изменений в таблице, установить linkID = 0.   
   Надо разбить на более мелкие вызовы. Сейчас сохраняется сразу вся связь, это долго.
   
Jan 17, 2012   
- updateLink исправлена - отсутствовало условие выборки записей.
- Нужно спроектировать код связей - сейчас бардак.
  Нужна теория про загрузка связей из бд в ячейку, выгрузка связей в бд при сохранении ячейки, 
  размещение и поиск в контейнере, создание удаление ... В общем, вся концепция.  
- набросаны в MCell. Надо переделать соответственно для MCellA и MCellB.
public MLink createLink(uint Axis, MAxisDirection axisDirection, MCell targetCell) - создает связь, записывает в 
  таблицу если не временная, записывает в контейнер и ячейки. Если связь уже существует, выдает исключение. 
  Между 2 ячейками в одном направлении оси считается только одна связь.
public MLink createLink(uint Axis, MAxisDirection axisDirection, uint targetCellId) - то же но без конечной ячейки в памяти
internal MLink intCreateLink(uint Axis, MAxisDirection axisDirection, MCell targetCell) внутренняя, не проводит проверку существования связи. 
internal MLink intCreateLink(uint Axis, MAxisDirection axisDirection, uint targetCellId)


Jan 23, 2012
? Осмотреть класс MElement, можно ли его удалить, а поля перенести в соответствующие подклассы.
  Класс был выделен для общего представления всех элементов структуры. Некоторые поля элементов вынесены в него.
  Это ухудшает отображение данных классов в отладчике.
  Надо подумать.
- MEngine.GetCells переименована, поскольку она ищет только в таблице, а не целиком по контйнеру.
   Нужно реализовать функцию поиска целиком по контейнеру (если это нужно...)  

Jan 29, 2012
- для обеспечения временных ячеек нужно переделать существующий код:
  + Идентификаторы ячеек сменить тип на int32
    + Соответственно изменить код в MDbLayer для ячеек и связей. - ид и state поля
    + Просмотреть код коллекции ячеек и изменить необходимое
  - Выделить отрицательное пространство идентификаторов для временных ячеек.
    - Сделать исключение о исчерпании пространства идентификаторов и описать условия его выдачи, внедрить в код.
    + Сделать поиск свободного идентификатора дл новой временной ячейки и поиск максимального 
       идентификатора временных ячеек
  - Сделать код для определения типа ячеек и связей по этому новому принципу.
  - Внести изменения в концепцию и документацию.
В результате:
	- Временные ячейки будут обслуживаться тем же кодом, что и все остальные. Отличаться только пространством 	 идентификаторов.
	- Совместимость с базами данных будет предположительно выше, так как не будет проблем конверсии int-uint.   

- Предлагается связи ячеек выдавать пользователю в виде массива, что не позволит неправильно использовать - напрямую
    вставлять связи из пользовательского кода. Хотя это лишний расход времени и памяти. 
   Потом... 
+ Нужно сделать способ и функцию для быстрого объединения двух списков связей:
   Списка связей в памяти и списка связей из таблицы.
   Типично в список связей в памяти добавляются связи из списка таблицы, если их там нет. Нужен алгоритм для  
       максимально быстрого добавления.  
       - сделано, но надо оптимизировать. Сейчас в среднем n*m/2 сравнений связей.  
+ Нужно сделать функции создания связей и загрузки ячеек. Для каждого типа ячеек свой алгоритм, для связей тоже. См. документацию.  
  - сделано, тестируется.
  
Mar 04, 2012
- Ревизия структуры проекта:
  - рассмотрена концепция пользовательского проекта. Нужно расписать всю работу пользователя с проектом.
    - добавить в проект оболочки класс файла проекта (набор данных проекта) и работу - сохранение/загрузку в XML-виде.
  + идентификаторы ячеек сменить тип на инт32. Переделать код соответственно.
  + класс MVersion реализует проверку совместимости версий проекта и движка при открытии проекта.
  - статические функции byte<->HEX вынести в вспомогательный статический класс, чтобы они не мешались в подсказках.
  + выделить идентификатор ячейки в отдельный класс MID для упрощения последующих переделок.
	- сделать два варианта операций: статические и операции с объектом. Объект разместить в шаблоне - там все равно. Статические функции использовать в коде.
  - Для класса DbLAyer/MEngine предусмотреть функцию создания БД и таблиц в ней. Вероятно, реализовать отдельно от основной системы. Это надо для создания нового проекта на пустом сервере.
  - Добавить в движок класс MFileSystem, который будет управлять файлами проекта - ресурсами, снапшотами, логами, сборками кода. Будет размещать/удалять файлы и предотвращать коллизии. Классу нужно передать путь основного каталога проекта, имена подкаталогов фиксированные, дальше он сам.
  	-добавить контейнеру поле этого класса.
	-добавить инициализацию - приложение передает путь к каталогу проекта при старте движка.
     Часть данных сейчас хранится в БД. Можно удалить их оттуда, надо подумать.
 
 Mar 15, 2012    
- Изменения в коде
  - создать новые классы и добавить в контейнер если нужно.
    + MProject
      + сделать инициализацию строкой пути к проекту - done in MEngine.Open()
    + MResource
    + MMethod
    + MSnapshot
    + классы добавлены в контейнер, сделаны члены и проперти, конструктор контейнера создает по умолчанию.
  - MProjectFile - доступ к данным файла проекта.
      - сделать члены и функционал. Этот класс будет использоваться из пользовательского приложения как часть общей концепции проекта.    
  - переделать функции работы с ячейками согласно нового концепта.
    - надо придумать префикс-метку для отличения новых функций от старых при переделке. С1- ?
  
  - переделать идентификаторы ячеек
    + добавить класс MID и его функционал
    + переделать классы ячеек и связей, чтобы хранили int, а в код выдавали MID. - готово
      - придется создавать идентификатор из числа, а это тормозит. Зато код удобен для последующей модификации.
    + просмотреть весь код, и MDbLayer особенно. - done. Могут быть неочевидные ошибки, компиляция успешна.
      + добавить в MCellTemplate MLinkTemplate классы MID вместо int? и переделать весь код - готово. Но код надо пересматривать.
        + MLinkTemplate done
        + MCellTemplate done 
    - При переделке допущены ошибки. В классах MLink MCell в проперти Set из переданного MID извлекается int и записывается в поле. 
       Поэтому код вида cell.CellID.ID = x.ID должен быть переделан на cell.CellID = x. Посмотреть и остальной код на предмет таких ошибок.
    - сравнение идентификаторов проводится сравнением их полей. Можно переделать на bool MID.Equal(MID id), это уменьшит код и 
       производительность немного поднимет. Пока что для связей сравнение идентификаторов упрощено - сравниваются с их внутренними переменными
        через прилепленные функции быстрого доступа, но при усложнении идентификатора придется переделывать этот код в MLinkTemplate.       
  - MDbLayer
	+ переделать идентификаторы ячеек
    - internal MCell selectCell(uint cellId, MEngine cont) - убрать лишнее. Переделать идентификаторы ячеек.
    - internal uint getMaxCellId() - переделать на новые идентификаторы. Больше ничего не менять.
    - internal MCellCollection getCellsByTemplate(MCellTemplate tmp, bool largeCells) - убрать лишнее. Просмотреть, как используется результат, возвращать список?
    -  
  - MCellSaveMode - переделать. Добавить и переименовать все. 
    + переименован в MCellMode.
    + надо переделать комменты
    - надо проверить и переделать использование.
    - используется в MDbLayer, но там надо все переделывать. 
  + MElementTemplate - не нужен. Члены перенести в подклассы, чтобы формировалось полное представление в отладчике. - done
  
Mar 23, 2012
  - всю концепцию слить в один документ. Переработать и упорядочить.
  + Определить апи для движка на основе прошлых версий. Этот минимальный набор функционала нужно будет реализовать и потом развивать.
     Все прочие фичи дописываются после создания, тестирования и совершенствования структуры основных операций.
  + MEngine private bool m_largeCell;  поле переделать на MCellMode DefaultCellMode - это будет поле типа ячеек по умолчанию, 
     не сохраняемое в таблице, и изменяемое в ходе сеанса. Это поле по умолчанию инициализируется для MCellA пока.
  - MEngine  MCellCollection переделать кеши идентификаторов и функции их обслуживания.
    + Функции и переменные сделаны, не тест.
    - Надо распихать код по операциям с ячейками - когда будут готовы операции.
  - Из таблицы контейнера удалить поле каталога проекта как неиспользуемое, переделать DbLayer код, использующий эту таблицу.
    - Отложим до первого релиза, чтобы объединить все изменения в таблице.
  - Операции ячеек реализовать в MEngine.
    - public MCell S1_intCreateCell(MCellMode mode)
      + Код написан с учетом исключений. При ошибке выдается исключение и откатываются изменения. Не тест.
    - internal MCell S1_intGetCell(MID cellId)
      - Код вызывает intLoadCell которая не готова. 
    - internal MCell S1_intLoadCell(MID cellId, MCellMode cellMode)
    - public void S1_intDeleteCell(MID cellId)
      + Код написан без учета исключений.
      - TODO: Надо ли выгружать ячейку, если она помечена удаленной? Это зависит от дальнейшего использования ячейки.
        Пока можно предположить, что она не будет использоваться, и тогда наверно можно автоматически ее выгружать.
        Однако пока оставим это на усмотрение пользователя. 
    - public void S1_intUnloadCell(MID cellId)
      - Нельзя сделать - нет функций удаления связей из ячеек и контейнера. Нельзя тестировать - нет функций создания связей.
  - MCell.Save() реализовать в подклассах
    -   
  - Перед тестом операций ячеек выписать на функции возможные исключения в ремарки. 

Mar 26, 2012
  + Тест подключения к БД и операции создания ячеек.
    + Правильность работы
      + Подключение к серверу успешно
      + Ячейки всех типов создаются и записываются в таблицу/память.
    + примерное время создания ячеек и занимаемая память (с 10000 |1000000 ячеек для каждого типа ячеек, без связи)
      - MCellA: 7.5s, ~3Mb  | 14m30s 40Mb 
      - MCellB: 7.5s  4Mb  
      - MCellBds: 8.5s 4Mb
      - MCellBt: 0.02s 2Mb | 4.34s 150Mb
    + результаты привести здесь. 
      - необходимо сделать везде ToString() функции для удобства просмотра ячеек и связей в отладчике  
      + Ячейки создаются по умолчанию - с пустыми строками и коллекциями.
      + После создания 1000000 ячеек файл БД 185Мб, лог БД 1250Мб. Сервер БД занял 254Мб памяти и не освобождал до конца работы.
 - Нужны функции создания и удаления связей между ячейками, для тестирования операций загрузки-выгрузки ячеек.
   + Надо придумать, как сохранять изменения в связях немедленно(дляMCellB,MCellA) в таблице или отложенно.
      Тогда будет проще удалять связи и работа для пользователя станет очевиднее. 
      + Если связь постоянная - есть идентификатор связи - то сохранять при изменении через проперти.
        Если связь временная - не сохранять. Для первичного заполнения связи данными использовать 
         конструктор или специальную функцию.
         - уже сделано, с самого начала. Но наверно быстрее записывать по полям, а не всю целиком как сейчас. Надо потом это проверить.
   - разработать описание и операции связей:
      - создание связи между ячейками
      - получение связи между ячейками
      - удаление связи
      - выгрузка связи из памяти
      - удаление связей оптимизатором
      - загрузка связи из БД
        - только для MCellB, MCellBds - создать, заполнить, добавить в контейнер, ячейку, в конечную ячейку если она не MCellA или MCellBt.
          Для остальных нечего делать.
      - получение списка связей ячейки, фильтрованных по критериям.
        - получить список связей ячейки и отобрать по шаблону MLinkTemplate. 
           - Почти весь код уже есть, надо функцию написать и код сборки списка связей для MCellA.
             + Список связей MCellA реализован. 
      - код удобно в MCell разместить.
   
 + MCellMode переделать порядок на Compact Normal,DelaySave, Temporary. Это будет использоваться при выборе преимущественной ячейки при создании связи между ячейками.
    Т е связь MCellA-MCellBt будет создаваться MCellBt ячейкой, поэтому у нее будет соответствующая реализация.
 + MCell добавить public static int LinkTreshold; //Порог - число связей ячейки, когда искать связи в таблице быстрее чем в памяти.
    - default 512, подобрать экспериментально при тестировании. 
        При замене локального сервера БД на удаленный значение надо заново подбирать.
 + Сделать функцию сборки списка связей ячейки MCellA - готова, надо тестить.
   - проверить работоспособность и скорость.
   - ускорить работу.
   
Mar 28, 2012
 - MCell public MLink S1_createLink(MID Axis, MAxisDirection axisDirection, MCell targetCell) делаем.
   - Функция проверяет приоритет CellMode и вызывает S1_intCreateLink() более приоритетной ячейки.
     Поскольку пока это набросок, функция должна быть переделана после теста, для отката изменений при ошибках, итп
     - Для MCell.S1_intCreateLink(MID Axis, MAxisDirection axisDirection, MCell targetCell)
       - Проверить соответствие кода кейсов концепту. 
        Нужны функции:
       + Проверка существования связи между ячейками: 
          Должна возвращать true при наличии любого количества активных связей, совпадающих по axis, upcellid, downcellid, active с образцом.
          Образец типа MLink для уменьшения кода - проверяются только определенные поля.
          Часть из этих функций может потребоваться в остальном коде, но пока они приватные
         + В списке ячейки   public bool MCollection.containsLink(MLink link) основная, private bool MCell.containsLinkMorT(MLink li, bool orTable)       
         - В меньшем списке из двух ячеек (если они не MCellA) private bool containsLinkMinCollection(MLink li, MCell cell1, MCell cell2, bool orTable)
         + В таблице private bool containsLinkInTable(MLink link)
         + В меньшем списке связей ячеек или в таблице private bool containsLinkMinCollection(MLink li, MCell cell1, MCell cell2, bool orTable)
         + В списке ячейки или в таблице private bool containsLinkMorT(MLink li, bool orTable)
      - Переработать MDbLayer.GetLinkId() в соответствии с концепцией связи. 
         Поскольку между ячейками может как-либо существовать несколько связей с разными состояниями, искать для одной из них идентификатор проблема.
         Для получения идентификатора только что созданной связи лучше использовать SQL-функцию получения последнего primary key.
         Тогда обсуждаемая функция не нужна, идентификатор надо получать непосредственно при вставке связи в таблицу. 
         Можно ли его сразу добавлять в экземпляр связи, или просто возвращать? И то и другое.
         Это все надо проверить. 
         - сделана функция-замена.  MDbLayer.GetLinkId() не использовать, убрать из кода ее вызовы.
   - Тест создания связей
     - Проверить работу MCell.ToString() MCellA.ToString надо переделать на получение всех данных ячейки за раз. А то сейчас это 5 запросов.
     - Проверить создание связей между ячейками всех типов.
       +сделать ячейки каждого типа
       +создать связи между ними  (4 оси, по одной на каждую ячейку)
       +вывести связи каждой ячейки в памяти в текстовый файл для удобства анализа. 
         Можно в лог, кстати, он работает? Да.
       - Сделать анализ, проверить код, описать в документации исполнение операции, оптимизировать код с учетом исключений.
        + Ячейки в памяти создаются, поля MCellA из таблицы получаются, в таблицу пишутся (не все проверял),
           связи MCellA получаются. Краткое представление ToString работает.
	       Идентификаторы ячеек сответствуют концепту.
	    + Связи в памяти создаются, в ячейках содержатся и получаются из списков связей ячеек. 
           + Краткое представление ToString работает, но в нем нет идентификатора связи. Надо добавить. - сделано
        + Ячейки в таблице создаются MCellA/B/Bds, для них, кроме MCellBds, записывается имя. (Для MCellBds пока нет функции Save())
        + Связи в таблице создаются MCellA-MCellA, MCellA-MCellB, MCellB-MCellB соответственно концепту.
        + В общем, соответствует концепту.
        - Оптимизировать и учесть исключения
        - Описать в документации
    - Проверить работу всего исполняемого кода пошагово. Проверенные функции отметить.
      - где-то не закрыт датаридер, int getLastIdentityLinksTable() выдает исключение - сделано
        - нет, везде закрывается. что еще?
          - пользователю БД необходимо разрешение на просмотр определений  - GRANT VIEW DEFINITION TO username;
            - не помогло.
        + Не закрыт. Когда проперти связи присваивается значение, связь пишет себя в таблицу, если идентификатор связи не нуль.
          Где-то внутри цикла чтения датаридера происходит запись в таблицу, и чего-то в ридере портится от этого,
           а проявляется не сразу.
       
  + readLinkResultSet - переделано - MLink.TableID должен присваиваться последним, чтобы избежать перекрестного обновления.
    - переделал, но надо просмотреть весь код, где эти проперти используются, чтобы избежать проблем поиска непонятных ошибок потом. 
  - MLink.Axis записывается в БД при изменении. А не должен бы... Надо посмотреть, какие могут быть последствия...         
  - Надо уже вводить запись в лог исполняемых функций и их аргументов/результатов. а то искать ошибку будет очень сложно.
     Предлагается ввести класс сообщений об исполнении функций (вход и выход), чтобы его отключать если не надо полной детализации.
     И код создания этих сообщений вставлять во все функции в начало и конец, или хотя бы в начало.
  - В контейнер добавить функцию удаления неактивных связей оптимизатором. 
     Сделать публичной, чтобы пользователь мог затребовать очистку неактивных связей после интенсивной работы.
    - тогда надо и ячейки неактивные удалять тоже уж заодно. Надо спроектировать весь этот процесс, когда все операции будут уже
        реализованы, все особенности утверждены и описаны. Потом реализовывать.    
  - В MDbLayer можно добавить функцию удаления неактивных связей из таблицы оптом. Но пока она незачем.
     Оптимизатор - отдельная часть концепции, его после будем проектировать.
  - Надо упорядочить пользователя БД - определить необходимые права, создать роль, сделать описание настройки сервера, 
     код для создания БД проекта, инструкцию по развертыванию системы.
  - Хранимые процедуры в БД пока не используем - и без них прет. И нет проблем переноса на другие БД. 
  - Сделать класс файла проекта и сделать открытие проекта в соответствии с концептом.
    + класс файла проекта набросан. Открывается, читается, пишется. Снабжен атрибутами для просмотра в типовом гриде.
      Тест - пример использования. Можно еще диалог просмотра с гридом добавить - не надо, и так дофига зависимостей у сборки выходит.
    - Поскольку файл в XML-формате, надо соблюдать ограничения в строках - нельзя использовать < и >, и еще что-то.
       Можно просматривать все строки и менять эти символы на другие, перед сохранением.
  - Для лога сделать вывод сообщения о начале и конце сессии.
     Добавить классы сообщений Низкоуровневые функции, Высокоуровневые функции - 
      - это когда функции можно будет распределять по слоям.  
      
Mar 30, 2012  
+ Набросана internal MCell MEngine.S1_intLoadCell(MID cellId, MCellMode cellMode)
   В процессе работы туда-сюда таскал код получения связей MCellA, поэтому не уверен, что он теперь работает.
   Можно тестировать internal MCell S1_intGetCell(MID cellId), которая должна добывать ячейки из памяти 
    или загружать из таблицы.
+ Набросана public void S1_intUnloadCell(MCell cell)
  + функция удаления/добавления ссылок на ячейку в списке связей контейнера/ячейки internal void MLinkCollection.S1_setCellRefs(MID cellid, MCell cell)
     Для удаления ссылок передавать null.
  - Набросано все. Проверить правильность кода по диаграмме, а работу на тесте связей ячеек. 
     Хорошо бы выводить в файл список связей контейнера и список ячеек контейнера также.      
- Тест создания, получения, изменения свойств и выгрузки ячеек. 
  - Без связей. Всех типов.
  - Со всеми связями, всех типов. Выгрузка по одной ячейке каждого типа из полной картины связей (По диаграмме).
     С полным выводом всего что есть в файл. 
     - код для полного вывода сделан. 
     - Надо переделать ToString для всех элементов, чтобы просматривать удобно было.
        Можно сделать формат отображения как в прошлой версии Tapp.
     - Надо добавить поле идентификатора в контейнер. Хоть пока не используется, пусть будет.
       - его надо хранить в таблице.
  - Замечания по тесту без связей
    - MCellBds надо сделать Save() - сейчас невозможно сохранить изменения
      Остальные ячейки изменяются успешно.
    - Ячейки из контейнера удаляются при выгрузке, получаются, загружаются успешно. 
       Загружаются как MCellA.
  - Замечания по тесту со связями
    -  
    - 
   
   
Apr 08 2012
 - выписать  системные исключения для первичных функций
   + MCellCollection
   + MLinkCollection
   - MDbLayer
   - ...
 - сделать MCell.Save()
   - основной код накидан, надо тестить
   - переделать для лучшего соответствия и исключений.
 - сделать тест базы деталей со связями. 
    - импорт данных
    Каждую строку представить ячейкой записи, с подъячейками - полями.
    Ячейки-записи объединить в ячейку-таблицу - пока просто соединить.
    - обработка
      объединить ячейки с одинаковыми значениями (по каждому столбцу раздельно).
      Можно сначала высчитать коэффициент повторяемости.
    - запись готовой структуры (для MCellBt, MCellBds)
    - поиск детальки по параметрам. Выборка ячейки.  
   - Записать время выполнения операций и занимаемую память для каждого типа ячеек.       

Apr 11 2012
 - определить концепцию доступа к конечной ячейке связи
   - проверять ли наличие ячейки в контейнере (достоверность ссылки)
   - получать ли ячейку из контейнера при отсутствии ссылки 
   - обновлять ли ссылки в связях ячейки при отсутствии ссылки        
 - S1 префикс убрать из имен функций, он уже не нужен. Проверить их использование. 
 - набросать формат сообщения лога
   - сделать вывод сообщений о вызовах основных функций, открытии и закрытии сеанса.
 - набросать сериализацию  
   - определить формат сериализации связи, ячейки, контейнера в текст, в бинарный формат
   - при сериализации контейнера выводить ли ячейки?
   - при сериализации ячейки выводить ли связи? 
   
 May 20 2012
 - сериализация ячейки
   - специфичные элементы сериализации вынести в Mary.Serialization пространство.
   - для поддержки мультиконтейнерного формата писать/читать идентификаторы как Int64.
   - сделана сериализация в двоичный поток и в массив. В массив сделано через двоичный поток в память.
   - надо сделать CRC16 алгоритм, пока просто суммируются байты
   - формат сериализации ячейки:  
     - тип записи MSerialRecordType.Cell (многовато для него 4 байт, сократить размер)
     - блок данных ячейки, полученный от .toBinaryArray() 
       - проверить что пишется размер блока и вообще размеры внутри него
       - по окончании разработки сериализации документировать форматы сериализации
          и происходящие процессы.

     - формат ячейки
      1)тип записи 1б
      2)длина записи, байт 4б
      3)ид ячейки 8б
      4)длина строки имени 1-2б
      5)символы строки имени
      6)ид stateID 8б
      7)ид typeID 8б
      8)ид valueTypeID 8б
      9)длина массива данных, байт 4б
      10) массив данных
      11) длина строки описания 1-2б
      12) строка описания
      13) isActive 1б
      14) Creatime 8b
      15) moditime 8b
      16) readonly 1b
      17) serviceflag 4b
      18) checksum  2byte
       - если строка пустая, выводится только длина строки (0х00)
         если не пустая, выводится длина строки в байтах(1 или 2 байта), потом символы строки, терминатор не выводится.   
       - выводится длина массива данных(4байта), потом сам массив, если не пустой.  
       - ИД выводится как 64-битное число, номер контейнера старший, номер ячейки младший.
       
May 27, 2012
Из таблицы в контейнер и назад - осмотреть, что вынести в файл проекта, что нельзя выносить.
+ versionId - версия движка. Нужна ли субверсия? Для проверки совместимости-нет.
+ step - номер шага структуры - номер последнего снимка
- project directory (skipped) - каталог проекта, не используется
+ log name - имя файла лога - имя убрать, номер вместо него.
+ log detail level - степень детализации лога
+ description - описание проекта
+ name - имя контейнера/проекта
+ service flag - служебный
+ state  - состояние контейера
- limiter (skipped) - для CSV-файлов, но нафик не нужен.
- step file name (skipped) - путь и имя файла снимка

- перенести все поля из таблицы в файл проекта.
  + переделать код открытия/создания/загрузки/сохранения контейнера соответственно.
  - неправильно, переделать обратно
    + из файла проекта убрать свойства контейнера - они будут загружаться из снимка или БД, или использоваться дефолтовые.
    + функции трансфера контейнер-файл проекта убрать.
    - в MSnapshot сделать функцию загрузки снимка в контейнер.
       функция должна загружать указанный снимок в текущий контейнер. 
        Пока только полный снимок загружать.
        - LoadFullSnapshot(string filename) - без кода.
        
- В контейнере и БД слое сделать функцию очистки таблиц БД от ячеек и связей.
   - public void MEngine.ClearProject() 
     - удаляет связи и ячейки из памяти, из таблиц.
       Надо еще переменные заново инициализировать.
   - internal void MDbLayer.ClearCellAndLinkTables() - надо бы индексы перестроить тоже.
- В БД слое сделать стат функцию создания новой БД
  - internal void CreateDatabaseTables()
    - код создает БД, еще надо таблицы и индексы.
- В MProject статич функцию создания структуры каталогов по файлу проекта.
  - public static void CreateProjectFolder(MProjectFile pfile) - код без учета ошибок.
    
- В MEngine статич функцию создания нового проекта целиком, с БД или без, по файлу проекта.
  - public static void CreateProject(MProjectFile pfile)  - код без учета ошибок.   
+ сделать доступ к данным проекта из всех менеджеров контейнера.  
- Осмотреть таблицу контейнера, убрать лишние поля, переделать код доступа.
  + MEngine.DefaultCellMode надо сохранять в таблице/снимке.
    - done not tested.
  + MLog.LogFileNumber - переделать таблицу и код весь - сейчас используется поле logname.
    - done not tested.   
Jun 01 2012
+ добавлено поле идентификатора контейнера в таблицу и в контейнер.
  - посмотреть весь код, где он должен использоваться, и переделать.
+ создание БД на сервере работает, если пользователь из dbcreator роли.
  - Таблицы еще сырые, еще надо будет их шлифовать.

Jun 03 2012
+ Сделано создание проекта с БД. Тестировалось.
- Сделаны
  ClearProject() - done, not tested
  DeleteProject() - done, tested
- Возможно, потребуется GetProjectStatistic() для вывода статистики по проекту.
  Часть статистики удобно хранить в файле проекта, для пользователя. 
- Сериализация в полный снимок
  - надо вывести содержимое памяти и содержимое таблиц.
    Поскольку содержимое памяти должно быть выведено 1 к 1, надо разделить вывод памяти и вывод таблиц.
    При загрузке сперва пишем таблицы, потом создаем и загружаем в память ячейки и связи, соответственно
     корректируя первичные ключи (в постоянных связях). 
    При загрузке содержимого памяти не используем типовое создание ячеек, а просто создаем ячейки конструктором.
    В итоге после загрузки должно быть тоже что и перед выгрузкой в снимок.           
  - т.о. сперва пишем содержимое таблиц,  затем содержимое памяти. Дубликаты ячеек там и там пусть будут.
    Проблема вывода большой таблицы - памяти/таймаута не хватит на результат запроса - надо как-то предусмотреть.   
  
Jun 08 2012
- Добавлены публичные функции апи для ячеек. CreateCell, GetCell, DeleteCell, UnloadCell. По идее, функции должны реализовывать безопасную операцию с откатом 
   изменений при возникновении ошибок. Пока ничего этого не делается, только выполняется основное действие.
   - Надо сделать полный код. 
   - deleteCell выглядит бесполезной. Ячейку можно пометить удаленной и через проперти экземпляра ячейки.
     Само же удаление должно производиться оптимизатором, но он пока не реализован. 
      Поэтому сейчас удалить ячейки из проекта можно только если они временные. 
- Проверить, что при создании связей используются/создаются копии идентификаторов, чтобы не было проблем. 

Jun 25 2012
- Добавлен класс MArg для описания аргументов методов. Взят из Тарр2, исключено поле ID, поскольку 
   ранее оно использовалось для контроля семантического класса.
   Сейчас это бессмысленно. А идентификатор ячейки есть в самой ячейке.
- Добавить класс MKta, только переделать, поскольку теперь это просто набор аргументов для единообразия использования.
  - добавлен. Из полей оставлены только список аргументов и результат.
- Переписать концепцию методов. Исполнение методов не входит в функции движка. 
   Движок предоставляет функции для исполнения методов-из-кода. Само исполнение возлагается на пользовательский код.
- не забыть после релиза накатать документацию по движку.
- просмотреть этот файл, освежить список проблем.
- сериализация 
  - ячейки
   MCell.toBinary(...) - перенесена в подклассы, поскольку MCellA и MCellB различаются.
   MCell.fromBinary(...) - не реализована
   MCell.toBinaryArray() - не реализована
   MCell.toTextString(bool withHex) - не реализована
   MCell.toText(System.IO.TextWriter writer, bool withHex) - не реализована
   MCell.fromText(System.IO.TextReader reader)  - не реализована
   
   MCellA.toBinary(...) - из таблицы получаем всю ячейку как MCellB, сериализуем как MCellB, но с MCellMode.Compact. 
   MCellA.fromBinary(...) - не реализована
   MCellA.toBinaryArray() - реализована через MemoryStream и toBinary. Вообще-то наверно надо наоборот, toBinary через toBinaryArray.
   MCellA.toTextString(bool withHex) - не реализована
   MCellA.toText(System.IO.TextWriter writer, bool withHex) - не реализована
   MCellA.fromText(System.IO.TextReader reader)   - не реализована
   
   MCellB.toBinary(...) - через  toBinarySub(System.IO.BinaryWriter writer, MCellMode cellmode)
   MCellB.fromBinary(...) - не реализована
   MCellB.toBinaryArray() - реализована через MemoryStream и toBinarySub.
   MCellB.toTextString(bool withHex) - не реализована
   MCellB.toText(System.IO.TextWriter writer, bool withHex) - не реализована
   MCellB.fromText(System.IO.TextReader reader)   - не реализована
   
  - связи
   MLink.toBinary(...) - реализована
   MLink.fromBinary(...) - не реализована
   MLink.toBinaryArray() - реализована через MemoryStream и toBinary. Вообще-то наверно надо наоборот, toBinary через toBinaryArray.
   MLink.toTextString(bool withHex) - не реализована
   MLink.toText(System.IO.TextWriter writer, bool withHex) - не реализована
   MLink.fromText(System.IO.TextReader reader)  - не реализована 
  
  - контейнер
   MEngine.toBinary(...) - не реализована
   MEngine.fromBinary(...) - не реализована
   MEngine.toBinaryArray() - не реализована
   MEngine.toTextString(bool withHex) - не реализована
   MEngine.toText(System.IO.TextWriter writer, bool withHex) - не реализована
   MEngine.fromText(System.IO.TextReader reader)  - не реализована 
  - менеджер снимков
   MSnapshot.LoadFullSnapshot(string filename) - не реализована
   MSnapshot.SaveFullSnapshot(string filename) - не реализована
   
- ячеек может быть не более 2млрд - ограничено размером cellID. Сколько может быть связей? В БД тоже не более 2 млрд, а в памяти? 
В снимке надо указать число ячеек и связей, используем int32, это не более 2млрд связей.  
- надо бы сохранение снимка сделать через классы. Например, заголовок файла сделать классом,
   чтобы пользовательский код мог получать описания снимков, не загружая весь файл.
   Да и остальной этот код уконтрапупить. 
   -как потом вписывать в заголовок счетчики связей и ячеек?
- структура полного снимка
  -сигнатура файла снимка 8 байт
  -заголовок снимка с длиной
  -секция контейнера
  -секция списка ячеек в памяти
  -секция списка ячеек в таблице
  -секция списка внешних ячеек
  -секция связей в памяти и таблице
  -секция конца файла (1 байт)  
! предполагается, что перед созданием снимка все ячейки MCellBds были сохранены.
   Хотя их можно сохранять прямо при сериализации при проходе-выборке временных ячеек,
    потом сохранять режим ячейки. Но вообще-надо подумать, как с ними быть.
    - сейчас получается, что постоянные ячейки сохраняются в БД, а временные в память. 
     Но так получается, что временные ячейки в памяти, а постоянные - нет. 
     Выходит, надо сохранять ячейки в памяти все подряд, и в бд - независимо друг от друга.
     Тогда загруженная в память постоянная ячейка будет в снимке дважды. Это решает проблему MCellBds,
      позволяет полностью сохранить/восстановить состояние контейнера на момент сохранения.  
      Но надо хранить их в снимке тогда раздельно - содержимое памяти и содержимое таблицы. 
      - переделать код вывода снапшота.
      - ячейки должны загружаться в таблицу, а потом в память? Желательно просто создавать ячейки в памяти
        и вписывать данные мимо официальных проперти, чтобы не менять ничего в БД. Так будет
         сохраняться состояние MCellBds ячеек.
        Сначала будем загружать в память, потом в таблицу. Тогда если код попытается изменить таблицу
         через экземпляр ячейки в памяти, будет исключение (да?). Это сигнализирует о неправильном коде.
         Хотя вообще-то без разницы порядок. 
    - еще, при загрузке постоянных связей надо заменять в памяти их идентификаторы - они являются 
       первичными ключами и зависят от состояния таблицы.
    - при загрузке временных связей их надо создать в памяти, добавить в список связей контейнера, 
       добавить в списки связей ячеек
      при загрузке постоянных связей их надо создать в памяти, создать в таблице, заменить 
       идентификатор связи в памяти из таблицы; если хотя бы одна из ячеек загружена в память, 
       но не является MCellA, то добавить в список связей ячейки в памяти, добавить в список 
       связей контейнера.
     Вопрос делать ли раздельные секции для таблицы и для памяти - в размере структуры в памяти.
     Связи не самостоятельные - если ячейка в памяти, связи тоже в памяти (кроме MCellA)
      Если большая часть структуры в памяти, то раздельные секции - дублируются.
      Если меньшая часть структуры в памяти, то много времени тратится на проверку наличия ячеек в памяти.
      Вообще, раздельные секции или нет - не существенно, поскольку нет отложенной записи связей.
      Но размер файла и время выгрузки-загрузки больше.
      Пока примем что только одна секция связей.
          
- придумать как выбирать связи и ячейки из таблицы порциями.
  Написать запросы и код для такой выборки. Определить размер выборки.
  -MDbLayer функции сделаны:
     internal List<MCell> getBandOfCellById(int rowFrom, int rowTo)
     internal MLinkCollection getBandOfLinkById(int rowFrom, int rowTo)
     internal int getMinLinkId()
     internal int getMaxLinkId()
  - MSerialRecordType добавлены типы секций. Можно убрать различные типы секций ячеек, но пока оставлю.   
  -ячейки: 1024-32-1. Выборка ячеек и создание списка в памяти.
   Разбиваем весь набор на секции по 1024. Если 1024 не прокатило, перехватываем исключение.
   Разбиваем 1024 на 32 секции по 32. Если не прокатило, перехватываем исключение.
   Разбиваем 32 на 32 секции по 1. Если не прокатило, перехватываем исключение. 
   Выбрасываем свое исключение, ибо раз и по одной записи не читается, значит все, пипец  
   Получается в общем неплохая конструкция. Надо отлаживать.
   description, value - поля могут достигать 2гб длиной
   name длиной 880 байт.
   Тест: сделать 1024 ячейки с description по 10мб, и попробовать их сериализовать. 
  -связи: 
   есть только одно поле переменного размера - description. Хотя оно предполагается обычно пустым, однако...
   остальные поля займут 36 байт + 16 байт на экземпляр + 16 байт на список
   т.о. типичный размер связи примем 80 байт. 
   8192-256-1
  -сериализация связей и ячеек отличается по вычислению длины от остальных частей снимка. 
    Надо упорядочить.  
    
 Навигация по снимку:
 -читаем сигнатуру 8 байт
 -читаем размер секции 4 байта sectLen : длина включает поле длины, это неудобно.
 -данные секции шапки длиной sectLen - 4.
  -число ячеек в снимке 4байт
  -число внешних ячеек снимка 4байт
  -число связей в снимке 4байт
  -версия движка 4байт
  -субверсия движка 4байт
  -номер шага снимка (версия данных проекта) 4байт
  -тип снимка 1 байт
  -имя проекта строка (включая длину)
  -описание проекта строка (включая длину)
  -checksum 2byte
  
 -идентификатор секции контейнера 1 байт
 -длина секции контейнера
 -containerid 4byte int 
 -name string with length
 -description string with length
 -stateId 8byte uint64
 -isActive  1byte bool
 -serviceFlag 4byte int
 -defaultcellmode 1byte enum
 -logdetail 4byte int
 -logaddsymbolicdata 1byte bool
 -lognumber 4byte int
 -dbtimeout 4byte int
 -snapshotStep 4byte int (???-да пусть будет - меньше мороки)
 -checksum 2byte
сюда не включеы свойства лога: кодировка, разделитель ксв формата.
 
 
 -идентификатор секции ячеек в памяти 1 байт
 -длина секции ячеек 8байт sectLen : длина включает само поле длины, поэтому следующая секция будет на sectLen-8
 -число ячеек 4байт
 -последовательные секции ячеек
 -чексум 2байт
 
 -идентификатор секции ячеек в таблице 1 байт
 -длина секции ячеек 8байт sectLen : длина включает само поле длины, поэтому следующая секция будет на sectLen-8
 -число ячеек 4байт
 -последовательные секции ячеек
 -чексум 2байт
 
 -идентификатор секции внешних ячеек 1 байт
 -длина секции ячеек 8байт sectLen : длина включает само поле длины, поэтому следующая секция будет на sectLen-8
 -число ячеек 4байт
 -последовательные секции ячеек
 -чексум 2байт   
 
 -идентификатор секции связей 1 байт
 -длина секции связей 8 байт sectLen : длина включает само поле длины, поэтому следующая секция будет на sectLen-8 
 -число связей 4байт
 -последовательные секции связей
 -чексум 2байт 
 
 -идентификатор секции конца файла 1 байт
 
 формат вывода одной ячейки: (сейчас такой)
 -идентификатор секции ячейки 1байт
 -длина записи 4байт : длина всей секции, включая чексум, поле длины, идентификатор секции
 -cellId 8байт uint64
 -cellmode 1byte
 -name string
 -stateId 8byte uint64
 -typeId 8byte uint64
 -valuetypeId 8byte uint64
 -valueLength 4byte int
 -description string
 -isActive 1byte bool
 -creatime 8byte datetime
 -moditime 8byte datetime
 -readonly 1byte bool
 -serviceFlag 4byte int
 -checksum 2byte short
 
 Формат вывода связи сейчас:
 -идентификатор секции связи 1байт
 -длина записи 4байт int : длина всей секции, включая чексум, поле длины
 -downCellId 8byte uint64
 -upCellId 8byte uint64
 -AxisId 8byte uint64
 -StateId 8byte uint64
 -isactive 1byte bool
 -serviceFlag 4byte int
 -tableid 4byte int
 -description string with length
 -checksum 2byte short
 
 Переделать:
  - значение длины секции не должно включать длину самого поля длины.
  - поле чексум не заполнять пока. чексумму не считать и не проверять. 
     Потом добавим это.
    
    -MLink done
    -MCellB done
    -MSnapshot done
    
Замечания: 
  -SqlServer при первом чтении записей жрет память и не освобождает ее обратно.
   Поэтому лучше бы его в отдельный компьютер пересадить. Пусть там растет.
  -814275 ячеек с краткими именами 62717617bytes  ~78bytes/cell
   и 403 связей дают 60мб файл снимка. 62737545bytes ~50bytes/link
   время выгрузки 2мин30сек 
  -Поскольку файл очень большой, надо писать и проверять чексумму секций.  
  -Текст сериализуется в анси, по байту на букву. Как это будет работать с русскими или другими текстами?
    Не придется ли переделывать или сохранять еще и кодировку файла снимка? 
    -По дефолту должно использоваться UTF8 формат - в MSDN сказано.
  - Сжимается хорошо 7зипом. до 4.33мб. Однако надо учесть, что структура ячеек неразвитая, в файле снимка одни нули.
  
Jun 28 2012
- добавлено вычисление чексуммы при сериализации. Чексумма пока простая - сумма байт.
  -не тест.
- public void MSnapshot.SaveFullSnapshot(String filename) - надо бы переработать код, 
   но надо сначала определиться со всеми свойствами.
- public static SnapshotFileInfo SnapshotFileInfo.Load(string pathname) сделано - функция возвращает инфу о снимке
  -тест ок
  -Этот класс для пользователя, чтобы получать инфу о снимке при выборе перед загрузкой. 
- кстати, при записи в некоторые проперти постоянной связи, она сбрасывается в таблицу целиком.
   Надо бы переделать чтобы записывались только изменяемые поля, но пока некогда.
- Десериализация MLink не приводит к созданию связи в таблице. 
   Концепция идентификатора не нарушается в снимке.
- Десериализация MEngine, MLink, MCellA, MCellB сделана, не тест.
  -переделать так, чтобы CRC проверялось перед загрузкой данных, а не после
  +переделать подсчет CRC из потока для уменьшения требуемой памяти, чтобы при загрузке большой ячейки память не обламывалась.
   - done
- Как делать десериализацию MCellA?
  -как и остальных ячеек, избегать записи в таблицу
- Проблемы
  - следует ли раздельно хранить число ячеек в памяти и в таблице - в заголовке снимка?
     сейчас они суммируются, но это вводит в заблуждение, поскольку загруженные в память постоянные ячейки в снимке записаны дважды.
     лучше включить в заголовок их раздельно - как объект статистики структуры.
  - можно ввести поля числа ячеек, связей, внешних ячеек в MProjectFile для пользователя.
    - можно ввести в контейнер средства получения этой статистики и сделать класс для значений, который потом использовать вместо раздельных переменных.
      - они также будут использоваться в полном снимке для создания хидера снимка без манипуляций с позицией файла. 
      - разместить в менеджере проекта.
      - класс MStatistics хранит данные статистики проекта. Получить данные можно через контейнер или менеджер проекта.
         Текущее состояние должно выводиться при записи файла проекта, при записи снимка, хорошо бы и при закрытии контейнера. 
         поля
         -связей в памяти (всех)
         -временных связей
         -связей в таблице
         -связей с внешними ячейками
         -ячеек в памяти (всех)
         -ячеек в таблице
         -временных ячеек
         -внешних ячеек  
  + нужна ли функция восстановления проекта из полного снимка и как это будет выглядеть?
    - пока нет. Снимок восстанавливает текущий контейнер. Для восстановления проекта вместе со снимком надо хранить файлы проекта. 
       Поэтому вообще говоря, в снимок должны бы входить также все файлы проекта - проект целиком.
       Однако тогда проще архивировать весь проект. Снимок просто представляет БД, или состояние контейнера на момент времени. 
  - нужно переписать код сериализации, объединив код секций в один, только разные функции вызываются согласно типу секции, через свич.
    соответственно переписать код десериализации. 
  + в ячейке надо тип ячейки хранить первым, чтобы меньше возни?
    - в целом, не имеет значения. все равно читать и возвращать обратно файловую позицию придется.
  - сделать на бумажке описание формата снимка, с позициями полей и охватом для поля размера.
     А то неудобно.  
  + вынести весь код работы с заголовком снимка в MSnapshotFileInfo, чтобы уже его весь использовать в коде.
    -либо приделать ему проперти файлового потока, либо давать этот поток извне класса - переделать его функцию чтения, чтоб принимала поток.   
	- done
- По статистике:
  + сделан класc данных статистики MStatistic
  + сделана функция получения статистики контейнера public MStatistic MEngine.getStatistics()
    - она будет довольно медленно работать, так как перебирает все ячейки и связи в памяти.
  - впихать статистику в файл проекта?
  - впихать статистику в менеджер проекта - чтобы оттуда вызывалась, как проперти
    - сейчас это функция контейнера. Нафик еще проперти?
  + впихать статистику в заголовок снимка - чтобы писалась из и в MStatistic в MSnapshotFileInfo.
    - done
  - куда еще потребуется эта статистика? 
  - предлагается сделать MSnapshotFileInfo  производным от MStatistic 
    +: поля будут удобно просматриваться в PropertyGrid-контроле, для этого не надо будет делать отдельные проперти.
    -: если вносить переделки в MStatistic, их надо вносить и в производные классы. 
     поскольку предполагается что снимок содержит информацию о моменте работы контейнера, 
      логично что он будет содержать статистику состояния контейнера. Хотя она избыточна для информации только о снимке. 
   + попробуем... 
  + добавить атрибуты в MSnapshotFileInfo и MStatistic для просмотра
    - done
  + переделано MSnapshotFileInfo
    + internal void LoadHeader(BinaryReader reader) - читает заголовок снимка в объект
    + internal void SaveHeader(BinaryWriter writer) - формирует заголовок снимка на основе данных объекта
    + public static MSnapshotFileInfo Load(string pathname) - статическая функция для просмотра свойств снимков перед выбором.
       выдает исключения при ошибках. 
    + internal void getContainerState(MEngine ct) - получает информацию из контейнера, для создания заголовка снимка   
 - сейчас новая реализация public void SaveFullSnapshot(String filename)
   + сделано, не тест.
   + заголовок снимка формируется через MSnapshotFileInfo
   - переделать сериализацию контейнера или оставить как есть?
     - можно переместить строки в конец секции, тогда остальные поля проще найти.
       Но пока что это не важно.
   + заменить код для каждой секции ячеек-связей на вызовы общей функции
     -сделано
   + в секциях-наборах ячеек-связей: поскольку CRC вычисляется для секции без подсекций, то можно его писать до подсекций - так удобнее проверять при чтении
     А вписывать можно после длины сразу. И порядок перечисления дескриптор-размер-дескриптор не нарушается, и читать проще.
     - сделано
   - о версиях структуры:
      -когда записывается снимок, его имя создается из номера версии из контейнера. Там номер будущей версии лежит или текущей?
      -когда записывается снимок, номер версии из контейнера выводится в снимок.
      -когда снимок загружается, номер версии восстанавливается.   
      -логично, что в контейнере лежит номер текущей версии данных. Тогда после создания снимка надо увеличить номер версии.
      Однако при загрузке номер версии восстановится, и следующий снимок будет с тем же именем, что недопустимо.
      Следовательно после загрузки и после выгрузки надо увеличить номер версии, чтобы состояние контейнера 
       после загрузки соответствовало состоянию после выгрузки.
       
Jul 04, 2012
 - делаем public void MSnapshot.LoadFullSnapshot(string pathname)
    создание снимка сделали, теперь для начала теста надо сделать загрузку.
   - не забыть прописать инкрементить степ после успешной загрузки снимка. 
   + private void LoadSection(BinaryReader reader, MSerialRecordType sectionType)
     + private void LoadMemoryCells(BinaryReader reader, int numOfElements)
     + private void LoadTableCells(BinaryReader reader, int numOfElements)
     - private void CheckRefCells(BinaryReader reader, int numOfElements)
     + private void LoadAllLinks(BinaryReader reader, int numOfElements)
 - вырисовываются ограничения числа элементов в структуре, налагаемые снимком  и движком в текущей реализации:
     -общее число пост и врем связей не более 2млрд - они в одной общей секции, секция не должна содержать более 2млрд элементов.
     -общее число пост и врем ячеек в памяти - то же самое. (где бы взять столько памяти?)
     -число пост ячеек - то же (ограничения идентификатора)
     -число врем ячеек - то же (ограничения идентификатора)(где бы взять столько памяти?)
 - имя файла полного снимка образуется из имени проекта и номера версии структуры.
    Как образуется имя частичного снимка?
    - частичный снимок состоит из ячеек, объединенных общим смыслом. 
      Имя снимка может отражать этот смысл, соответственно оно задается пользователем при создании снимка.
      Или же имя может быть случайным. Когда снимок используется как ресурс, имя несущественно, так как снимок является частью общей структуры.    
 - переделать все fromBinary на подсчет чексуммы прежде всех полей, кроме длины. 
 - для внешних ячеек нужен код формирования списка внешних ячеек. Это зависит от концепции.
    Если внешние ячейки копируются в контейнер (это не имеет смысла - они сами часто не нужны, нужна вся их обвязка), 
     то они существуют в контейнере, это кеширует запросы чтения (см сагу о синхронизации кешей). 
    Если не копируются, то они доступны только через связи ячеек. 
   Поэтому нужен код формирования списка идентификаторов внешних ячеек из списка связей контейнера. 
    Можно его прицепить к соответствующей функции статистики.

05 Jul 2012
- написан код десериализации. По результатам теста:
  - после загрузки надо бы обновить поля maxCellID в контейнере. 
    (Хотя они должны соответствовать, но только для полного снимка.
     Для частичного снимка ячейки добавляются, а не загружаются. 
     Хотя тогда бесполезно расходуется пространство идентификаторов - надо концепцию частичного снимка думать.)
  - посмотреть, что надо обновить после загрузки снимка.
  - тестирование записи:
    -пишется успешно. Формат пока не проверен.
  - тестирование чтения:
    -шапка читается успешно. Выглядит правдоподобно.
    -секция ячеек в памяти читается успешно - ячеек пока нет
    -секция ячеек в таблице читается, выдает исключение о наличии записи в таблице, поскоьку таблица не очищена.
      - зарисовать исключение, чтобы потом знать чего обрабатывать.
  - при загрузке снимка надо проверять, используется ли в проекте и снимке БД и если нет, выдавать исключение. Прописать в концепте структуру снимка при отсутствии БД - по существующему коду.    
             
06 Jul 2012
- надо спроектировать меню главной формы - для удобства операций с контейнером.
- надо добавить в контейнер флаг, что контейнер открыт или закрыт, чтобы не закрывать уже закрытый.
- тест:
  - создать новый проект
    - неудобно создавать проект.
  - заполнить образцовой структурой
  - сериализовать в снимок
    + исключений не возникает
  - очистить контейнер MEngine.ClearProject
    - удаление папки проекта выдает исключение что файл используется другим процессом
  - проверить состояние после очистки
    
  - десериализовать из снимка
    + исключений не возникает.  
  - проверить правильность структуры и процесса загрузки.
    + количество ячеек и связей соответствует.
    - надо проверить детально 
    - что-то в структуре многовато временных связей. Связи MCellBds тоже временные? 
- придумать как показывать статистику контейнера в свойствах проекта.
  - сделать MProjectFile производным от MStatistics - а как тогда получать статистику из контейнера?
  - сделать отдельную кнопку для показа статистики в диалоге свойств проекта.
  - сделать независимые проперти в MProjectFile и получать данные из контейнера? Надо и сохранять их в файле проекта тоже.   
- в MProjectFile имя файла проекта, версию и дату создания перенести в отдельную категорию атрибутов, а то они тусуются месте с редактируемыми полями.
  Имя файла проекта получается из имени проекта.
  - можно вручную заполнять таблицу свойств в диалоге, чтобы поля в ридонли установить.
- надо осмотреть процессы создания проекта, и переделать все, чтоб было удобно для пользователя. 
- надо прописать расширения файлов  в MProject аналогично именам каталогов и применить их в коде
- удаление проекта не работает. 

Текущее состояние проекта.
Сериализация полного снимка в двоичный файл вроде бы сделана, в общем. Сериализация частичного снимка требует разработки концепции. Введена, но не везде реализована, и в общем не готова, концепция работы без БД, как в Tapp2.
Работа с ячейками вроде вся сделана, хотя по ходу могут выявляться мелкие проблемы - это следствие пошаговой разработки концепции. Надо разрабатывать общую концецию работы пользователя с проектом, дорабатывать работу пользователя со снимками, интерфейс пользователя по управлению проектом.
Остальные части проекта схематично реализованы. Их детальную концепцию тоже надо прорабатывать.
Полные идентификаторы ячеек и контейнера примерно обозначены в концепции, но полностью не реализованы, оставлены пометки в коде для переделки.  
- предлагается сделать новую версию, рассчитанную на использование снимков, мультиконтейнер и прочие усовершенствования. Но прежде чем делать, надо разработать структуру проекта и план создания, чтобы можно было делать проект по маленьким одночасовым кусочкам, и приготовить средства документирования процесса, чтобы фиксировать все проблемы и решения. Новая версия предлагается локальная для внедрения в десктопные приложения, хотя должна быть вполне самостоятельной.
  Надо выписать основные проблемы и решения архитектуры, чтобы проще потом было понимать работу системы.

20 Feb 2013
- Разработка подсистемы ресурсов.
  - Набросаны прототипы функций, надо добавить код.
- Добавить поля для файлов в класс статистики
  - готово
  - Переделать код сериализации и везде где используется MStatistic
	- MEngine.getStatistics() - ok
	- MSnapshotFileInfo - ok
	- Проверить структуру и загрузку-выгрузку снимка, документировать изменения в классах и структурах. Метка = 210213.
  - Типы полей могут быть некорректны и не отражать реальные возможности движка.  
+ Функции конверсии в Hex вынесены сейчас в MObject класс. 
   Можно сделать статический класс MUtility и переместить туда все неотносящиеся к классам функции со всего проекта. 
   Так будет проще их искать при написании кода.
   - done
-  Hex-конверсию посимвольно - можно делать через класс System.Uri - Там есть статические функции  
- Получение информации о файле ресурса по идентификатору файла.
  - Функция internal FileInfo[] getFileInfosById(UInt32 fileId) возвращает массив описаний файлов с таким именем.
     Подходящих по ИД файлов может быть несколько - с разными расширениями. Хотя по концепции файл только один.
     Оптимизатор или пользователь должен удалять лишние, чтобы был только один файл ресурса с таким именем.
     Код должен использовать первый из массива файлов.
  - Ввиду неясности, что именно потребуется от файла ресурса пользователю, пока не создаем функции доступа к файлу.
    Когда будет ясно, тогда наделаем. Сейчас есть public FileInfo GetFileInfoById(UInt32 fileId) на все эти случаи.   
 - надо придумать тест подсистемы - с достаточными правами и с недостаточными правами. 
    Документировать возникающие исключения.
   - добавление файла ресурса
     - копирование
     - перемещение    
   - провепка существования файла ресурса
   - поиск максимального ИД файла  
   - подсчет статистики подсистемы
   - получение свойств файла ресурса
     - полное имя и путь
     - размер
     - дата создания
     - дата изменения
     - атрибуты
   - оптимизация
     - удаление пустых каталогов
     - удаление файла ресурса
 - Надо расписать исключения для каждой функции и при необходимости переписать код для обеспечения отката изменений.
 - Надо сделать документацию по готовым функциям подсистемы. 
 - Основные функции подсистемы ресурсов готовы к тесту.
   + Создать проект для тестирования
      C:\Temp\TappTest\
      В нее добавлена тестовая коллекция файлов ресурсов.
   + Прицепить БД
   - Написать код теста 
 - Тест подсистемы ресурсов проводить после теста новых функций создания-открытия проекта. Эти функции еще не сделаны, надо их сделать, и тестировать. А потом уже тест ресурсов.
 - Сервер БД запускается вручную, логин astra, пароль astalavista.
 
23 Feb 2013
- Для всех функций MResource описать возможные исключения. Пока нет публичного АПИ по ресурсам, незачем перехватывать исключения.
	- Сделаем после теста - вдруг придется переделывать код?
- делаем MEngine.ProjectCreate функцию.
   Это новая функция создания нового проекта.
  - Создание БД и создание таблиц разделено на две функции MDbLayer.CreateDatabase() и MDbLayer.CreateTablesIndexes()
     вместо одной старой MDbLayer.CreateDatabaseTables(). Так должно быть проще переделывать потом.	 
  - Надо протестить функцию, чтобы оценить возможные исключения.
     Поскольку эта функция используется только пользователем, незачем тщательно отбирать исключения.
     Надо проследить, чтобы она сама откатывалась при любых ошибках. 
  - Надо сделать для нее диалог ввода данных в тестовой оболочке.
    - сделано
  - тестируем на своем аккаунте
    - БД создается  
    - Таблицы и индексы создаются
    - каталоги и файл проекта создаются
  - тестируем на чужой папке
    - создать аккаунт к которому нет доступа
      - создан аккаунт, в нем папка, в которой запрещено создавать папки и файлы.
    - проверка
      - из диалога папок нельзя попасть никуда кроме МоиДокументы и ниже, так что проверка
        откладывается. Вообще-то это неплохо, но пока попробуем поменять на мой компьютер. 
      - папки в чужом аккаунте создаются, если не запрещено. Проблем здесь нет.
    - теперь есть три пустых проекта, на них проверим удаление проектов.   

24 Feb 2013
- MEngine.ProjectDelete написана.
  - Тест на своем аккаунте - успешно.
  - Если БД нет на сервере, удалить проект не удается. Надо придумать что-то, чтобы удалять проект, если БД удалена.
- Для MResource заявлены две функции Init() и Exit(). Вызываются соответственно в начале и конце сеанса контейнера.
  Надо и для остальных подсистем тоже сделать такие. 
  - done
- Добавлена MProjectFile.checkValues() для централизованной проверки свойств проекта.  
- Функции перестройки индексов и очистки проекта сделаем, когда будет большая БД и можно будет проверить их работу. 
   Интересно время выполнения. 
- MEngine.ProjectOpen() - оболочка для  MEngine.Open(), код сырой, надо переделывать. 
- MEngine.ProjectClose(...) - оболочка для  MEngine.Close(), код сырой, надо переделывать.  
- MEngine.ProjectSave()
  - Для проекта с БД функция сохраняет контейнер и все его MCellBds ячейки. Ячейки MCellBt не сохраняются.
  - Для проекта без БД сохранять нечего, можно обновить статистику контейнера в файле проекта, когда она там будет.
  + добавлены функции для сохранения всех ячеек MCellBds или MCellBt из пользовательского кода.
    - internal void MCellCollection.SaveCells(MCellMode cellMode)
    - public void MEngine.SaveAllTemporaryCells()
    - public void MEngine.SaveAllDelaySavedCells()
    Эти функции должны вызываться пользовательским кодом, но они сохраняют все ячейки указанного типа в контейнере.
    Для более разборчивого сохранения надо создавать специальные механизмы.
- MEngine.ProjectOptimize() - написать, когда будет концепция оптимизатора
- MEngine.ProjectStatistics() - переделывать.    

25 Feb 2013
- добавлена функция удаления таблиц связей и ячеек.
   private void MDbLayer.DeleteTablesCellLink();
- сделана функция для очистки проекта MDbLayer.ClearCellAndLinkTables()
  - Функция MEngine.ProjectClear() теперь должна быть более быстрой.
- Из-за блокировки папок ресурсов службой индексирования, MEngine.ProjectClear() иногда возвращает 
  исключение о невозможности удаления папок ресурсов. К этому времени таблицы бд уже обработаны.
  Однако, надо перепроектировать код, чтобы обеспечить откат изменений при любых исключениях.
- Есть большая БД, можно экспериментировать над ней. Надо сделать две или три БД, чтобы опробовать все варианты.
  - время доступа
	- время выборки ячейки
	- время обновления ячейки
  - оптимизация индексов	
	- степень фрагментации индексов
	- перестройка индекса
	- пересоздание индекса
  - удаление таблиц
    - время пересоздания таблиц
  - полный снимок
    - создание полного снимка
    - загрузка полного снимка  	  

26 Feb 2013
- Переделана internal MCell MEngine.S1_intGetCell(MID cellId). Теперь если проект без БД, функция не ищет ячейку в БД.
- Для кода поддержки проекта без БД назначен тег PRJNODB Надо его везде поставить.
  - ok
- Для полных снимков в контейнер добавлены функции работы со снимками.
  - public void SnapshotFullLoad(string snapshotFilePathName) - загружает указанный снимок в контейнер. 
    Контейнер должен быть чистым - только что созданным или очищенным от ячеек и связей.
    Очищать весь проект ProjectClear() нельзя если проект содержит ресурсы.
    - Надо определить процедуру очистки контейнера перед загрузкой, и проверки.
  - public void SnapshotFullCreate() - создает новый снимок  в каталоге снимков проекта.
    Снимок можно создавать в любом устойчивом состоянии контейнера, в отсутствие каких-либо процессов в структуре.
- При длительных процессах хорошо бы иметь индикатор прогресса. 
  Можно периодически вызывать событие, которому передавать степень завершенности процесса.
  Приложение пользователя могло бы получать это событие и отрисовывать прогресс.
  Это надо попробовать когда определимся с главными вещами.  
   
   
   
010313
- Добавлена функция internal Dictionary<UInt64, int> MLinkCollection.getLinkAxises().
  Она возвращает словарь осей связи, используемых в активных связях в памяти. Словарь содержит счетчики связей, что дает статистику по использованию осей связи.
  Она работает медленно. Предназначена для оптимизатора, который должен проверять список ячеек типа связи.
  Нужна еще одна такая же для связей в БД. 
  
- Для оболочки пользователя нужна функция контейнера для проверки уникальности имени ячейки.
  Из БД она будет запрашивать количество ячеек с указанным именем.
  Из памяти она будет запрашивать количество ячеек с указанным именем.
  Если в памяти есть такие ячейки, возвращать фальсе. Если нет, искать в БД.
  Если в БД нет, возвращать труе.    
  - public bool CellIsUniqueName(string cellName)

240313
- Приостановка проекта.
  Замечания
  - Не закончена переделка АПИ в части имен функций.
     Имя начинается с общего префикса, например, Project или Cell, затем идет название операции.
     Такое наименование упрощает поиск функции в списках и понимание ее задачи.
- Последующая работа над проектом предполагается в виде реализации запросов на изменение кода.
   Основная работа ведется над пользоательским проектом, в нем создаются запросы на изменение 
   кода навигатора и движка. Эти запросы можно накапливать, группировать и исполнять. 

010613
- Нужны идентификаторы связей
  Проектирование консоли, грамматики операций консоли, диаграмм структуры итд,
   сейчас упирается в невозможность однозначно указать экземпляр связи.
  У связей, насколько я помню, нет единообразного идентификатора. 
  Есть идентификатор записи в таблице БД. Временные связи не имеют уникального идентификатора.
  Можно предложить для связей завести такой же идентификатор, как для ячеек.
  Хотя это существенно увеличит расход памяти.
  Реально идентификатор связи нужен в грамматике, чтобы указать связь, находящуюся в БД. 
  В остальных местах можно использовать указатели на связь в памяти. Но это все равно неудобно.
  Для идентификатора можно использовать инт32, он добавит 4 байта к связи, и позволит создавать
   до 2млрд постоянных и столько же временных связей. 
  Механизм идентификаторов можно взять от идентификаторов ячеек.

240713
-Ввести класс для учета и создания новых идентификаторов ячеек, перенести туда весь код из контейнера, переделать остальной код.
Назвать контроллером идентификаторов или что-то вроде этого.
Изучить использование в коде.
Сразу переделать код на мультиконтейнерный вариант - в ИД в таблицах хранить ид контейнера и ид ячейки.
Сразу переделать концепцию на новые идентификаторы.
-Спроектировать затем такой же класс для связей, переделать код для поддержки идентификаторов связей.
 -Придется переделать таблицы в БД и весь код, который их использует.
 -Придется переделать класс связи и всю иерархию классов.  
  - в MElement ввести поле ElementId  для контейнера, связи и ячейки.
 -придется переделать сериализацию и все наработки по ней
 -придется обновить концепцию
 -практически это новая версия движка, несовместимая со старой.
  Имеет смысл осмотреть весь код и переработать концепцию с учетом имеющихся идей.
  
250713
Изменения в код проекта:
- ввести поддержку мультиконтейнерности
- ввести идентификаторы связей
- ввести выбор БД для проекта: MySql или MsSql2005
- провести ревизию кода проекта
(тут работы на 10 человек)
- внести соответствующие изменения в концепцию проекта
Структура проекта в деталях несовместима с предыдущими, это будет новая подверсия.
Соответственно, новый проект студии.
-создать документацию по проекту 
-идентификаторы ячеек в проекте:
 - m_maxConstCellID
 - m_maxTempCellID
 
 - m_dataLayer.S1_getMaxCellId()
 - m_cells.S1_getMaxTempCellID() 
 - changeIdCashOnRemoveTempCell
 - changeIdCashOnCreateCell
 - getNewCellId
 - S1_ChangeIdCashOnRemoveTempCell(int cellid)
 - S1_ChangeIdCashOnCreateCell(int cellid)
 - private int S1_intGetMaxCellTempID()
 - rivate int S1_intGetMaxCellConstID()
 Общий список переделок:
 Концепция:
 - Изменить концепцию в части строения идентификаторов
 - Обеспечить мультиконтейнерный вариант
 - Ввести сущности менеджера идентификаторов для ячеек и связей
    Описать их назначение, устройство и работу.
 БД - все поля идентификаторов в таблицах переделать на 2 поля: ид контейнера, ид ячейки/связи
 Иерархия классов:
 - все поля идентификаторов переделать на новый тип.
 - пока использовать один и тот же тип MID для ячеек и связей
 - переделать класс элемента и подклассы
 - переименовать поля классов для более точного соответствия названий
 Слой БД:
 - Составить список функций для переделки
 - составить план переделки и тестирования
 - Переделать существующие функции для поддержки новых идентификаторов
 - написать тесты для проверки работы подсистемы.
 - тестировать
 - Добавить возможность работы проекта на MySql
  - Проверить функциональную совместимость по возможностям БД
    При необходимости, провести проверочные тесты
  - спроектировать аналогичный по функциональности слой для MySQL БД.
   - Слой БД задает интерфейс. Надо спроектировать реализацию в разных субклассах.
      Потом при загрузке проекта загружать класс с нужной реализацией.
  - придумать, как выбирать нужный тип БД из настроек проекта.
  - внести изменения в концепцию проекта
  - переделать код проекта.
  - Написать код слоя
  - тестировать
  
14 ноября 2017 - возобновление проекта
- решил, что нужна уже работающая версия Движка. Пошарил по проектам - нашел вот эту. 
  Более поздние недоделаны намного, а в этой хотя бы движок и навигатор есть.   
  Новые изменения обозначать тегом //TAG:RENEW-13112017 - так их проще потом найти.
- В целом: 
  - движок работает, хотя недостаточно функционален. Пока можно использовать только в режиме без БД.
  - Навигатор работает, хотя недостаточно функционален. 
  - Пользоваться можно, хотя надо часто сохраняться и часто проверять, что получилось из сделанного.
- Теперь надо искать применение этому механизму.
  - пока нет БД, его можно использовать только для некоего анализа данных внутри процесса.
    - Это должен быть такой сложный анализ с классами, который нельзя реализовать без движка?
      - Ну, на движке это сделать проще, так как он уже есть. 
        Но надо подключать сборку к проекту, заводить солюшен, вспоминать, как это все работает.
        Это должен быть довольно сложный анализ, вроде разбора текста (предложения).
        Но и тут желательно уметь сохранять результаты.
- Замечания и Недостатки:
  - Тут можно создать солюшен и без БД, но:
	- идентификатор контейнера отображается знаком ? Потому что его вообще нет в классе MID. 
       А в объекте контейнера есть соответствующее поле, но оно = 0. Это недоделка осталась.
    - можно создавать только временные ячейки, так как нет сервера БД. Ставить не хочу.
      - можно поставить, если задача важная. Но пока нет такого.
      - можно переделать адаптер БД на MS Access. Но только если будет существенная причина для этого.
        Какой-то проект, в котором это будет использоваться.
        У меня есть проект БД словоформ - там можно это применить? Каковы требования?
	- солюшен надо сохранять в снимок при выходе, автоматически этого не делается.
  - Тут есть оболочка пользователя, но и в ней есть недостатки.
    + предустановленных ячеек в структуре сущностей нет, поэтому эту структуру надо 
       создавать самостоятельно каждый раз.
	  + написал функцию и сделал пункт меню для этого - теперь можно создать начальную структуру.
	- каждую создаваемую ячейку надо немедленно связывать с World хотя бы, 
	   иначе она потеряется - ее невозможно будет использовать. 
	   Это надо бы делать автоматически, но этого не делается сейчас.
	  - это не сделано, чтобы не отвязывать вручную каждую создаваемую ячейку.
	    Вообще, связи удалить сложновато тут. 
    - вылетают исключения, из-за них в любой момент можно потерять всю работу за сеанс работы.
	  - Надо перепроектировать весь движок, уж очень он экспериментальный.
	+ нет общего списка ячеек солюшена, поэтому никак нельзя просто перейти к нужной ячейке.
	  + сделал форму общего списка ячеек, теперь можно перейти к любой ячейке, 
	    находящейся в памяти, из формы навигатора.
    - нельзя вручную вписать идентификатор ячейки ни в связь, ни в данные места в списке мест.
      - Это и не надо, если все сделано нормально. Это заставит делать приложение качественно.
	- нельзя создать связь, если нельзя выбрать навигатором ячейку.
	- нельзя просмотреть свойства контейнера: хотя кнопка есть, но она не работает. 
	  - Там нет и формы и кода для просмотра свойств контейнера. Просто заготовка - недоделка.
	+ Список мест навигатора не работает с временными ячейками совсем. Это надо исправить.
	  + вроде исправил, работает теперь. Но для каждого проекта его надо заново настраивать.
         Начинать надо с места World - от него все остальное ведется проще.
         Эти места используются при создании ячеек и связей через Навигатор как свойства ячейки и связи по умолчанию.
    - Связь нельзя удалить из навигатора - нет для этого кода. Создать можно, а удалить никак.
	- Длинные имена ячеек не влезают в текстбоксы. 
	  - Текстбоксы рассчитаны на идентификаторы ячеек, а я там имена показываю.
        Но и идентификаторы ячеек там показываются, если имен нет.
        Я увеличил длину текстбоксов, но имена все равно есть длиннее их.
    - Идея сделать навигатор таким вот многоразовым превосходная - теперь я могу 
      создать ячейку и связи, и служебные ячейки для них за один раз, не прерывая рабочий процесс. 
      Главное не заблудиться в этих уровнях вложенности и не забыть создать какую-то нужную связь. 
      Но тогда уже нужны скрипты - там можно перепроверить и дописать упущенное.
      - Текстовые скрипты создания элементов структуры сущностей вроде бы были запланированы. 
      Но я не помню, чем это закончилось.
	- Пункт меню Очистить солюшен не работает.
	- Вообще, движок лучше из алгоритма использовать - он на это рассчитан в первую очередь. 
- Вообще, если структура сущностей, как сейчас, рассчитана на названия ячеек, то они должны быть уникальными.
   А в движке сейчас нет функции получения ячеек по названию - никаких вообще, только общий поиск по параметрам. 
   И тот не выведен наружу, просто где-то внутри существует.
   Зато есть функция проверки уникальности названия ячейки. 
   Тоже осталась от предыдущего прототипа или заготовка на будущее?
  - Ну, вообще да - рассчитана на уникальные названия ячеек. 
    А как иначе находить ячейки, если они не внутри одного алгоритма созданы, 
    и должны существовать после завершения приложения? 
    Идентификаторы тут не помогут. 
    Названия ячеек же я запомню и смогу потом повторно использовать эту структуру сущностей. 
    - Если этот Солюшен испльзуется для одномоментного анализа данных, и потом будет уничтожен, 
      то можно обойтись только идентификаторами, как сейчас.
    - Если Солюшен предполагается повторно использовать, то лучше использовать уникальные 
      названия ячеек для их указания. Идентификаторы ячеек не понятны сходу при чтении кода - требуется 
      лезть в Солюшен, чтобы понять, что они обозначают.  
  + я сделал функцию получения ячейки по имени - возвращает первую же ячейку с таким именем. 
     Из БД и из памяти. Имя ячейки регистрозависимое, поскольку в БД выборка так реализована.
    - не тестировал. 
       
14 ноября 2017
    //У этого проекта должна быть иконка паутины - я уже запутался в описании ячеек и связей.
    //Как можно быстро и просто строить тут структуры данных, 
    //если добавление первых 13 сущностей потребовало 33 ячейки и более 50 связей.
    //А добавление еще двух сущностей здесь - пользовательский аккаунт - 4 ячеек и 6 связей.
    //Это просто какой-то кошмар.
    //Что тут можно сделать?
    //- эти ячейки и связи описывают базовую инфраструктуру солюшена - и реализацию и структуру типов. 
    //Поэтому их так много получилось сейчас.
    //Если в будущем и дальше будет много новых типов, то и ячеек и связей будет много.
    //Это будет сложная работа, хотя ее можно автоматизировать - написать функции создания классов:
    //сразу и создавать ячейки типов ячеек и помещать их в коллекцию ячеек типов ячеек, и связывать с иерархией ячеек типов ячеек.
    //А если работа будет в основном с объектами, то сначала немного новых классов приплести, а потом 
      просто объекты к ним прицеплять, даже без связей.

    //Но все равно, я вижу, что тут нужна теория и навыки построения таких структур.
    //Ее разработка займет время, конечно, но нужен опыт использования.

    //Выводы:
    //- нужен опыт использования, нужно создать методику создания и строения структуры сущностей, типовые решения.
    //- нужно способ автоматизировать операции создания структуры сущностей. Хотя они зависят от строения Структуры сущностей.
    //   Это уже конфигурация получается, как в 1С. Тут надо методы Движка развивать.
    //- Концентрировать это устройство системы на работу с объектами. Так меньше ячеек надо создавать иможно использовать уже существующие.
    //- Развивать Структуру сущностей - чем больше в ней применимых классов, тем меньше их придется создавать каждый раз.  
 - в целом, если движок будет достаточно незаменим, то он будет и допиливаться и развиваться и в реализации и в методологии.
   - Надо искать ему применения.
 - против большой структуры сущностей есть методика: если сущность не необходима, незачем ее создавать.
   Вот у меня сейчас в начальной структуре сущностей пять коллекций служебных ячеек и коллекция аккаунтов пользователей.
   Зачем они нужны? Почему без них нельзя обойтись?
   - они уменьшают бардак в структуре и снижают сложность восприятия структуры сущностей при ее просмотре и понимании.
     Я более точно знаю, где искать нужную ячейку нужного типа.
     - вот это "снижают сложность восприятия структуры сущностей" недостаточно четко ограничено - это дело вкуса, настроения и свободного времени.
     - а можно ли измерять эту сложность структуры сущностей? Чтобы более формально это оценивать.
   - а коллекция аккаунтов пользователей - это вообще-то коллекция проектов, которые в структуре сущностей созданы и хранятся.
     Надо бы это переименовать так, более правильно. 
     Ведь там пользователей нет - там только разные структуры данных разных проектов могут быть.
     Правильно будет иметь один солюшен на один проект обработки данных.          
     
- переделка класса адаптера БД
  - причины:
    - Хочется уже иметь хотя бы один полностью законченный Движок, для опыта работы со структурой сущностей.
    - В проектах требуется движок с БД
    - Надо испытывать новую подсистему лога Тапп на реальном движке.
  - цели:
    - не потерять работоспособность без БД и на MSSQL2005 СУБД.
      - придется переделать состав MID, а это отразится на строении БД, так совместимость будет потеряна.
         И работоспособность на MSSQL2005 СУБД не гарантируется, а проверить не на чем пока.
         - развернем MSSQL2005, чтобы проверить - это несложно. В последнюю очередь, когда все остальное будет готово.
    - первый опыт реализации интерфейса адаптера БД - в виде базового класса, 
       функции которого будут переопределены в подклассах, собственно реализующих поддержку какой-то СУБД.
       И один класс для СолюшенБезБД - это должно упростить код движка в случае работы без БД.
       Не надо будет проверять  везде, есть ли БД - просто вызывать функцию, а она уже вернет правильное значение.
    - переработать названия функций, сделав их более понятными.
    - упростить код функций - их много и их приходится переносить в новый проект. 
      И их будет еще больше, когда проект будет более развиваться.    
  - 68 функций всего
    - их них 8 приватных - они не войдут в интерфейс Адаптера БД.
  - 20 полей
  - выполнение переделки:
    - я собираю решения из всех трех старых проектов, касающиеся адаптера БД, но они требуют переделки и остального кода проектов солюшена.
      - надо делать это минимально, чтобы не сломать и не запутать весь солюшен студии.   
    - сделал заготовку для базового класса MDbAdapterBase - оставил только заголовки функций без тела, удалил приватные функции.
      - надо переименовать функции правильно, чтобы названия соответствовали концепции и смыслу.
         Это должно сократить затраты драйва на их понимание при поиске в списке функций.
         Выведу в табличку экселя и там пропишу новые имена, а то сразу неудобно переименовывать - там
         еще и код переносить и переписывать надо для текущего класса MDbLayer. 
      - будем наследовать классы адаптеров от этого класса.
    + сделал пространство имен для адаптеров БД - папку Mary.DatabaseAdapters в дереве проектов студии.
    + добавил енум MDatabaseType для описания типов адаптеров БД - это поле сразу в базовый класс впихать, как часть общего интерфейса.
    - класс целиком MProjectFile надо заменить на MProjectInfo, и в него добавить поле тип БД (енум MDatabaseType).
      - уже добавлено ранее. 
      - А в форму создания проекта добавить комбобокс с этими типами БД вместо галочки NoDB.
      - А еще он используется в файлах снимка - там тоже надо переделывать.     
    - Выбрать один из классов: MVersion (old) или MVersionInfo - что оставить, весь код проекта студии на него переделать.
      + создал новые два класса MEngineVersionInfo и MSolutionVersionInfo - переделывать весь код на них!
      - требуется объект и проперти версии движка в классе MEngine, инициализируемый в конструкторе MEngine.
        - сделал, но теперь его неоткуда взять - требуется или ссылка на контейнер, или статический объект в контейнере.
        - это же версия всего движка - ее надо брать из версии сборки, и все дела.
          - тогда и версию сборки мне придется контролировать. 
        - Все равно же версия берется из статической строки константы - так и сделать ее статическим проперти.
        - переделать: константы все движка и солюшена (кроме приватных в подсистемах) хранить в объекте настроек солюшена, 
           то есть, в MProjectInfo.
           Туда перенести эту константу версии. Объект версии собирать из константы по требованию, там где он нужен.
           Объект MProjectInfo прицепить в поле как часть MEngine - он будет хранить часть свойств контейнера, 
           доступных всем через проперти MEngine.
           + константу версии и ее обвязку перенес в MProjectInfo. 
           + Объект MProjectInfo добавил как MEngine.SolutionSettings.
           - остальные поля - позже, слишком много изменений сразу.
        + пометил все места с версиями тегами //TODO: TAGVERSIONNEW: 
        - надо разгребать эти переделки-изменения, иначе проект увязнет в недоделках. Он и так уже затягивается. 
    - доделал шаблон классов адаптера бд, размножил по классам.
    - теперь надо перенести (копировать с переделками) функционал из MDbLayer в MDbAdapterMsSql2005 
      - и написать похожий код в MDbAdapterMsJet для OleDb типов. 
      - И на этом работа с БД будет пока закончена.

16 ноября 2017
- перенес функции создания и удаления БД, но придется переписывать под них код движка и приложений.
   Так как архитектура движка на тот момент была неупорядоченной, то много оригинальных неоптимальных решений в ней.  
  - переношу код MDbAdapterMsSql2005
    + все функции перенес и некоторые переделал немного. Поэтому они могут оказаться нерабочими. 
      Надо писать тесты движка, они пригодятся на других адаптерах БД.
    + компилируется успешно, все ошибки исправлены.
  - создал резервную копию солюшена студии для отката от неудачи.
  - не надо переделывать интерфейс ImSerializable, хотя и вроде есть потребность.
    В старых версиях вывод в массив реализован через MemoryStream.
    А вывод в строку вообще не реализован, как и вся работа со строками. Но и там можно через какой-нибудь StringWriter.
  - попытался заменить класс адаптера БД и по-быстрому проверить и согласовать изменения в проекте.
    - не вышло - надо переделывать и отдельные функции и всю ту часть архитектуры движка, что управляет солюшеном.
      Там так много всего недоделано, непродумано, что просто жуть.
      Надо пилить эту кучу недоделок по маленьким частям - сначала то, что уже наметил, потом последствия всех этих переделок.            
    - можно строение управления солюшеном посмотреть в последней версии проекта Тапп 
      - там она должна быть более проработана и более лаконична, чем я сейчас наскоро изобрету.
      - сейчас объекты адаптера бд и остальных менеджеров создаются при открытии солюшена - так я переделал код.
        И надо их же при создании солюшена так же создавать.
      - закрытие солюшена я вроде исправил, но не знаю, насколько правильно.    
      - MDbAdapterBase уже надо перепроектировать - некоторые функции изменились. 
        MDbAdapterMsSql2005 обкатывает эти изменения, он будет потом образцом.
    - вот встрял я с этими переделками - разворотил весь движок и теперь буду его собирать на новый лад - проще заново его спроектировать и написать, наверно.
       - надо перепроектировать функции создания и открытия солюшена - там все наскоро сделано, без концепции.
- оказалось, нельзя использовать статические функции в классе адаптера БД.
   Потому что селектор типа БД возвращает объект адаптера БД соответствующего класса.
   И вот этот объект должен делать всю работу как ему нужно, переопределяя свои функции.
   И нельзя из кода вызвать переопределенную статическую функцию правильного класса.
   Поэтому теперь надо все их переделывать и перепроектировать.
   И все функции создания удаления и открытия закрытия солюшена надо перепроектировать и переписать заново.
   + createCоnnectionString() переделал (перенес внутрь объекта БД) и сделал упрощенный вызов с ФайлСолюшена. 
     Во всех классах БД.
   + заменил поля версии движка и солюшена в МSnapshotFileInfo.
     Переделал сериализацию и десериализацию в нем сооответственно. Не тестировал.
   + сделал проверку версии движка при открытии Солюшена. Не тестировал.
   - устранил другие ошибки, сейчас солюшен компилируется. Но что вообще в нем происходит - я не понимаю.
     Слишком много изменений без общей системы - это все в солюшене теперь надо перепроектировать и переделать.  
     Часть задач описана в ТОДО-тегах, но не все.
   - надо полностью пересобирать набор подсистем, их инициализацию и завершение работы.
   
25 ноября 2017
+ создал еще одно, консольное, приложение только для теста движка.
  + в нем написал два сценария: для создания солюшена и для открытия солюшена.
    Это позволяет более определенно проектировать работу солюшена - дело должно пойти быстрее.    
- накидал создание солюшена - теперь надо тестировать.
  + переделал форму свойств нового проекта в TestShell проекте приложения. Вроде работает.
  - нужен сервер БД и пользователь с правами создания БД на нем 
- оказалось, что сохранение и закрытие солюшена - куча недоделок.
  Там есть и сохранение солюшена в промежуточных состояниях,
  и сохранение при закрытии солюшена, и закрытие солюшена без сохранения.
  Вот эти все функции надо осмотреть, определиться с их состоянием и решить, 
  какие из них реально будут использоваться в каких случаях.
  А сейчас их слишком много разных там. Надо сократить.
  И надо проверить, что при сохранении или закрытии солюшена его свойства сохраняются обратно в ФайлСолюшена.
  - тут просто внедрение концепции солюшена произошло без окончания переделки существующего кода, 
     поэтому остались вот эти дублирующиеся функции. Надо сначала определить, в каких ситуациях они используются и что должны делать. 
     А потом перепроектировать эту часть движка вокруг них.
  - public void SolutionClose(bool withSave) - закрывает открытый солюшен. Ее оставим.
  - public void SolutionSave() - сохраняет открытый солюшен, но не закрывает его. Ее оставим.
  - public void SaveAllDelaySavedCells() - надо анализировать случаи применения
  - public void SaveAllTemporaryCells() - надо анализировать случаи применения
  - public void Save() - удалена
  - public void Close(bool withSave) - удалена
- изменились процедуры выгрузки и загрузки полного снимка солюшена - их надо тестировать теперь.             

26 ноября 2017
- развернул SqlServer. описание в файле.
  - юзер с группой dbcreator не может удалить БД, только sa может удалить.
  - сейчас тестирую создание БД. 
  - Из-за ошибки в коде программы удалилось все, что было в каталоге Temp. Вроде бы там ничего важного не было, но все же...
    Надо более аккуратно подходить к тестированию программ - а не делать все в одной куче.
    То есть, нужно готовить рабочее место к тестированию, а не как сейчас. 
    Сейчас бардак - все где попало валяется из-за совмещения рабочих мест.
    Надо не оставлять кучу недоделок - тогда и теряться меньше будет.
  - создание БД проходит успешно, а вот открытие - нет, так как версии солюшена и движка не сохраняются в БД и не загружаются из нее. 
    Надо переделать таблицу контейнера в БД.
    - Для этого надо создать эту таблицу сначала, потом в ней проделать изменения и сгенерировать новые запросы по ней.
    + переделал, тестировал, вроде работает, но я не уверен, что все сохраняется и восстанавливается.
  + Также, версия движка или солюшена не выводится в ФайлСолюшена и не загружается назад. 
    Поэтому открыть солюшен не удается - срабатывает проверка версии движка.
    + исправлено, теперь солюшен можно открыть. 
  - Теперь номер файла снимка - номер шага - входит в состав объекта версия солюшена, 
     и должен инкрементироваться в объекте свойств солюшена в контейнере, а не в менеджере лога как сейчас.
    Но это все надо отслеживать и переделывать - сейчас там все запуталось.
    И далее запутается еще больше. 
- сейчас солюшен открывается и закрывается, но не все там правильно.
  - теперь надо тестировать ячейки и связи - как они там сохраняются и изменяются.
    Это долго и нужен план тестирования.
  - потом надо тестировать сохранение в снимок и загрузку из снимка.
  - и в конце концов это все равно одна большая недоделка - тут все надо перерабатывать, строго проверять архитектуру движка.
    Это должно сейчас быстро дать движок для накопления опыта - но не более того.
    Для реального использования это все надо разобрать, переосмыслить, переделать и заново собрать.          
- Надо шире использовать MSolutionInfo (бывший MProjectInfo) класс в менеджерах подсистем - в 
   нем и хранить все эти ШагБазы, НомерФайлаЛога итд.
  Тогда и обратно их вписывать не надо будет, и остальные подсистемы могут получить 
  свежую информацию сразу а не по окончании сеанса Движка.
  - Эти переделки отложим на потом - сейчас надо отладить основные части проекта.
  + я их таки сделал, теперь надо тестировать. 
    - Главное - объект свойств солюшена должен быть уже вписан в контейнер к моменту первого его использования.
    - Классы стали немного более лаконичными и простыми после удаления лишних полей.
    + первый тест прошел успешно, но я не уверен, что свойства солюшена, 
      которые записываются из БД, не перезаписывают себя в настройках солюшена.
      Если СолюшенБезБД, то как они будут загружаться из БД, которой нет?
      Эту часть процесса надо переработать - надо убрать загрузку контейнера из БД - вообще.
      Там все равно данные хранятся только для описания БД - достаточно будет их туда записывать, но не извлекать никогда.
    
27 ноября 2017
- надо добавить в файл солюшена флаг, что пароль и имя пользователя не сохранять в файле настроек.
  Это надо добавить и в концепцию движка Тапп как новую особенность.
  Сейчас логин и пароль пользователя сохраняются в файле солюшена как есть.
  В концепции сказано, что если они не указаны, их надо запросить у пользователя отдельным диалоговым окном.
  Этот запрос должен происходить при открытии солюшена. Окно должно предоставить приложение.
  Но файл солюшена перезаписывается несколько раз в течение работы движка.
  Поэтому в нем хорошо бы иметь такой флаг - сохранять ли логин и пароль пользователя в файле солюшена.
  Пользователь может захотеть запомнить пароль и не вводить его каждый раз.
  Тогда логин и пароль должны храниться в файле солюшена, как сейчас это происходит.
  А можно передавать их как аргументы при создании и открытии солюшена.
  Но это неудобно на БД, не требующих логина и пароля - это не универсальное решение.
  Поэтому вот такие сложности в этом. И поэтому мне сейчас незачем это делать - тут надо все продумать, 
  хотя это и небольшой кусочек жизни проектируемой системы.

29 ноября 2017
- вроде переделка закончена, хотя ее еще надо проверять.
  - там много недоделок вообще-то. Это я сейчас только получил первую сборку без ошибок, 
     и уже обрадовался, что все, можно пользоваться. 
- надо теперь переделать движок для поддержки адаптера СолюшенБезБД.
  - сначала надо провести тесты и убедиться что движок работает правильно.
     Это упростит последующую переделку движка.
  - надо написать тесты автоматической проверки. 
     Но это сначала надо их придумать, и весь процесс этой проверки.
  + тест записи свойств солюшена полностью провален - свойства контейнера не записываются в ФайлСолюшена,
     поэтому при загрузке солюшена в нем сохраняются старые значения.
     Хотя в БД они записываются, но потом эти поля контейнера перезаписываются из ФайлСолюшена.
     - вообще-то незачем их из БД извлекать при загрузке. 
       + сделано, закомментировал вызов функции загрузки контейнера.
         Сама функция осталась нетронутой. Хотя она вроде бы не нужна, но вдруг пригодится зачем-нибудь... 
       И сами поля эти не нужны в контейнере - их проперти привязать к НастройкиСолюшена или вовсе туда перенести.
       + переделано: поля свойств контейнера удалены, проперти контейнера используют проперти объекта НастройкиСолюшена.
         Теперь тест проходится успешно. 
         В коде пока остались закомментированные строки, я их потом удалю, когда остальные тесты покажут что все успешно сложилось.       
         Код проекта стал еще немного проще и лаконичнее. 
  - Хотя это не должно вызвать проблем, все же не рекомендуется менять НазваниеСолюшена после его создания.
    - Это значение используется для создания имени файла снимка.
    - Путь каталога солюшена берется из текущего пути ФайлСолюшена, поэтому солюшен можно перемещать, пути скорректируются.
  - нужны тесты ячеек и связей. Эти тесты потребуются много раз во время проекта, поэтому их надо основательно спроектировать и реализовать.
    Можно поодиночке их сравнивать, а потом небольшую структуру создать и проверить ее.
    - функции ячеек: нужно проверить для каждого типа ячеек - всего 4 типа.
      Надо описать, что должно произойти в результате операции.
      - создание: MCell c = d.CellCreate(MCellMode.Compact);
      - изменение:
      - сохранение: c.S1_Save();
        - исключение при сохранении временной ячейки. Надо воспроизвести тест.
      - выгрузка из памяти: c.S1_Unload();d.CellUnload(MID.InvalidID);
      - получение из контейнера: d.CellGet(MID.InvalidID);        
      - удаление: c.S1_Delete();   d.CellDelete(MID.InvalidID);
    - функции связей: для всех 4 типов ячеек,  всего 16 вариантов связей.
      - создание
      - изменение
      - удаление
      
6 декабря 2017
- надо собрать все задачи с начала переделки сюда, а то этот лог уже слишком длинный.
  Я могу забыть про поставленные задачи.
- тест ячеек неудачный. Надо описать, что успешно, а что нет.
  + успешно создание и заполнение всех типов ячеек
  + успешно сохранение в БД всех типов ячеек.
    - была выявлена и исправлена ошибка - при сохранении Temporary ячейки не изменялся СписокЯчеекКонтейнера,
      в нем эта ячейка оставалась под старым ключом. Замены производились в самом объекте ячейки только.
      Сейчас и СписокЯчеекКонтейнера все правильно содержит. Тестирование успешно.
    - ранее также при смене CellMode выбрасывалось исключение - срабатывает ограничение, 
       запрещающее менять тип ячейки для временной ячейки.
       Это ограничение введено для операций смены режима пользователем, но оно срабатывает сейчас, 
       для случая смены режима ячейки внутри движка. Это неправильно.
       + Предлагается перенести код из public void MCell.S1_Save() в подклассы, где проще реализовать
         требуемую подмену. Это надо оценить - доступны ли там вызываемые подфункции?
         + да, код перенесен, тестирован, успешно.
       + Предлагается запретить смену CellMode ячейки пользователем, чтобы упростить эти проверки
          и уменьшить сложность в понимании работы движка. Но это еще надо продумать.
         - все равно пользователь может для ячейки сменить MCellB на MCellBds только, остальное под запретом.
           И зачем ему такая возможность? 
           Можно ведь сразу ячейку загрузить как MCellBds или выгрузить и загрузить заново. 
         - надо найти и отметить все случаи, когда изменяется режим ячейки в коде движка.
           Тогда сможем отделить пользователя от движка в этом плане.
         + проперти MCell.CellMode.set переведено в internal во всех подклассах. 
           Теперь пользователь не может изменить режим ячейки в процессе ее жизни.
           Если это не понадобится нигде, то так и оставим.
  - выгрузка ячейки из памяти почему-то не реализована.
    - S1_intUnloadCell(MCell cell) выглядит законченной, но ее вызовы закомментированы.
      Выгрузка производится по cellid, хотя по объекту ячейки проще - непонятно почему такие сложности.
    - надо снова подключить и тестировать работу на ячейках. И особенно - на связях!!! Там могут быть проблемы.
      + подключена, тестирована на ячейках без связей, успешно.
      - если ячейка уже выгружена из контейнера, повторная выгрузка тихо завершается.
        Но все равно надо принимать какие-то меры, чтобы нельзя было использовать далее эти выгруженные ячейки.
        Или выявлять случаи их использования.
        - завести внутри ссылку на контейнер или флаг, что ячейка была выгружена? Ссылка на контейнер полезнее.
                                   
  + успешно получение ячейки из контейнера по ид.
    Если она есть в памяти, то извлекается из памяти.
    Если нет в памяти, то загружается из БД в режиме, указанном в MEngine.DefaultCellMode.
  - тут нет функции для загрузки ячейки в нужном режиме MCellMode. 
    Пользователь не сможет загрузить ячейку в нужном режиме, так как нет функции для этого.
    Ее надо создать. Назвать вроде CellLoad(MID cellid, MCellMode mode)
    - надо изучить этот вопрос.
    - тут нужна именно функциональность загрузки ячейки строго указанного типа. Для остальных случаев сгодится MEngine.CellGet()
    - если ячейки с таким идентификатором нет в контейнере и в БД, функция возвращает нуль.
    - если ячейка уже загружена в контейнер, но не указанного типа, функция возвращает нуль.
    - если ячейка уже загружена в контейнер и она указанного типа, функция возвращает объект ячейки.
    - если ячейка не загружена в контейнер, функция загружает ячейку под указанным типом и возвращает объект ячейки.
    - если в процессе работы возникает ошибка, функция выбрасывает исключение.
    + сделаны сразу два варианта : выборка ячейки по cellId и по cellTitle.
       Они одинаковые почти, только функции выборки разные.
       Функция выборки по названию ячейки будет работать медленнее чем по ИД, так как поиск в СписокЯчеекКонтейнера 
       реализован перебором всей коллекции ячеек до первого совпадения.
       Тестированы, успешно.

21 декабря 2017
 - застрял на удалении связи - никак не возьмусь за работу над проектом.
   - эта тема теоретически вроде не проработана достаточно?
     - найти описание операции в концепции. Если его нет - отдельно разработать эту операцию!
   - связь должна быть помечена неактивной только - удаления ее не происходит, она (связь) просто должна игнорироваться.
   - собственно удаление связи из памяти и таблицы производит оптимизатор, но он пока не придуман.
   - в старых проектах тапп23 тоже ничего не реализовано в этом - все так же, как и здесь.
   - надо просто найти связь, чтобы пометить ее удаленной. И этого кода тоже нет в старых проектах.
     - связь ищем по двум ячейкам и типу связи. Ищем в таблице и в списке связей контейнера. 
     - Если одна из ячеек временная, то и связь временная - ищем ее только в списке связей контейнера.
     - если ячейка постоянная (MCellA), то ее список связей не хранится в памяти, 
        а загружается из таблицы связей БД каждый раз, когда он запрашивается.
        Даже для получения числа элементов коллекции. 
        Это долго, так как он еще и согласовывается с связями, уже загруженными в список связей контейнера.
        Поэтому список связей такой ячейки надо получать один раз и далее специально хранить в памяти, а не как обычно.
        Искать меньший список в этом случае нерационально - экономии не будет.
     - Если обе ячейки MCellA, то ищем в списке связей любой из ячеек, так как 
        ячейки MCellA не загружают свои связи в список ячеек контейнера - эти связи существуют отдельно, 
        и изменения в них сразу записываются в БД (проверить это!).
     - если одна из ячеек MCellA, то ищем связь в списке связей в другой ячейке?
     - а если эти обе ячейки не загружены в память, то как быть? 
       + обе ячейки должны быть загружены в память для поиска сейчас.
       
 23 декабря 2017
 + сделал поиск связи, не тестировал.
   - пока только просто - поиск в списке связей текущей ячейки. Оптимизацию решено потом приделать, когда определимся, нужно ли это.
   - можно искать только активные связи или же все подряд.
 + сделал функцию удаления связи ячейки - пометка связи неактивной.
   Неактивными помечаются все связи, которые отобраны по заданным параметрам.
   Обычно должно быть всего одна связь с такими параметрами, но их может быть и больше.
   Функция возвращает число измененных связей. Это могло бы пригодится где-нибудь потом.
   - еще нужна функция удаления связи оптимизатором.
   - надо бы убедиться, что неактивные связи не обрабатываются потом так же, как и активные.      
     - этот вопрос вообще-то не продуман никак.
   - надо тестировать работу операций удаления связей.  


6 июля 2018
- Я сейчас на этот проект смотрю, словно в первый раз его вижу.
   Как его доделывать, когда я ничего не понимаю в сделанном ранее?
 - надо писать заново описание движка - с нуля, и только для такого вот восстановления знаний.
 - надо более тщательно разделить код движка на подсистемы.
 - надо выкинуть из солюшена совсем уж левые проекты-приложения. Оставить только приложение-тест, сам движок и приложение-браузер.
 - надо все же описывать структуру подсистем, если не умл-диаграммами, то хотя бы текстом.
 - тут и концепция тоже не доделана - все по ходу дела переделывается, она не соответствует текущему коду.
 - надо уже переписывать движок на более простой вариант, но и его концепция не закончена. 
   Не хочется переделывать движок заново - этот раз может совсем не пойти и проект завянет окончательно.
 - почему мне с этим проектом невезет-то? Опять застрял с ним. Чем дальше, тем хуже.
   - он слишком большой для меня. Я никак не разберу его на отдельные куски поменьше.
   - он до сих пор не имеет реального применения, поэтому и мотивации его закончить нет. 
     И даже частичное применение не предусматривается пока. Надо найти ему реальное, важное применение.   

13 июля 2018
- Надо инвентаризировать коды и сообщения ошибок. Они должны передаваться  через исключения и Лог.
  Надо собирать их в класс вроде ErrorMsgController.
  С функцией Получить сообщение ошибки по ее коду.
  И функцией Распечатать все сообщения об ошибках в список для разработчика.
  Вначале описывать ошибки непосредственно в коде, а перед релизом переводить их в список сообщений.
  Этот процесс инвентаризации ошибок и их сообщений - отдельный этап при разработке движка.
  Хорошо бы создать целый объект сообщения об ошибке, где хранить код сообщения, текст сообщения и описание ошибки.
  Описание ошибки позволит лучше понять смысл события.
  Хотя сейччас это выглядит излишним и несвоевременным. Пользователю движка нужен только факт ошибки. 
  А разработчику движка доступен исходный код движка, в нем все и так понятно.
  - В С# нет макросов, поэтому не получится легко и без переделок оформлять и код ошибки и текст сообщения.
    И ситуации ошибок пока не проработаны, и их обработчики. Весь движок собирается на авось прокатит.
- Подсистему лога надо делать отдельным проектом Dll. Так проще ее развивать.
  - для начала, сделать ее в подпространстве имен с номером версии подсистемы лога.
    А потом, когда все будет успешно реализовано, можно и вынести в отдельную длл.
    + классы лога вынесены в папки подсистем.
      Хотя сейчас это первая версия подсистемы лога - там и лог не ведется совсем.
      Но затем планируется более сложная версия, с поддержкой отката транзакций по логу.
      Вот для нее эти все особенности нужны.       
      
14 июля 2018
- Не на чем тестировать текущую сборку проекта.
   Я не могу сейчас придумать никакой способ использования движка, чтобы тестировать его.
   все что приходит в голову - слишком сложное для изготовления теста, и непригодное практически.
  - разве только Инвентарь БД принести на Тапп. 
    Но для него сначала надо разрабатывать систему классов ячеек.
    Это называется пользовательская часть концепции солюшена.    
    И потом ее некуда применить. Просмотреть нельзя - браузер не готов для этого.
    Проект надо слишком много доделывать, чтобы применять его хоть как-то.
    - Надо осмотреть код и запланировать требуемые функции и их разработку для такой готовности к сценариям использования.
    Сейчас можно применить проект только для каких-то локальных задач по переработке и реклассификации данных.
     Но у меня таких задач пока нет.  
  - Отложить работы по движку пока нет условий для тестирования.
    - Сейчас можно дорабатывать подсистему лога. Концепция для нее начата, не закончена.
    - другие подсистемы тоже можно пока проектировать и улучшать, но сначала только в концепции.   

10 января 2019
Решил взяться наскоро наклепать адаптер БД для мс Аксцесс, чтобы запустить этот движок.
А то новый еще не скоро изготовлен будет - долгое это дело получается.
А этот старый движок - можно поиграться, подумать куда приспособить.

- реализовал функции класса MDbAdapterMsJet
  + это было сравнительно легко, за 8 часов управился. Поскольку класс простой; набор функций знакомый; 
    функции уже описаны тегами документации; код можно брать из похожего класса и немного исправлять; 
    код структурирован подразделами; достаточно много наработок-примеров в других моих проектах. 
  - путь к файлу БД должен располагаться в MSolutionInfo.DatabaseServerPath
  + заготовка БД размещена в ресурсах сборки, функция ее извлечения уже добавлена в код.
    - но заготовка пустая, сама БД еще не реализована.
+ надо реализовать саму БД - наполнить таблицами и индексами.
  + выполнено. 
- Надо проверить, что вызываются функции создания БД, удаления БД итп из функций входной группы Движка.
  + Создание БД вызывается успешно.
  - Удаление БД 
- надо проверить исполнение запросов БД - они наскоро портированы, ожидаются мелкие ошибки.       
  
12 января 2019
- провел тестирование запуска Солюшена на СУБД Аксцесс. Текущие тесты успешны.
- надо составить список тестов для Солюшена.
  - для начала взять их из существующего кода тестов.
  
06 января 2020
- небольшая уборка в файлах проекта. 
  - сменил платформу на х86, так как на платформах х64 Аксцесс БД не запускается.
- все проекты компилируются
- в записях сказано, что тут есть недоделки, но я их пока не обнаружил.
- Задача: доделать движок для его использования в Оператор. 
  - БД Аксцесс
  - движок создает Солюшен. Надо описать структуру файлов Солюшена и решить, как он будет храниться в Оператор.   
  - Для Солюшена надо разработать Структуру Сущностей специально для Оператора.
    - и написать код, который эту Структуру Сущностей Оператора будет обслуживать.
      Это такая надстройка над Движком Тапп получается, которая будет адаптером между Оператор и Тапп.