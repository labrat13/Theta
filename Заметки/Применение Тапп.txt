Наполнение тапп кодом.

Для использования Тапп в моих проектах важно сделать удобным его интеграцию с кодом моих проектов.
Поскольку наполнять Солюшен приемлемо быстро и качественно можно только кодом, то
 надо придумать, как это делать.
- обычно я пишу алгоритм наполнения - утилиту, которая прямо в отладчике выполняет наполнение Солюшена данными.
 А более она и не нужна обычно. Но проект утилиты потом дополняется другими алгоритмами - переработки данных, 
 проверки Солюшена, тестирования операций с данными Солюшена, или сохранения результатов работы.
 То есть, вся работа делается прямо в отладчике, заодно и тестируется и отлаживается.
 И в конце работы проект можно просто выбросить за ненадобностью. Результат уже получен, и повторение не требуется.
 - Но можно выделить отдельные функции, которые можно повторно использовать в новых проектах.
   Даже, следует это делать, так как создание новых проектов для работ с Солюшеном при этом упрощается.
- можно предложить наполнение Тапп скриптовым кодом некоторого языка, но где взять интерпретатор, с отладчиком и библиотеками функций?
  Так что пока Шарп и студия вполне хороши в этом деле. 
- Часто надо в одном процессе открыть тапп и другой мой движок. Например, движок Хранилищ.
  В этом случае лучше создать независимый проект и в него референсами подключить оба движка.
  Это удобно, но при изменении в одном из движков приходится заново его подключать. 
  Хотя, поскольку проект утилиты одноразовый, с этим проблем не должно быть. 
  А если утилита многоразовая, с ней в комплекте должны идти и используемые библиотеки.
   Вот тогда надо отслеживать версии движков и заменять на новые, или не заменять, если и старые работают как надо.
- Но все равно, версии движков это важная часть проекта, если он не одноразовый. 

------------------------------------------------
Можно Тапп использовать для исправления классов деталей в Хранилищах.

Для одной детали сейчас там может быть указано несколько классов. Это неправильно.
Та может быть указан более общий класс, конечный класс и какой-то неверный класс.
Надо собрать общую иерархию классов деталей.
Для каждой детали надо собрать список сопоставленных ей классов детали. 
Затем надо выбрать наиболее детальный класс из иерархии классов.
Если же есть один или несколько классов, не входящих в путь в иерархии классов, 
такой конфликт должен быть разрешен вручную или на основании других источников данных.

Для деталей-аналогов можно ввести дополнительный класс - прототип детали.
Он будет группировать детали, полностью функционально аналогичные.
Например, 555 - LM555 - NE555 - КР1006ВИ1 (?)
Но это сложно. Тут много ручной работы по сопоставлению аналогов.
Лучше пока связями указать аналоги деталей.
И это потребует загрузить в Тапп все Сущности Хранилищ, хотя бы без файлов.

Для диодов, микросхем и транзисторов можно написать парсер названий деталей.
Такой парсер по названию детали может определить класс детали, серию, индекс итп.
Это полезно для случая К155ЛА3 КМ155ЛА3 ЭКР155ЛА3 - упрощает поиск.

Только для каждого семейства деталей придется искать в документации принцип наименования и писать/настраивать для него парсер.
И эта работа будет использована один-два раза в жизни.

Вообще, коэффициент использования этих технологий довольно низкий и зависит от частоты возникновения задач, требующих работы с деталями.
Если я не занимаюсь ими часто или постоянно, то и смысла реализовывать эти технологии нет.

Эту же классификацию можно затем применить в Инвентарь.
Нужно сделать ее отдельной единицей, применяемой в разных моих проектах.
Хотя Инвентарь должен хранить классы деталей в своей БД, но импортировать он их может из стороннего объекта - Хранилища иерархии классов.
В концепции Органайзера это был Справочник.
А вот при чем здесь Тапп?
- Надо где-то хранить классификацию. А Тапп в этом лучше всего подходит.
  Но это надолго. Классификация собирается медленно, совершенствуется методом проб и ошибок.
  Соответственно, Тапп тоже должен быть долгоиграющим, стабильным проектом. А он сейчас экспериментальный.
- И еще, для Тапп нужен браузер и диаграммер. Браузер должен позволять вносить изменения в Структуру Сущностей.
  А диаграммер должен уметь отображать иерархии в графическом виде на плоскости или в виде текстового дерева.
- и еще нужна пользовательская концепция Структуры Сущностей. Организованная специально для такого применения, и поддерживающая также браузер и диаграммер.
- Это много работы предполагает. 

А что вся эта суета мне даст?
- иерархию классов, пригодную для практического использования в Оператор.
  Для начала, радиодеталей, и предметов из Инвентарь. 
  Оператор сможет находить и предлагать не только Веник, но и Щетка, Метла, итп.  
  По радиодеталям - аналоги требуемых деталей: полные аналоги или функциональные аналоги.
- Определение тематики текста по упоминающимся в них сущностям. Например, тексты по электронике.
  Но тут лучше подходит анализ частотного словарного набора.
- Пока не знаю, что оно мне даст полезного, надо пробовать. 
 
