++ Обсуждение Схема Многопользователей Тапп Бар
Входит в: [//ПодсистемаЛога]
В этой схеме под одним логином СУБД работают несколько Агентов: один пользователь и несколько ботов.
Боты выполняют автоматизацию рутинных работ под собственным ИдентификаторАгента.
Пользователь работает под собственным ИдентификаторАгента.

Эта схема типична для веб-сайтов. Там тоже один БД аккаунт и много пользователей, разделяемых кодом сайта.

В таком случае, после собственно инициализации Движка идет открытие Солюшена. 
А потом Агент запрашивает создание объекта КонсольПользователя. 
Через консоль Агент работает с Движком и Солюшеном, запускает операции.
Консоль именная, но пароля у Агента не требуется. Вся защита в Тапп по паролю СУБД.
В этой консоли идет весь СеансПользователя и все операции Движка.
Консоль как объект представляет собой СеансПользователя.
Можно держать одновременно открытыми несколько консолей.
В МенеджерСолюшена ведется список этих консолей. Консоль можно получить по ИдентификаторАгента - просто по имени. Например, "оптимизатор".

Это такой сценарий работы движка. Я его сначала накидал, а теперь пробую использовать его для проектирования самого движка. То есть, более подробно расписываю процессы. Это надо вообще-то делать в более подходящем месте и виде.
* Это требует многопоточности Движок, что сейчас невозможно реализовать.

+++Пример кода приложения
1. Engine E = new Engine(..); //создаем объект движка. Тут просто инициализация движка без солюшена.
    * Солюшена нет, лога нет, вывод сообщений об ошибке только через мессагобокс или специальный канал сообщений.
    * todo: Что входит в такую инициализацию?
        * Подключение приложения к каналу сообщений движка? Только после создания объекта движка. И это должен делать код приложения.  

1.1. E.messageHandler += new Handler(Msg m); //подключение приложения к каналу сообщений движка. Код неточный.

2. E.openSolution(..); or E.createSolution(..); //открываем или создаем солюшен и инициализируем его данными движок. Это можно сделать статической функцией класса движка, чтобы он сразу и создавал объект движка и открывал Солюшен. Тогда код приложения будет выглядеть проще.
    * Создается [//ИдентификаторСеансаДвижка] и отправляется в менеджеры подсистем, где он требуется?
    * Происходит инициализация подсистем Движка.
        * Инициализация подсистемы лога:
            * Инициализируется МенеджерЛога
            * [//СчетчикИдентификатораЗаписиЛога] = 1
            * [//СчетчикФайловЛога] = 1
            * Создается ПапкаСеансаЛога и первый ФайлЛога.
            * В лог выводится сообщение о начале СеансДвижка.
            * ...

3. Console C = E.createUserConsole("operator"); //Эта консоль хранит информацию о пользователе для всех вызываемых функций и применений. Cоздаем СеансПользователя, объект консоли. 
    * А если такой пользователь уже есть - отдаем уже существующий объект. Хотя тут может быть проблема с незавершенными транзакциями, если код приложения уж совсем бардачный окажется. Ведь так можно получать объект консоли отовсюду, где есть объект Движка. Например, из методов
    * Еще можно получать ранее созданную и существующую консоль E.getUserConsole(...);
    * Тут проблема - если имя пользователя будет написано с опечаткой - будет создана новая консоль, а не использована имеющаяся. Это создаст проблемы с отладкой. Лучше явно создавать пользователя, и явно получать консоль по имени, и возвращать ошибку "Нет такого пользователя".
        * Вот E.getUserConsole(...) и будет возвращать ошибку "Нет такого пользователя". А E.createUserConsole("operator") не должна использоваться нигде, кроме начала сеанса пользователя, и должна возвращать ошибку "Пользователь уже существует". 
    * Создается [//СеансПользователя] по ИдентификаторАгента (это строка имени пользователя) и добавляется в [//КоллекцияСеансовПользователей].
    * В лог записывается сообщение о начале сеанса пользователя.
    * В [//КоллекцияТранзакцийПользователя] заносится первый элемент - псевдотранзакция о сеансе пользователя.
        * todo: Можно ли его вынести отдельно от списка транзакций, раз уж это постоянный член коллекции. Или обрабатывать их кучей будет проще? 
    * Создается объект КонсольПользователя и отдается приложению.
        * todo: можно ли объединить объекты [//СеансПользователя] и КонсольПользователя? Ведь они оба представляют пользователя. Или они будут использовать друг-друга?
  
4. Cell r = C.createCell(..);//тут некоторая операция

5. C.beginTransaction("t"); //Начало транзакции. Проще использовать строковое имя, чем передавать везде объект транзакции. Имя можно и на месте написать, где нужно.
    * todo: проверить, что имена транзакций не будут использоваться в методах. Так как там они не могут быть изменены и будут приводить к трудновыявляемым ошибкам при выполнении методов.
        * Если это название транзакции существует только в использующем Движок коде, то это допустимо. 
    * Проверяется размер [//КоллекцияТранзакцийПользователя]. Если он выше чем [//КонстантаМаксимальноеЧислоВложенныхТранзакций], то выдается сообщение об ошибке.
        * done: Или это считается как ошибка в текущей транзакции и выводится сообщение об ошибке в лог? 
            * По идее, код должен обработать отказ в начале транзакции и пойти другим путем. Тогда текущая транзакция будет продолжена, как будто ничего не произошло.
            * На практике, код будет исполняться в методах, и там нет возможности предсказать все возможные случаи. Возможно, отменить текущую транзакцию будет правильно. Вот это все надо на практике и проверить.
            * Решение: если создать транзакцию невозможно, код должен обработать отказ. Текущую транзакцию автоматически отменять не нужно. В текущую транзакцию нужно вывести сообщение лога о неуспешной попытке начала транзакции, содержащее данные о транзакции - это пригодится для анализа лога пользователем. ИнтерпретаторЛога будет игнорировать такие сообщения лога.
    * Создается новая [//ТранзакцияПользователя] и добавляется в [//КоллекцияТранзакцийПользователя].

6. ... \\некоторый код здесь

7. C.commitTransaction("t"); //принять транзакцию "t". Если там были незавершенные вложенные транзакции, должно быть выдано сообщение об этом.
    * Тут надо пометить транзакцию как успешную - надписать начало транзакции в файле.

8. C.invokeMethod(..); //вызов метода - гипотетически.

9. C.close(); //закрыть объект консоли. Он должен быть уничтожен, а СеансПользователя закрыт.
    * в лог выводится сообщение о завершении СеансПользователя.
    * выполняется проверка и очистка всех свойств для этого сеанса пользователя (КонсольПользователя).
10. E.close(); //закрыть объект движка
    * Движок закрывается вне сеансов пользователей. Но если много пользователей, то Движок должен закрываться тогда, когда последний пользователь закончит свою работу и освободит КонсольПользователя. То есть, Движок закрывается при вызове функции Закрыть движок(), если [//КоллекцияСеансовПользователей] пуста. А до тех пор просто возвращает Труе.
        * У каждого пользователя, получается, есть своя ссылка на единственный в приложении объект Движка.
          А как он ее получает? 
            * Ему отдает ее приложение и дает поток для работы. Пользователь работает в интерактивном потоке, боты в фоновых потоках.
            * question: А Движок может работать в таком многопоточном варианте? Это может оказаться слишком сложно.
                * Многопользователи предполагают многопоточность Движка. В текущей реализации  это приведет к множественным проблемам из-за ошибок доступа к коллекциям. Вероятно, придется пользователям ждать друг друга, чтобы использовать Движок монопольно.
                * Тогда зачем вся эта концепция?
                    * она и многопользовательская и имеет собственные транзакции. Из-за транзакций и ИнтерпретаторЛога я ее и разрабатываю.
            * todo: Тему с многопоточностью придется серьезно изучать, когда захочется делать многопользовательский Движок. Там вероятны множественные конфликты потоков при доступе к коллекциям, вроде Словарей в foreach. Тогда всю архитектуру Движка придется сильно переделать.  
            * Конечно, можно было бы приложению завершать объект Движка, когда все потоки пользователей завершены, но зачем, когда в сам движок можно встроить этот механизм легко и без проблем.  
    * Сначала закрывается Солюшен. Потом Движок.
        * В лог выводится сообщение о завершении СеансДвижка.
        * Подсистема лога закрывается и очищается.
    * уничтожается объект Движка


     - 
 
- Сначала закрывается Солюшен. Потом Движок.    
    
    
11. return; //конец алгоритма
