++ Идентификатор Ячейки
[template: ШаблонКарточкиГлоссария]
Состояние: [//ДОПОЛНИТЬ]

ИдентификаторЯчейки обозначает ячейку в СтруктураСущностей.
Уникальный идентификатор позволяет однозначно указать ячейку при различных операциях.
См. ИдентификаторЭлементаСтруктуры

+++Версии
* todo.глоссарий.форма: Создайте новую страницу для версии описания сущности, добавив к имени "Версия0". Так осуществляется поддержка версий страниц глоссария. 

+++Обязанности
* [//ИдентификаторЯчейки/Контроль идентификатора]
* [//ИдентификаторЯчейки/ПроверитьНеВременныйЭлемент]

+++Сущности предметной области
* todo.глоссарий.форма: Перечислите выявленные сущности предметной области здесь.
* 

+++Соответствующий класс кода
* [MID]->[MCellID]
++++Свойства - данные
* ИдентификаторСолюшена
* ИдентификаторЯчейкиВнутриКонтейнера
++++Методы

+++Дополнительная информация 
Ячейка имеет уникальный составной ИдентификаторЯчейки, состоящий из ИдентификаторСолюшена и ИдентификаторЯчейкиВнутриКонтейнера, чтобы [Ячейка] могла ссылаться на ячейки из другого Солюшена. 

ИдентификаторСолюшена обозначает [Контейнер] и [Солюшен], и используется для обозначения ячеек из СтороннийСолюшен,  связанных с текущей ячейкой. При доступе к такой ячейке используется МеханизмКоммуникацииКонтейнеров.

ИдентификаторЯчейки входит в состав [Связь], где он обозначает связанные ячейки.

Поскольку ИдентификаторЯчейки занимает место в связях, и МеханизмКоммуникацииКонтейнеров не разработан, в прошлой версии проекта нет ИдентификаторСолюшена в ячейке. Все ячейки принадлежат одному контейнеру.

ИдентификаторЯчейкиВнутриКонтейнера представлен типом int32. Положительные значения обозначают ПостояннаяЯчейка, отрицательные значения обозначают ВременнаяЯчейка. Значение 0 зарезервировано как НеправильныйИдентификаторЭлемента.
Новые ячейки получают новый идентификатор, на 1 больше максимального существующего. Временные - соответственно, в отрицательную сторону. 
Для единообразия код, определяющий новый идентификатор, унифицирован для временных и постоянных ячеек.

 Операции с идентификатором - статические члены класса.

Поля идентификаторов ИдентификаторЯчейки представлены классом [//MID], и при чтении создают и возвращают копию идентификатора. Это снижает производительность, но защищает от случайного изменения полей идентификатора. 

++++Хранение идентификатора
Поскольку ИдентификаторЯчейки много используется в связях, а связей намного больше, чем ячеек, в памяти хранится только значение (8 байт), а не объект класса идентификатора (16 байт).
* В памяти в объектах идентификатор хранится как Int64 - так он занимает меньше места в объекте с учетом расхода на описания полей, и так он быстрее сравнивается при поиске нужного идентификатора. Разборка и сборка частей идентификатора выполняется статическими функциями класса идентификатора.
* В снимках СнимокСтруктуры ИдентификаторЭлементаСтруктуры хранится как Int64.
* В [//БазаДанныхСолюшена] идентификатор хранится двумя полями Int32. Это поскольку запрос, который ищет нелокальные идентификаторы в таблицах [//БазаДанныхСолюшена], не сможет разбить инт64 на инт32. Индексы по идентификаторам теперь должны быть на 2 поля.
* В ФайлСолюшена ИдентификаторЭлементаСтруктуры хранится как MID. Тут надо соблюдать порядок.

+++++Получение наибольшего существующего идентификатора ячейки
При создании ячейки ей нужно присвоить новый идентификатор. Поскольку использование б/у идентификаторов нежелательно, нужно получить наибольший существующий идентификатор ячейки (НСИ).
Новый идентификатор получается как НСИ+1.
При удалении ячеек освободившиеся идентификаторы вновь используются, если они меньше НСИ. Можно бы вообще не использовать эти идентификаторы, адресного пространства достаточно. Это позволило бы явно указывать идентификаторы в коде без проблем. Но пока так. При необходимости можно переделать движок, все необходимые изменения локализованы в описываемом здесь механизме.
Для получения НСИ надо просмотреть весь список ячеек: 
В таблице — для постоянных идентификаторов;
В памяти — для временных идентификаторов.
Этот процесс долгий, и применяется кеширование. В списке ячеек контейнера нужно хранить  НСИ ячеек - для постоянных ячеек и для временных ячеек.
Новый идентификатор получаем из существующего соответственным увеличением числа.
Поиск идентификатора проводится как можно реже. Рассмотрим ключевые точки, в которых он необходим:
–	При старте системы. Первоначально кеш идентификатора = 0, это означает, что необходимо искать НСИ. Поиск идентификатора проводится при требовании его значения.
–	При создании ячейки. Нужно получить НСИ, чтобы произвести идентификатор новой ячейки. Имея кеш НСИ, можно обойтись без поиска.  Здесь надо присвоить кешу новое значение НСИ.
–	При удалении ячейки. Нужно обновить НСИ только если удаляемая ячейка имела НСИ, в противном случае НСИ не изменился, и ничего не надо делать. Нужно проводить полный поиск, чтобы получить действительный НСИ, поскольку предыдущие ячейки тоже могли быть удалены. Поиск проводится при следующем требовании НСИ, для этого кеш = 0.
Первоначально кеш идентификатора = 0, это означает, что необходимо искать НСИ. Если кеш не 0, просто используется его значение. 
Поиск идентификатора проводится при требовании его значения. Для постоянных идентификаторов проводится запрос в таблицу.
 Для временных идентификаторов проводится поиск в памяти перебором элементов. При этом, если в структуре нет временных ячеек, поиск ничего не даст, и новый запрос  НСИ  должен будет проводить новый поиск, при этом будут перебираться постоянные ячейки в памяти. Поэтому поиск НСИ для постоянных и для временных идентификаторов — раздельные операции, выполняющиеся при требовании соответствующего НСИ. При создании первой же временной ячейки ее идентификатор будет записан в кеш, и поиск не будет выполняться..

++++Получение нового идентификатора ячейки
Поскольку идентификаторы бывают временные и постоянные, новый идентификатор для них вычисляется по-разному. Для постоянных идентификаторов +1, для временных -1. Если идентификатор достигает предельного значения, выдается исключение.



