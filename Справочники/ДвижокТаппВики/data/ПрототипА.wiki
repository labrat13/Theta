++ Прототип А

Выбор варианта реализации:
а) классы и объекты
б) граф ячеек

Общие положения

-Движок является контейнером всех сущностей системы.
-Каждый класс может иметь собственный конструктор для объектов и другие функции.

Вариант Классы и объекты:
Резюме: Система с частично фиксированной структурой, выше производительность, проще создавать, ниже гибкость.
Потребует значительной переработки по мере развития, подходит не для всех применений. Легко контролировать структуру.

Класс является контейнером объектов. Класс управляет существованием объектов, определяет методы для объектов.
Объект без класса невозможно создать.
Класс содержит системные объекты Unknown, Undefined, Nothing и другие, обозначающие какую-то сущность.
По идентификатору объекта можно определить его класс, а также каким именно системным объектом он является.
- Концепция базы не универсальна. При развитии периодически требуется полная перепланировка архитектуры.
Классы образуют структуру графа ячеек, объекты ее выборочно повторяют.
Методы подобны классам. Здесь классом будет реализация алгоритма, а объектом - конкретное использование метода в алгоритме.
Аргументы метода являются классами данных, а аргументы использования метода - объекты данных. Это позволяет хранить связи данных и методов согласно общей концепции системы.
Методы сопоставляются только классам, не объектам.
Объекты сопоставлены только одному классу. Связи объект-класс не создаются, что экономит память и время. Однако объект нельзя отвязать от класса и прицепить к другому.

Вариант Ячейки:
Резюме: Система с максимально гибкой структурой, ниже производительность, сложнее создавать, выше гибкость, потребует меньшей переделки в процессе развития, подходит для большего числа применений. Сложно контролировать структуру.

Ячейка является универсальной сущностью, которую можно назначить объектом, классом, методом или чем еще.
Для обозначения типа ячейки можно ввести поле, варианты значений в котором обновлять по мере развития системы.
- Для получения типа ячейки нужно получить саму ячейку. По самому идентификатору невозможно определить тип ячейки.
Идентификатор ячейки - просто обычное число. Системного пространства идентификаторов нет. 
? Идентификаторы специальных сущностей - как обычные сущности, ищутся в таблице.
Можно ввести подтипы или детализировать типы ячеек для специальных сущностей.
Ячейка создается конструктором контейнера без специализации класс/объект/метод. 
При создании ячейки-объекта можно указать класс, тогда используется конструктор от этого класса.
Можно сначала построить граф сущностей-ячеек, потом классифицировать.

Хотя все равно придется в результате перестраивать структуру, поэтому можно сразу строить из классов, после анализа создать новую структуру. Это будет локальное во времени преобразование, при медленном, постепенном преобразовании такая система может оказаться неподходящей. 

Каждой ячейке могут быть сопоставлены методы. Объекты могут иметь методы, отличные от методов других объектов этого же класса.
В классе по оси абстракции вниз будут обозначены объекты. В объекте эта ось пустая. Объект может быть сопоставлен нескольким классам, хотя это, разумеется, неправильно. Контролировать это будет либо [Оптимизатор] либо пользователь, но не движок.

Поскольку типы ячеек определяются по самой ячейке, то связи между классами и методами, например, могут быть реализованы на основе общих механизмов. (То есть, один и тот же механизм используется и для данных, и для методов, 
то есть они имеют одинаковую реализацию в коде). Различение типов таким образом возлагается на оперирующий код.


Dec 17, 2011
Попробуем систему ячеек.
-все ячейки имеют одинаковую структуру вне зависимости от их типа.
-идентификаторы ячеек представляют собой 32-битное число и не имеют разделения на пространства.
-новый идентификатор получается как max+1. Идентификаторы введены поскольку структура состоит из элементов, хранящихся независимо.
-можно предположить типы и подтипы ячеек. Возможно, после испытаний можно будет отказаться от хранения типа ячеек, определяя его по связям ячейки.
-Типы и подтипы могут быть удалены или добавлены. 
-основные типы ячеек:
-класс
-объект
-метод
-существующие в базе сущности:
-служебный класс, имеющий специальное назначение
- класс

- служебный объект класса, имеющий специальное назначение

- объект класса
- метод
- экземпляр метода

- связь между ячейками

- тип связи

-Ячейка может быть найдена по идентификатору или по имени (и типу).
-Имя ячейки может быть не уникальным. Поиск в таком случае возвращает список ячеек.
-Каждой ячейке могут быть сопоставлены методы. Объект может пользоваться методами класса. 
Объект может иметь собственный вариант метода, отличный от метода класса.
-Метод представляет собой ячейку-класс, описывающую алгоритм и связанную с этим алгоритмом. Объекты этого класса являются реализациями алгоритма, связанными с конкретными объектами-данными.
-алгоритм представляет собой граф классов-элементов алгоритма, каждый из которых связан с ячейкой-методом.
-каждая реализация метода состоит из объектов-элементов алгоритма. 
Реализация создается классом метода, и может накапливать данные о своих исполнениях.
-Назначение ячейки определяется ее типом, который в основном нужен для представления пользователю, и характером связей.
-в движке нужны функции для получения объектов класса по идентификатору класса, служебных объектов класса по имени, служебных классов по имени, методов/классов/объектов/..., связанных с ячейкой, общего списка классов, общего списка методов.
-все ячейки могут связываться друг с другом без ограничений. Проверка правильности структуры осуществляется [Оптимизатор]ом и оболочкой пользователя. 
-Ячейка, представленная в памяти приложения, является clr-классом, осуществляющим операции. Однако, код выполняет только базовые 
низкоуровневые операции, а для операций ячейки вызываются сопоставленные ей методы. 
Вероятно, потребуется ввести некоторый шаблонный набор методов для каждого типа ячеек, который хранится где-то, и при отсутствии 
сопоставленного непосредственно с ячейкой метода, подставляется метод из шаблона. Возможно, потребуется ввести классы типов ячеек и в них прописывать этот набор. Каждую ячейку тогда можно связать с одним из этих классов и таким образом иметь доступ и идентификацию типа. Можно создать тип связи "Тип ячейки" для этого. Такой элемент может хранить типичный для 
типа ячейки набор методов, который потом проецируется на ячейку, когда перечисляются ее методы. Ячейка переопределяет этот шаблон своими связями.
-таким образом, для построения произвольной системы нужно иметь ячейки, связи, изменяемые методы, движок для исполнения операций и хранилище данных. Ячейки, связи, методы могут иметь типы, что облегчает их интерпретацию и восприятие структуры. Однако могут и не иметь, это зависит от организации системы.
-В представление связи в памяти входят идентификаторы связанных объектов, состояние связи, тип связи, флаг удаления, адрес конечного объекта в памяти. Поскольку исходный объект и так известен, можно удалить его идентификатор, но пока оставим, пригодится если использовать этот класс отдельно от ячеек.
-тип связи - это ось связи, выделен в отдельный элемент, можно добавлять и удалять типы связей
-состояние связи дополняет тип связи, оно сейчас имеет два значения: Разрешено, запрещено. Выделить в отдельный элемент с возможностью удалять и добавлять. Состояние связи можно использовать для выключения дефолтовых методов, соответствующих типу ячейки для конкретной ячейки или методов класса для объекта. 
!Нужно придумать механизм, при помощи которого подключаемые ячейки-свойства будут участвовать в операциях. Импорта  МетодОбработчикЯчейки обработчиков недостаточно. Можно попробовать аналогию с нейронными сетями или с осциллографической трубкой - каждое свойство влияет в своем направлении, потом выбирается подходящий метод.

-Всю систему нужно спроектировать для самостоятельного применения, включая самостоятельное создание и обслуживание таблиц и индексов. 
- нужно реализовать вывод базы данных в один файл.
- в сущности, связь сама по себе можно представить в виде ячейки, с входящими и выходящими связями. Эта концепция редуцирует всю систему до подобия нейронной сети. Однако пока еще нельзя определить, как это должно выглядеть и какую функцию должна выполнять каждая ячейка. Нужен опыт работы с создаваемой версией. 

-тип данных в ячейке представляет собой код типа. Поскольку данные ячейки хранятся как последовательность байт, их надо транслировать туда/обратно при любом доступе. Для поддержки различных типов данных предполагается связать с идентификатором типа данных МетодОбработчикЯчейки обработчики сериализации. Это позволит использовать любые типы данных, которые можно сериализовать.
Поиск по содержимому в этом случае возлагается на МетодОбработчикЯчейки обработчик соответствующего типа, а не на СерверSQLБД.
Можно вместо указания типа данных сделать ссылку типа "Тип данных ячейки" на ячейку такого типа, и для нее сделать МетодОбработчикЯчейки обработчики. Но это расходует память, можно вместо этого реализовать эту ассоциацию в алгоритме - Пока используем поле, переделаем на связь если потребуется.


Dec 20, 2011
Дополнения в структуру:
1)для указания типа ячейки, связи и так далее (А), используются числовые идентификаторы, набор которых предполагается пополнять. Эти идентификаторы сопоставлены некоторому смыслу и специализированному поведению некоторых операций. То есть, представляют собой сущности некоторого типа.
Предлагается вместо этих идентификаторов использовать идентификаторы ячеек (Б), которые олицетворяют эти сущности. Ячейки (Б) могут иметь операции, и эти операции можно проецировать на элементы (А). Таким образом, ячейки (Б) представляют собой классы для ячеек(А). Лучше было бы использовать связи между ячейками вместо полей в ячейке. Это позволяет назначать любое количество свойств для ячейки, не изменяя структуру движка системы. Однако это усложняет поиск ячеек с заданными свойствами и размер 
базы данных. 
-Это позволит единообразить строение системы, заменить специализированные принципы на общие принципы. Удалить таблицы этих специализированных значений из базы. Обозначать значения уникальными именами ячеек. Можно создавать классы сущностей (Б), использовать любую существующую ячейку для создания и обслуживания соответствующего ей типа связи. Повышает универсальность базы.
-Нужно разобрать примеры доступа, чтобы выявить узкие места.
-Все необходимые ячейки должны быть включены в стартовый набор.

2) В существующей архитектуре связь представляет собой сущность. У нее есть тип, состояние итд. Можно предложить выделить ее в отдельную ячейку в середине связи, а связи тогда будут представлять собой только пары идентификаторов. Это уже несколько другая система получается, поскольку ячейка-связь может содержать несколько связей в каждом из направлений и иметь МетодОбработчикЯчейки обработчики для выполнения собственных операций. Это что-то похожее на нейронную сеть.
-Пока неясно, как это вписывается в общую картину системы. Пока отложим до выработки общей концепции. 

Примеры доступа для 1)
-получение Б по ид - ищем в таблице ячеек по ид.
-получение Б по имени - ищем ячейку (Б) в таблице ячеек по имени. Имя ячейки(Б) должно быть уникальным, чтобы его можно было использовать в коде пользователем.
-определение типа ячейки (А)
вариант с полем типа: получаем значение поля, при необходимости получаем ячейку с таким идентификатором из списка ячеек.
вариант со связью: Связь "Тип ячейки" ищем в списке связей ячейки. 

Получаем идентификатор ячейки(Б), т.е. идентификатор типа. 
-выполнение операции создания связи в соответствии с типом связи
вариант с полем типа: получаем значение поля, ищем ячейку(Б), получаем список операций, выбираем и исполняем операцию.
-получить все связанные с ячейкой (А) объекты класса Е:
-по идентификатору установить класс невозможно. Для каждой связанной ячейки нужно проверить, что она является объектом, И сопоставлена с требуемым классом. 
вариант с полем типа: 
Получаем связанные ячейки(С) в список. Для каждой ячейки (С) проверяем поле типа. Если не объект, удаляем из списка. Вариант: если поля типа не нужны, и ячейка определяется по структуре, то пропускаем этот 
шаг, поскольку тогда надо проверять связь с классом, а это следующий шаг.
Для каждой С-ячейки из списка проверяем, является ли она объектом класса Е. (Наличие восходящей связи соответствующего типа) Как можно заметить, все это работает медленно, если лежит в таблицах, но довольно быстро, если с прямыми ссылками размещено в памяти.
-...

3) Поскольку структура системы универсальна, а ее представление в коде нет, придется повозиться, чтобы реализовать эту гибкость и удобство в структуры данных для использования в пользовательском коде.
4) надо составить дерево вариантов архитектуры, и каждый вариант пометить кодом, чтобы обозначать сответствующее поведение в системе.
Дерево вариантов:
- Поле Типа ячейки:
а)Тип ячейки Класс-Объект-Метод-... хранится в специальном поле ячейки.
б)Тип ячейки не назначается, а определяется по характеру связей ячейки для каждого конкретного случая.
-Поля типов, состояний, ...:
а)представлены Б-ячейками, идентификаторы которых хранятся в специальном поле ячейки.
б)представлены связью соответствующего типа с соответствующей Б-ячейкой. 
5)поскольку везде в структуре вместо типов, состояний итд должны применяться идентификаторы ячеек, то для старта базы нужно создать эти ячейки, увязать в структуру, и снабдить их МетодОбработчикЯчейки обработчиками, чтобы можно было их использовать. То есть, нужна еще концепция использования этого механизма.


Dec 21, 2011

Архитектура:
Сериализация элементов в текст и в двоичный поток - вынесена в абстрактный класс.
Переделаны таблицы БД, убраны лишние таблицы.
! После выяснения всех тонкостей переработать иерархию классов и заново ее документировать.
В архитектуре заведены таблицы БД как классы, они отличаются от классов кода, и эти отличия надо бы документировать.
! Добавлен класс [Лог]а, нужно наполнить его смыслом. Надо разработать систему кодов для записей. Записи должны содержать данные об элементах движка, так что они должны использовать сериализацию элементов в текст.
-[Лог] является частью контейнера, данные хранит в таблице контейнера.
! В архитектуру нужно добавить исключения, но это можно сделать только в процессе описания тела функций.
? Вопрос: Ячейка должна наследовать МетодОбработчикЯчейки обработчики над-ячейки. Во всех ли случаях, во всех осях связей, или надо специально обозначать, откуда нужно импортировать методы, а откуда нельзя? И как это обозначить (разрешить/запретить импорт методов) Или, наоборот, экспорт. 
? Параметр "таймаут БД" нельзя хранить в БД. Строку соединения тоже нельзя хранить в БД. Где ее хранить?
- Можно в приложении, которое использует Mary. Там есть где хранить, и ясно, зачем.
- Надо сделать полнофункциональный аккаунт пользователя на СерверSQLБД, с паролем и логином. Для чистого доступа к базе из кода.
Логин и пароль передавать в строке соединения, строку пока создать вручную для тестов только. Эту строку приложение должно передать движку, а как оно ее получит - неважно.
Можно сделать интерфейс с бд отдельной библиотекой, но не будем - все равно, если переносить, то вместе с движком, на другой язык.
- Надо в таблицы добавить несколько записей, для теста запросов. Надо запроектировать функции чтения-записи данных, и сделать запросы для них.
- Надо сделать тестовую таблицу, накидать в нее много строк данных и посмотреть как они будут выполняться из кода.
Попробовать пересоздать индексы вручную и из кода. Данные забивать случайные.

dec 23, 2011
? как подменять методы в ячейках? Можно по имени. Имя метода является семантическим слотом, метод вызывается по имени. Можно установить связь с другим методом того же имени, поэтому при вызове операции будет вызываться новый метод. Метод можно запретить с помощью состояния связи с этим методом.
Выводы:
-Методы должны вызываться только по имени.
-Импорт методов из других ячеек надо продумать 
-Нужно разработать концепцию семантических слотов для ячейки
-Методы можно организовать в классы по семантике, и вызывать не конкретный метод, а его класс. Тогда нужный метод будет найден по связям с ячейкой или подобран автоматически, если такой связи нет. Собственно, класс метода упрощенно является семантическим слотом, но этот механизм позволяет лучшую универсальность при большей сложности.

? Свойства, типы и другие характеристики элементов являются самостоятельными сущностями, и также представлены в виде ячеек. Чтобы 
ввести новый тип, нужно как-то вписать его в существующую систему. Поскольку первоначально никаких сущностей в базе нет, ячейкам назначается тип по умолчанию. 
а)Просто игнорировать тип по умолчанию при выполнении операций - потребуется реализовать это в каждом коде.
б)Реализовать его поддержку в коде движка.
в)Предусмотреть в теории ТипПоУмолчанию, его МетодОбработчикЯчейки обработчики, как пустые. Если нельзя обойтись, создать такой тип вместе с базой.
г)Поставлять вместе с базой минимально необходимый набор сущностей, в случае если они окажутся взаимозависимы.
