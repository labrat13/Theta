++ Концепт Тапп2
Semantic Platform Project 2.0
Предварительная информация
16 апреля 2011


1 Общее описание

Эта система является средством для создания семантической сети для  построения, хранения и обработки логических моделей. Сеть использует объектно-ориентированную методологию. Сеть состоит из классов, объектов, методов, связей. При помощи этой сети можно создавать графы - логические модели и делать операции с ними. Система позволяет выполнять частичную или полную абстракцию моделей, при этом сохраняя их целостность и достоверность. Система также потенциально позволяет производить классификацию моделей, при наличии некоторого начального опыта.
Хотя сейчас система выглядит как очередная реализация теории семантических сетей, несмотря на это, ее следует рассматривать как некоторый язык и среду программирования. Можно сконструировать любой тип, описать его поведение и затем использовать.  Можно развить систему так, чтобы она превратилась в framework, реализовав типичные классы объектов и операции с ними, после чего станет возможным построение практически применимых моделей. 

Это не готовый продукт, исходя их которого, можно получить представление о свойствах и рентабельности идеи. Это только начатая пробная реализация фундамента. Действительно интересные свойства системы заключаются в надстройках, которые должны быть созданы в виде набора скриптов и моделей.
Таким образом, проект представляется как есть, без гарантий и ограничений. Я надеюсь, кто-нибудь поддержит эту необычную систему. У меня почти не осталось времени.


1.1 Текущее состояние проекта. Изменения новой версии.
Это вторая версия движка проекта. Введены 3 оси связи (X Y Z) для построения структур классов, объектов, операций. (Агрегация, абстракция, ...).

Методы могут быть организованы в иерархическую структуру для обеспечения работы абстрактных и агрегатных методов. Методы независимы от классов, и могут использоваться через связи с классами или через иерархию методов.

Текущая реализация системы представляет собой код C#, позволяющий создавать структуру из классов, объектов, операций.
-Код, обслуживающий структуру классов и объектов, портирован из первой версии. Убрано ограничение на количество связей объектов. Код не тестирован. 
-Код, обслуживающий операции, не готов. Создается. Планируется использовать вызовы исполняемого кода или интерпретацию скриптов. Планируется поддерживать исполнение абстрактных методов.  
-Пользовательский интерфейс не реализован. Планируется графический интерфейс подобно первой версии, и/или командная консоль a-la linux bash.
-Интерпретатор не реализован, планируется.

Общая функциональность классов и объектов вынесена в родительский класс.
Операции связей унифицированы, число осей легко увеличить при необходимости.
Методы используются при помощи кта. КТА позволяют хранить информацию о использовании метода, о перенаправлении вызова, оценки качеств методов.


1.2 система поддержки интеллекта (СПИ). Наброски.

Система персонализирована и настраивается под пользователя. Пользователь может достраивать и перестраивать систему как ему удобно.
Для интерфейса можно использовать индивидуальный язык (символ = понятие) и индивидуальные элементы интерфейса.
(Надо посмотреть семантику иероглифических языков - как они формируются, общие правила для всех наверно одинаковы?)
Таким образом, взаимодействие реализовано в понятиях, которые транслируются в символы для передачи пользователю и обратно.
Набор понятий определяется пользователем, транслируется по правилам, определенным пользователем.
Можно использовать любой, в том числе индивидуальный, способ представления понятий.

Система представляет собой граф из классов, объектов, операций. То есть, данных и действий.
Система должна формироваться по определенным правилам, однако их соблюдение частично ложится на пользователя.
Приложения в системе создаются образованием в общей глобальной структуре новых структур, использующих новые и существующие элементы системы для реализации необходимых функций. При этом дистрибутив нового приложения представляет собой текстовый файл - скрипт, по которому создается новый участок структуры.
Поскольку система индивидуальна, каждый пользователь должен сам корректировать структуру приложения при необходимости.
То есть, скрипты должны быть открытыми. Это уже не программа, а инструкции по ее созданию. Хотя в каком-то смысле это все еще отдельная вещь. Типично для современного программного обеспечения.

Для пользователя необходимо создать начальную структуру, облегчающую начало использования. Некоторый общий набор, который затем сам пользователь будет развивать по своему усмотрению. 
Также пользователю потребуются некоторые начальные знания, позволяющие создавать и оценивать структуру, распознавать типичные ошибки. 

Система будет надстройкой над ОС компьютера. 
Возможности:
- модификация пользователем или самомодификация, исходя из требований пользователя.   
- полностью индивидуальный интерфейс пользователя.
- автоматизация типичных действий пользователя.
Существующие реализации требуют от пользователя знаний алгоритмизации и языков программирования, владения соответствующими инструментами.

Таким образом, задача создания СПИ: создать систему, которая не требует специальных знаний для ее использования или модификации.
Для начала работы с системой должно быть достаточно общеобразовательной подготовки. (Из чего следует, что общеобразовательная подготовка должна обеспечивать некоторый стабильный минимум как стандарт. Этот набор знаний вполне пригоден в любой деятельности, поскольку представляет семантику окружающей среды.)


2 Техническое описание

Система создана на C# для Microsoft Visual Studio 2005 или поздних версий. Visual Studio используется как среда разработки и отладки, с просмотром состояний объектов и других данных.
Для хранения структуры системы на диске используется XML. Во время работы структура целиком находится в оперативной памяти компьютера.

В системе предполагается следующая архитектура:
 - сборка-движок системы в виде библиотеки классов. Предоставляет средства для реализации системы. Экспортирует контейнер, в котором все сущности создаются, существуют и уничтожаются.
 - сборки методов для выполнения операций с данными базы. Сборки содержат методы, определяемые прикладным программистом. Методы используются движком при помощи Reflection.
 - приложение – оболочка пользователя, из которой можно работать в системе.
 - утилиты и сторонние приложения. 

Пользователи проекта делятся на системных программистов, прикладных программистов и  конечных пользователей.
Системные программисты заведуют  АПИ проекта, который делится на SystemLayer и UserLayer. SystemLayer  выполняет базовые операции в соответствии с архитектурой  компьютерной платформы. UserLayer обеспечивает соответствие операций и методологии, контроль входных данных и так далее. 
Прикладные  программисты используют UserLayer для создания  методов обработки данных. 
Конечные пользователи конструируют структуру данных, добавляют и удаляют данные, требуют от прикладных программистов реализовать необходимые методы.

Для хранения базы во время работы используется оперативная память. На диске база хранится в виде XML документа, немного оптимизированного для простого просмотра.
Файл базы данных имеет версию и шаг. Версия означает строение файла. Шаг предназначен для поиска последней сохраненной копии данных.
Чтобы сохранять целостность структуры данных, операции должны предусматривать возможность отмены изменений при сбое. Если отменить изменения невозможно, следует загрузить последнюю версию данных из файла. После завершения операции нужно сохранить новую версию системы на диск.
Планируется добавить поддержку файлов, в этом случае сохраняются также копии файлов. 

Поскольку система реализуется для исследования, для основных сущностей предусмотрены поля для хранения текстовых описаний. 


2.1 Сущности

Контейнер - представляет всю систему. Содержит все остальные сущности.
Объекты - представляют данные. 
Классы - представляют абстракцию данных. Могут быть связаны в иерархию классов.
Связи классов/объектов - связывают классы с классами, объекты с объектами в одной из осей.
Связи класс-метод - связывают классы с методами.
Связи методов - связывают методы с методами.
Методы - представляют операцию. Могут быть связаны в иерархию методов.
КТА - комплект типов аргументов. Представляют использование метода.
Аргументы - аргументы метода.


2.2 Идентификаторы, пространства идентификаторов

Каждый класс имеет порядковый номер, каждый объект внутри класса имеет порядковый номер.
Идентификатор объекта состоит из номера класса и номера объекта в классе.
Номера от 0 до 255 образуют системное пространство. Объекты и классы в этом пространстве являются частью архитектуры системы.
Номера выше 255 образуют пользовательское пространство. Первый пользовательский объект первого пользовательского класса будет иметь ObjID 256:256.


2.3 Контейнер

Контейнер представляет систему, хранит список классов/методов системы, предоставляет операции.
Контейнер позволяет загрузить базу из файла, выгрузить в файл, произвести чистку и оптимизацию структуры данных, создать, удалить, изменить класс и связи класса, объекта, добавить или удалить метод, вызвать метод для объекта класса и так далее. 


2.4 Классы

Классы семантически являются классами сущностей и используются для хранения типов данных и общей структуры связей с другими классами. Связи между классами, как и между объектами, организованы по принципу главный-подчиненный. Один и тот же класс не может быть и главным и подчиненным какому-либо классу.  Следует избегать кольцевых связей в структуре классов. Вообще, структура классов требует большого внимания.  Связи между классами проецируются на пользовательские объекты класса, таким образом, структура объектов в целом повторяет структуру классов. Каждая новая связь между классами отражается на всех пользовательских объектах этих классов. Таким образом, если для некоторой сущности (объекта) a1 добавлено новое свойство, оно добавляется в абстрактной форме и к другим сущностям того же класса - сущности a2, a3, … также получают то же свойство, но пока в неопределенной форме.
 
Класс служит также шаблоном - образцом для создания новых объектов класса.
ObjID класса = 0. В классе хранятся связи класса с другими классами. Класс также хранит тип данных, но не сами данные.
Класс имеет идентификатор объекта – иконки, сопоставленной этому классу. (В этой версии не реализовано.)
Класс, как и объект, имеет три оси связей: X (aggregation), Y (abstraction),  Z (reserved).
Соответственно, шесть списков связей: X+, X-, Y+, Y-, Z+, Z-.
Классы могут использовать все оси для образования структуры классов.
Класс включает в себя список объектов класса, список связей с методами. 

2.4.1 Служебные классы

Служебные/системные классы создаются автоматически при создании базы данных.
Класс 0 – Мир/ World. Начальный класс базы. Все прочие структуры классов начинаются с него. Мир является исходной точкой навигации по структуре классов. В системе может быть несколько независимых графов классов, все они должны начинаться с класса Мир. Иначе они будут недоступны для использования и могут быть удалены [Оптимизатор]ом.
Класс 1 – Unknown. Используется в связях классов и обозначает неизвестную сущность, не поддающуюся определению.
Класс 2 – Undefined. Используется в связях классов  и обозначает, что сущность еще не определена, то есть, ее нужно определить.
Класс 3 – Nothing.  Используется в связях классов и обозначает, что сущность не существует.


2.5 Объекты

Объекты предназначены для хранения конкретных данных и связей между ними. Объекты принадлежат классу. 
Каждый объект содержит списки связей с другими объектами. 
Все объекты могут иметь несколько связей с объектами одного класса.

Тип данных объекта определяется типом данных класса. В экземпляре объекта тип данных хранится для удобства, чтобы не запрашивать класс.
Выбор типа данных ограничен возможностями применяемой платформы .NET Framework, как в части работы с типами данных, так и в части создания методов для них.

2.5.1 Служебные объекты

В каждом классе автоматически создаются служебные/системные объекты.
Объект 0 – обозначает сам класс в пространстве идентификаторов объектов.
Объект 1 – Unknown. Используется в связях объектов и обозначает неизвестную сущность.
Объект 2 - Undefined.  Используется в связях объектов  и обозначает, что сущность еще не определена, то есть, ее нужно определить.
Объект 3 – Nothing. Используется в связях классов и обозначает Cущность не существует.


2.6 Методы

Общее описание методов в версии 2.0. Методы существенно изменены, поэтому здесь приведено комплексное описание.

Основные сущности системы:
- Контейнер	- представляет систему. MEngine класс, содержит список классов, список методов, операции.
- Класс		- представляет класс сущностей. Класс содержит список объектов, списки связей с другими классами, список связей с методами,
			 имя и другие данные, операции.
- Объект	- представляет сущность. Объект содержит списки связей с другими объектами, данные, операции.
- Метод		- представляет метод. Метод выполняет некоторую операцию, принимает и возвращает аргументы. Метод может быть сопоставлен одному или 					нескольким классам, может вызываться классом или объектом класса. 
			Метод содержит связи с другими методами, список связей с классами, список КТА, данные, операции.
- Аргумент	- представляет аргумент метода. Аргумент имеет имя, тип, значение, другие данные.
- КТА		- представляет комплект типов аргументов для метода. Это вариант использования метода.
- связь класс/объект-класс/объект 	- связывает два класса или два объекта. По одному экземпляру связи для каждой стороны. 
						Содержит поля для хранения типа связей.
- связь класс-метод	- связывает метод с классом и класс с методом.
- связь метод-метод	- связывает метод с другим методом.  По одному экземпляру связи для каждой стороны.

Описание:
Контейнер содержит список методов. Все методы хранятся в этом списке.
Класс имеет список связей с методами. В версии 1 все методы жестко связаны с классом, хранятся в списке методов класса, вызываются только через класс.
В версии 2.0 методы являются самостоятельной сущностью, могут быть организованы в собственную структуру, могут вызываться через связанный с ними класс или индивидуально, по имени или номеру. Метод также может быть выбран и вызван при помощи иерархии методов,  этот вариант не изучен, но представляется перспективным, поэтому в архитектуре намечена его поддержка.

Поскольку один и тот же метод может вызываться разными классами, с разными типами данных, введены КТА. КТА хранит типы, значения, метаданные о вызове метода, это обеспечивает проверку корректности вызова метода.  КТА фиксирует использование метода для вызывающего класса. В методе есть список кта, в котором сохраняются все вызовы метода всеми классами. Предполагается использовать этот список для статистики и оптимизации выбора в иерархии методов. Планируется, что метаданные КТА позволят определять допустимый диапазон значений и типов аргументов, оценивать пригодность метода для конкретного использования и т.д. КТА содержит идентификатор класса/объекта, который вызывает метод. Для уменьшения размера списка КТА периодически, во время очередного вызова, проводится оптимизация - удаление дублирующихся записей, выделение трендов, и т.д.

Метод может быть абстрактным, не содержать кода, только обеспечивать выбор подходящего метода в иерархии абстракций. Таким образом, вместе с иерархией данных, это обеспечивает выполнение операции на всех уровнях абстракции. Это упрощает контроль и отладку абстрактных методов.

Связь класс-метод связывает классы и методы. В экземпляре метода существует список связей с классами. В экземпляре класса - список связей с методами.
Поскольку методы используются классами через КТА, то связь указывает на класс с одной стороны, и на КТА метода с другой. Таким образом, один класс может быть связан с несколькими методами, и даже с нескольким кта одного метода, различающимися типами аргументов (например, если метод абстрактный).
Метод может быть связан с несколькими классами, или ни с одним - в этом случае он может использоваться через иерархию классов.  Запрещается хранить в списке связей дубликаты.

Метод содержит основной КТА - КТА0. Этот КТА создается при создании метода, и определяет набор и типы аргументов, которые метод использует.
Предполагается, что КТА будет использоваться совместно с иерархией абстракций методов, что позволяет создавать и использовать абстрактные методы так же, как и конкретные. То есть, если КТА описывает абстрактные типы данных, то метод можно вызвать для конкретных типов данных. При этом автоматически должен быть найден и вызван подходящий метод, информация об этом выборе/вызове зафиксирована в КТА абстрактного метода, данные возвращаются как будто они исполнялись абстрактным методом.
Метод содержит поле для текста скрипта. Если поле пути к коду содержит путь, то метод вызывает CLR-код. Если нет, проверяется поле текста скрипта. Если оно не пустое, текст отправляется интерпретатору, если пустое - это абстрактный метод или ошибка. Абстрактный метод не содержит кода, используется для организации вызова конкретного метода. Информация для поиска содержится в списке кта метода.
  
Можно попробовать ввести в КТА показатель эффективности метода, который записывается по результатам метода. Можно будет выбрать подходящий метод на основе эффективности, определить границы эффективной работы метода, и прочие интересные возможности. Но это потом.

Связь метод-метод связывает методы таким же образом, как и аналогичные связи класс-класс. Можно выделить абстракци, агрегацию методов, и соответственно реализовать структуру. Для большей гибкости, методы связываются через концепцию КТА, обычно через кта0.
  

2.7 Связи Класс-класс, объект-объект

Связи представляют отношения объектов. Два объекта связаны отношениями верхний-нижний, главный-подчиненный. Связи двусторонние, то есть, каждый из двух объектов имеет свою копию связи. Создание связи между объектами возможно только при наличии связи между классами. 
Связи, как и объекты и классы, также  имеют состояния. Если  связь между двумя классами помечена состоянием «запрещено», то связь между объектами этих классов не может иметь иное состояние.  
Связи не могут соединять два объекта одного и того же класса.
Связи могут ссылаться на уже удаленный объект, на предопределенный или на несуществующий объект.
Класс, как и объект, имеет три оси связей: X (aggregation), Y (abstraction),  Z(reserved).
Соответственно, шесть списков связей: X+, X-, Y+, Y-, Z+, Z-.
Классы могут использовать все оси для образования структуры классов.
Объекты используют Х-связи для отношений включения между объектами.
 Y- связи используются для отношений абстракции. Если у надкласса есть объект, и нужно создать связь с ним (то есть, если существует объект надкласса как абстракция объектов текущего класса. Нетипичная вещь.), то они связываются так же, как и для Х оси.Если связи нет, то как и в Х оси, текущий объект связывается с объектом надкласс::Undefined.
Z ось реализуется по тем же правилам, но пока не используется. Предполагается применить ее для привязки свойств объекта/класса. Пока неясно как это должно выглядеть.  
Между двумя объектами или классами может существовать только одна действующая связь. Допускается наличие нескольких недействительных (удаленных) связей между объектами.

Связи между объектами различных классов при создании дублируются в связях классов. Например, если объект класса А связывается с объектом класса В, то должна быть сначала создана связь между классом А и классом В. Она указывает на наличие и характер связи между классами А и В, и при создании нового объекта класса А у него тоже создается связь с объектом класса В, но пока абстрактная -  конечным объектом является системный объект В.Undefined.   Это механизм для автоматического поддержания структуры данных, когда «висящие» связи привлекают внимание и должны быть разрешены (указывать на что-то, быть как-то определенными). Если в результате разрешения установлено, что конечный объект связи не может существовать, то конечным объектом становится B.Nothing. Если в результате разрешения  установлено, что конечный объект связи неизвестен, и не может быть определен сейчас, то конечным объектом становится B.Unknown. 
Связь, создаваемая между классами, распространяется на все его пользовательские объекты.

2.7.1 Типы связей:

- Запрещено.  Семантически это означает, что между двумя сущностями не может быть связи.  Если  связь между двумя классами помечена состоянием «запрещено», то связь между объектами этих классов не может иметь состояние Нормально. Но может иметь состояние Неопределено. Если же в классах связь не Запрещено, то связь объектов может иметь любое состояние, в том числе и Запрещено.  
- Нормально.  Между двумя сущностями существует обычная связь.
- Неопределено. Используется [Оптимизатор]ом при обслуживании структуры. 
- Не существует. Это значение используется только как код возврата в функциях поиска связей.

2.7.2 Краткое описание правил для связей:

Обозначения: 
 	А – пользовательский класс.
	М – класс Мир. Начальная точка иерархии классов по всем осям.
	У – системный класс Undefined
	у- системный объект Undefined  пользовательского класса
 	а1 – один пользовательский объект пользовательского класса
 	а* - несколько пользов. объектов пользов. класса
	+ - создание связи между объектами или классами
	- - удаление связи между объектами или классами

1)Если А + В   то а* + ву, ау + в*; Если классы соединяются связью, то объекты также соединяются связью – с объектами Undefined целевого класса.
2)Если а1 + в1 то А + В; Если объекты соединяются связью, то классы также соединяются связью. (Реализация – сначала связать классы, потом нужные объекты).
3)Если а1 + в* то А + В; (Реализация - сначала связать классы, потом нужные объекты).
4)Если связь АВ имеет состояние запрещено, то все связи ав должны иметь состояние запрещено.
5)Связи между объектами одного класса нельзя создавать.
6)Между 2 объектами может существовать только одна действующая связь.
7)Если А не имеет ни одной связи в осях X+, Y+ или Z+, он автоматически должен быть связан с классом Мир. Если же А имеет связь в этих осях (хотя бы одну) не с классом Мир, он должен быть отсоединен от класса Мир. 
8) Если А – В, то все ав связи удалить.
9) Если а1 – в1, то а1 + ву, ау + в1;  объектом целевого класса сделать  Undefined


2.8 Связи класс-метод

Связывают классы и методы. Связь состоит из идентификатора объекта/класса и идентификатора метода/кта.
Класс может быть связан с несколькми методами, метод может быть связан с несколькими классами.
Позволяют вызвать связанный с класом метод.


2.9 [Оптимизатор]

Это служебная процедура, выполняющая проверку и оптимизацию структуры базы.
Удаление ненужных структур, расширение узких мест, развитие системы.




(С) 2011 Селяков Павел Михайлович
