++ Идентификатор Элемента Структуры
[template: ШаблонКарточкиГлоссария]
Состояние: [//ДОПОЛНИТЬ]

Это абстракция идентификатора, он одинаковый по устройству, для связи, ячейки.
См ИдентификаторЯчейки и ИдентификаторСвязи.



+++Версии
* todo.глоссарий.форма: Создайте новую страницу для версии описания сущности, добавив к имени "Версия0". Так осуществляется поддержка версий страниц глоссария. 

+++Обязанности
* Создание объекта НеправильныйИдентификаторЭлемента для использования в КодДвижка.
* [//ИдентификаторЭлементаСтруктуры/ПолеИдентификаторСолюшена]
* [//ИдентификаторЭлементаСтруктуры/ПолеИдентификаторЭлементаВнутриКонтейнера]
* [//ИдентификаторЭлементаСтруктуры/КонтрольИдентификатора]
* [//ИдентификаторЭлементаСтруктуры/ПроверитьНеВременныйЭлемент]

+++Сущности предметной области
* todo.глоссарий.форма: Перечислите выявленные сущности предметной области здесь.
* 

+++Соответствующий класс кода
Представлен классом [MID].
++++Свойства - данные
++++Методы

+++Дополнительная информация 
Это идентификатор, одинаковый по устройству, для связи, ячейки и контейнера. 
Он позволяет однозначно идентифицировать любую [Связь] или [Ячейка] или [Контейнер] в пределах существующей МногоконтейнернаяСистема. 
ИдентификаторЭлементаСтруктуры состоит из ИдентификаторСолюшена и ИдентификаторСвязиВнутриКонтейнера или ИдентификаторЯчейкиВнутриКонтейнера.
Пространства идентификаторов у ячеек, связей и контейнеров разные, нельзя их путать.

++++Поле типа элемента
* todo: Надо ввести в Идентификатор элемента структуры поле, описывающее тип элемента: Контейнер, Ячейка, Связь.
Это может быть байтовый енум на 4 элемента. Это поле нужно для того, чтобы хранить идентификаторы элементов в одной куче. Например, в словаре блокировок в ТранзакцияПользователя.
И оно должно сериализовываться вместе с остальными полями объекта.
Это нужно для ПодсистемаЛога.
 * тогда нельзя упаковать все поля идентификатора в U64, как сейчас. Значит, размер объекта связи или ячейки увеличится.
 * Не хочется это делать. Может быть, для ТранзакцияПользователя можно хранить объект соответствующего типа, а для ПодсистемаЛога сериализовывать будем в некий промежуточный формат, содержащий и тип элемента? Хотя, это корявое решение. Лучше уж добавить одно поле в класс идентификатора и все сделать без оглядки на желанную экономию памяти.

++++Дефрагментация пространства идентификаторов
Поскольку при работе с СтруктураСущностей получаются пробелы в использовании пространства идентификаторов, [Оптимизатор] может производить дефрагментацию этого пространства, заменяя идентификаторы в ячейках, методах и связях для тех ячеек, которые не имеют связей вне обслуживаемого сейчас контейнера. Для этого нужно полностью заменить все существующие идентификаторы ячейки. 
Поскольку МетодИзКода не поддается такой модификации (там могут использоваться обращения к ячейкам по вшитому в код ИдентификаторЯчейки), нужно соблюдать правило - в этих методах получать ячейки только по НазваниеЯчейки. Если это возможно.
Для ячеек и связей, имеющих внешние контакты, изменение идентификаторов приведет к разрушению СтруктураСущностей, поэтому тут надо думать. Вероятно, от идеи дефрагментации идентификаторов пока нужно отказаться. Или же дефрагментация идентификаторов должна проводиться [Оптимизатор]ом для всей МногоконтейнернаяСистема сразу.

++++Исторические причины
О поиске нового идентификатора
Если гарантировать, что создание ячеек будет только через MEngine, то можно кэшировать последний выданный cellid, чтобы ускорить создание ячеек. В Tapp2 была реализована эта схема, она раз в пять сократила время импорта таблицы с данными (12 * 67000 ячеек)
Выдержка из Tapp2: 
271111 - getFreeObjId оптимизация. Создана переменная MClass.maxObjId в которой хранится максимальный ИД объекта.
Поскольку ИД объектов выбираются как максимальный ИД + 1, то хранение результатов предыдущего поиска ускоряет получение нового ИД, то есть, создание объекта.
При создании объекта его ИД записывается в эту переменную, при удалении любого объекта переменная сбрасывается в 0.
Полный перебор производится при первом обращении после загрузки базы, после удаления объекта.
Предлагается разместить поле в MEngine.

++++Переделать старые Идентификатор ячейки и связи
Из wiki:///V:/МоиПроекты/SIM/Работать%20здесь/NewConcept/NewConcept.wiki?page=КонцепцияИдентификатораЯчейкиИСвязи

Предлагается единая концепция идентификатора для ячеек и связей.
Положительные числа - постоянные ячейки и связи, отрицательные числа - временные ячейки и связи, 0 - зарезервированный идентификатор.
Сейчас постоянные связи используют первичный ключ из таблицы связей как идентификатор.
Он используется для проверки, что связь временная или постоянная.
Также по нему запись связи ищется в БД.
Но этот идентификатор получается из таблицы связей БД.
Временные связи не имеют его, поэтому не различаются.

Есть проперти MLink.isLinkNotTemporary  который проверяет это поле объекта связи на 0. Проперти вполне себе используется.
MDbLayer.getLastIdentityLinksTable()возвращает идентификатор записи связи сразу после добавления связи в таблицу.
Постоянные связи записывают изменения проперти сразу в таблицу.

Если вместо идентификатора связи из таблице мы будем назначать уникальные идентификаторы для постоянных и временных связей, то отпадет необходимость в хранении идентификатора связи из таблицы, а остальные операции во всем движке надо будет как минимум просматривать, а то и полностью перепроектировать.

Предлагается переделать MID так, чтобы он описывал идентификатор для контейнера, связи и ячейки.
Также для полных идентификаторов надо придумывать поиск в таблицах.

Объект идентификатора ячейки в старом коде не хранится в памяти, а создается из поля int32 cellId при каждом обращении к проперти. Поэтому и копировать идентификаторы между объектами не приходится и памяти меньше занимает.
Придется также перепроектировать код всех функций движка, ячеек, связей.
Придется перепроектировать код АдаптерБД MDbLayer, поскольку выборка связей теперь не по tableId, а по новому идентификатору связи. Его все равно переделывать - к идентификаторам добавляется еще поле ИдентификаторСолюшена. Соответственно, потребуются новые индексы.

Сейчас поиск ячейки идет только по полю cellid - поля containerid в таблицах нет, поле первичного ключа таблицы ячеек не используется. Нужно создавать индексы идентификаторов по двум полям, и добавлять поля в таблицы, и работать соответственно. То есть, переделывать весь код MDbLayer.
Целесообразно совместить это с переработкой всей архитектуры.

Первичный ключ таблицы ячеек не используется, поэтому структура ячеек не разваливается при переносе на другую базу данных, когда создаваемым строкам назначаются другие первичные ключи. Надо избавиться от использования первичного ключа таблицы ячеек.

Сразу можно проектировать БазаДанныхСолюшена и [Солюшен] на выбор одной из БД. Это если MySqlСУБД поддерживает необходимый набор возможностей. Набор предстоит определить и проверить его реализацию в каждом СерверSQLБД. Предлагается сделать класс-интерфейс стандартного набора функций АдаптерБД, и потом для каждого типа СУБД из ПереченьТиповБд его переопределять.


