++ Обсуждение Сеанса Пользователя В Логе
[//ЗАВЕРШЕНО] - часть КонцепцияЛога.
Входит в: [//ПодсистемаЛога]

+++Обсуждение
* todo: Можно ли числовой ИдентификаторСеансаПользователя назначать в начале СеансПользователя и использовать его только внутри лога?
    * Можно сопоставить ТранзакцияСолюшена и пользователя. Тогда, для ЗаписьЛога внутри этих ТранзакцияПользователя, можно не хранить ИдентификаторСеансаПользователя.
        * Но еще могут быть записи вне ТранзакцияПользователя - как для них определять ИдентификаторСеансаПользователя?
            * Можно считать СеансПользователя как ТранзакцияПользователя первого уровня. А собственно транзакции - вложенными в него.  
        * Тогда чтобы определить пользователя для конкретной ЗаписьЛога - надо раскрутить всю цепочку вложенных транзакций.
            * А зачем определять пользователя для ЗаписьЛога?
            * Если сопоставлять каждую транзакцию пользователю, то только ближайшую транзакцию нужно получить.
    * Можно ИдентификаторСеансаПользователя назначать как координату ЗаписьЛога о начале СеансПользователя в СеансЛога. Это 64-битное число будет указывать на пользователя только внутри лога.
        * А этот СеансПользователя как вообще будет приходить в Лог? Это же каждая операция Движка должна будет получать идентификатор пользователя как один из аргументов.
            * Вообще-то, он в некотором смысле является чем-то вроде ТранзакцияПользователя. Но да, все операции пользователя должны сопровождаться каким-то идентификатором или даже объектом СеансПользователя. Иначе не получится разделять одновременных пользователей и их транзакции.
            * Поскольку у меня сейчас одновременных пользователей нет, то СеансПользователя вроде бы и не нужен.
            * Но он и для неодновременных пользователей нужен - как мне различить, где работал пользователь, а где - Оптимизатор? 
                * По началу и концу сеанса пользователя и [Оптимизатор]а.
                * Просто обсуждаемый многопользовательский механизм более универсален, и в будущем более полезен. Вот поэтому его и следует проработать и внедрить. Хотя он усложняет всю систему, конечно.
            * Да, и как собственно в текущей версии Движка могут работать множественные пользователи? Ведь движок-то один на процесс.
                * Каждый пользователь имеет собственный *объект описания пользователя*. Этот объект представляет СеансПользователя для [Движок]а. И этот объект указывается при вызове каждой операции [Движок]а.
                * При любой обычной операции этот объект считается псевдо-транзакцией. Операция включается в эту транзакцию.
                * При начале первой транзакции он является родительской транзакцией для этой транзакции. И последующие операции становятся частью начатой транзакции.
                * При завершении транзакции некоторого уровня должны быть завершены вложенные в нее транзакции. Таким образом, завершение СеансПользователя покажет и завершит также все открытые им транзакции.
                    * Тут нужны функции проверки, есть ли вложенные транзакции для указанной транзакции.
                    * И функция закрытия транзакции и всех вложенных транзакций.
                    * И транзакции должны называться по уникальному строковому имени.
                    * А список транзакций должен находить транзакцию по этому имени, не по индексу в списке.
            * И так получить пользователя в работающем [Движок]е легко можно по списку транзакций, в которые вложена ЗаписьЛога. А как сделать это же без [Движок]а?
                * ЗаписьЛога содержит координаты ЗаписьЛога о Начало последней транзакции.
                * Перейдя к этой Записи, получаем описание этой транзакции, в том числе ее координаты Родительская Транзакция и координаты записи Начало сеанса пользователя.
                * Перейдя к ЗаписьЛога о Начало сеанса пользователя, получаем название пользователя.
            * А как для всех записей лога показать Пользователя?
                * Придется составить дерево транзакций, начинающееся с СеансПользователя. И по полю  Родительская Транзакция каждой ЗаписьЛога можно высчитать Пользователя по этому Дереву. Причем одновременно с собственно построением дерева транзакций.
                * Это значит, для произвольного места Лога нужно прочитать предыдущие файлы лога.
                    * Не все, а только указанные координатами записи в них.
                    * Но все файлы лога за СеансЛога должны существовать, их нельзя частично удалять.
                    * Значит, нет смысла читать один файл лога отдельно от остальных - они нужны целым СеансЛога сразу.
                        * Ну, можно некоторую информацию дублировать в начале каждого ФайлЛога. Но это мало что дает. Все равно ТранзакцияСолюшена размазаны по всему СеансЛога - один кусок не самодостаточен. 
        * ИдентификаторСеансаПользователя для лога приходит снаружи, однажды записывается в лог в начале СеансПользователя и потом используется в каждой ЗаписьЛога для обозначения инициатора операции.
* ИдентификаторСеансаПользователя сейчас описывает объект-описатель СеансПользователя, но не может быть представлен целым числом.

       
        
+++Выводы, решения
* СеансЛога представляет собой совокупность связанных между собой ФайлЛогаСолюшена. Потеря одного из ФайлЛогаСолюшена повредит целостность всего СеансЛога.

++++Общее строение многопользовательской системы Движка Тапп Бар
* Строение подобно веб-сайту. Есть один пользователь для БД, и один и более клиентов. У каждого клиента есть собственный логин. И возможно пароль, но это сейчас не используется.
* Когда пользователь запускает [Движок], он подключается к Солюшену, в том числе, к БД Солюшена.
* Затем пользователь запрашивает для себя объект Консоль. Этот объект хранит в течение всего СеансПользователя всю информацию о пользователе: Логин, открытые ТранзакцияСолюшена, итд. Консоль скрывает от пользователя механизм идентификации.
* Пользователь работает только через Консоль, вызывая в ней операции Движка.
* Консоль передает Движку вызовы операций [Движок]а пользователем, подставляя в них объект-описатель СеансПользователя, необходимый для работы подсистем [Движок]а. 

++++СеансПользователя
* СеансПользователя создается при начале работы пользователя с Движок. Вероятно, отдельной функцией, которая возвращает объект-описатель этого СеансПользователя.
* Описатель СеансПользователя передается как аргумент при каждой операции Движка. Код операции передает этот описатель в Лог и другие подсистемы.
* СеансПользователя является ТранзакцияПользователя первого уровня. В него вкладываются остальные операции и транзакции пользователя.
    * Объект-описатель СеансПользователя должен быть представлен классом подобным классу представления ТранзакцияЛога, чтобы единообразно обрабатываться в списке транзакций пользователя.
        * Либо не входить в список транзакций пользователя, а существовать и обрабатываться отдельно.
* Сам объект СеансПользователя тоже дампится в Лог как Начало сеанса пользователя.
* Все начинаемые транзакции описываются в объект-описатель СеансПользователя, так что он для пользовательского кода представляет все начатые кодом транзакции.
* Одновременно в Движок может существовать несколько таких объектов-описателей СеансПользователя. Это предполагает наличие списка или словаря с ключом по имени пользователя.
* Пользователи различаются по строковому названию - имени пользователя.

++++ИдентификаторСеансаПользователя
* ИдентификаторСеансаПользователя используется только внутри ПодсистемаЛога, внутри текущего СеансЛога.
* ИдентификаторСеансаПользователя назначать как координату ЗаписьЛога о начале СеансПользователя в СеансЛога. Это 64-битное число будет указывать на пользователя только внутри лога.
* ИдентификаторСеансаПользователя для лога приходит снаружи, однажды записывается в лог в начале СеансПользователя и потом используется в каждой ЗаписьЛога для обозначения инициатора операции.
* ИдентификаторСеансаПользователя сейчас описывает объект-описатель СеансПользователя, но не может быть представлен целым числом.

++++Идентификатор записи лога
* ИдентификаторЗаписиЛога это уникальное 64-битное целое число. Возможно, содержащее также и НомерФайлаЛога для быстрого перехода к нужному ФайлЛогаСолюшена.

++++Транзакции
* ЗаписьЛога о начале транзакции должна содержать ИдентификаторСеансаПользователя.
* Каждая ЗаписьЛога о начале транзакции описывает Пользователя как координаты ЗаписьЛога о начале СеансПользователя и/или непосредственно текстом с логином пользователя.
* ЗаписьЛога о начале транзакции должна содержать указатель на ЗаписьЛога о начале родительской транзакции. Если это транзакция самого первого уровня, то эта ссылка указывает на псевдотранзакцию СеансПользователя.
    * Таким образом можно по логу определить и пользователя - владельца транзакции, раскрутив всю цепочку вложенных транзакций.  
* Каждая ЗаписьЛога содержит поле Родительская Транзакция. В этом поле хранится ИдентификаторЗаписиЛога записи о начале соответствующей транзакции. Эта запись (о начале) содержит полезную информацию о транзакции.
* При завершении транзакции некоторого уровня должны быть завершены вложенные в нее транзакции. Таким образом, завершение СеансПользователя покажет и завершит также все открытые им транзакции.
    * Тут нужны функции проверки, есть ли вложенные транзакции для указанной транзакции.
    * И функция закрытия транзакции и всех вложенных транзакций.
    * И транзакции должны называться по уникальному строковому имени. И нужны публичные функции для генерации такого имени (возможно, дополнением таймштампом предложенного пользователем названия) и проверки его уникальности.
    * А список транзакций должен находить транзакцию по этому имени, не по индексу в списке.
* Все начинаемые транзакции описываются в объект-описатель СеансПользователя, так что он для пользовательского кода представляет все начатые кодом транзакции.

++++Как получить имя пользователя из лога без Движка
* ЗаписьЛога содержит координаты ЗаписьЛога о Начало последней транзакции.
    * Перейдя к этой Записи, получаем описание этой транзакции, в том числе ее координаты Родительская Транзакция и координаты Пользователь.
    * Перейдя к ЗаписьЛога о Начало сеанса пользователя, получаем название пользователя.
* А как для всех записей лога показать Пользователя?
    * Придется составить дерево транзакций, начинающееся с СеансПользователя. И по полю  Родительская Транзакция каждой ЗаписьЛога можно высчитать Пользователя по этому Дереву. Причем одновременно с собственно построением дерева транзакций.
    * Это значит, для произвольного места Лога нужно прочитать предыдущие файлы лога.
        * Не все, а только указанные координатами записи в них.
        * Но все файлы лога за СеансЛога должны существовать, их нельзя частично удалять.
        * Значит, нет смысла читать один файл лога отдельно от остальных - они нужны целым СеансЛога сразу.
        * Ну, можно некоторую информацию дублировать в начале каждого ФайлЛогаСолюшена. Но это мало что дает. Все равно транзакции размазаны по всему СеансЛога - один кусок не самодостаточен. 


