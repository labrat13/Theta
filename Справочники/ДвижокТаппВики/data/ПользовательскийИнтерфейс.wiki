++ Пользовательский Интерфейс

Из wiki:///V:/МоиПроекты/SIM/Работать%20здесь/NewConcept/NewConcept.wiki?page=ПользовательскийИнтерфейс

Соображения по интерфейсу. Написан исходный материал, его надо анализировать, переработать, разнести по соответсвующим разделам концепции. 

Для развития проекта его необходимо применять - решать с его помощью возникающие задачи. Например, БД или еще как-нибудь. Тогда усилия по решению задач приведут также и к развитию проекта как универсальной платформы.

+++Задачи
* написать выводы для текста
* перечислить и описать критерии оценки
* сделать шкалу для оценок и свести предложения в таблицу для выбора лучших способов.
* придумать концепцию механизма запросов на разрешение коллизий, и как его целиком вынести в пользовательскую концепцию проекта.

+++Выводы
* Пользователь должен в любой момент иметь возможность просмотреть [Лог] последних операций, чтобы восстановить контекст своей работы.
* Надо определиться со способами представления данных и документировать варианты, их достоинства и недостатки
* Каждое представление должно отражать контекст выполняемой операции, это ставит под сомнение универсальность формирования представлений.
* Система должна предоставлять пользователю достаточно подробный контекст, извлекая и представляя данные из [Лог]а.
Это снизит трудоемкость при принятии решений.
* В [Лог] нужно записывать комментарии по действиям пользователя и комментарии из методов. Вероятно, навигатор тоже должен писать события в [Лог] системы, иначе пользователю неудобно будет анализировать [Лог]. Таким образом [Лог] один на все приложения, работающие с проектом.
* [Лог] превращается в существенную часть проекта и требует существенного внимания. 

+++Критерии оценки
* Трудоемкость - количество действий пользователя, необходимых для выполнения задачи.
* Устойчивость контекста - вероятность потери контекста пользователем вследствие переключения внимания, внешних событий итд. Пользователь воспринимает процесс как последовательность параллельных представлений сущностей, без рекурсии.
Рекурсии вызывают прерывание текущего контекста и начало нового. Предыдущий контекст обычно запоминается, но может быть потерян по разным причинам. Визуально объединенное представление составляющих контекста позволяет быстро восстановить контекст. Например, диалоговое окно с контролами представляет контекст операции, поэтому, вернувшись к нему, пользователь понимает, какую операцию он собирался выполнить, и что для этого нужно. Хотя, возможно, он уже не помнит, зачем нужна эта операция, и тут для восстановления контекста нужен [Лог].
* Правильность структуры - пользователь, вследствие потери контекста, или по другим причинам, может создать неправильную структуру ячеек элемента. Эта неправильная структура может быть не замечена при отсутствии средств контроля правильности, и может стать причиной ошибок в работе системы.
* Правильность ввода данных - пользователь может не указать какие-то данные, или ввести ошибочные данные.

Рассмотрим БД.
Данные сведены в коллекцию подобно таблице. Элемент данных из этой таблицы представлен графом ячеек.
* Сначала надо завести проект,создать служебную структуру ячеек, настроить навигатор, ...
* Просмотр имеющихся данных
    * Через навигатор бродить по графу элемента. Представление элемента формируется в памяти пользователя.
        * Трудоемко, так как надо много переходов от ячейки к ячейке. 
        * Возможна потеря контекста, так как данные визуально не связаны. 
    * С помощью метода сформировать документ-представление элемента или коллекции в целом 
        * Неполнота - Существующие варианты представления не показывают отношения между частями представления
        * Трудоемко, так как для коллекции надо создавать метод, и переделывать его при каждом изменении структуры элемента. Универсальный метод будет вызывать Неполноту. 
    * Представить элемент диаграммой ячеек и связей 
        * Это представит данные и их отношения, обеспечив полноту и устойчивость контекста.
        * Это представление не изучено 
        * Трудоемко, так как пользователь должен найти интересующие его данные на диаграмме.
* Добавление данных
    * С помощью навигатора создаем граф ячеек элемента вручную, одновременно заполняем данными
        * Трудоемко, так как надо много переходов от ячейки к ячейке.
        * Потеря контекста, так как данные визуально не связаны, и есть рекурсия.
        * Может быть нарушена правильность структуры
        * Может быть ошибки ввода данных
    * С помощью метода создать граф элемента, затем вручную заполнить данными
        * Правильность структуры определяется методом
        * Трудоемко, так как надо создавать метод, и переделывать его при каждом изменении структуры
        * Трудоемко, так как надо много переходов от ячейки к ячейке при заполнении данными
        * Потеря контекста, так как данные визуально не связаны, и есть рекурсия. 
        * Может быть ошибки ввода данных
    * С помощью метода создать представление, в него ввести данные
        * Трудоемко, так как надо создавать метод, и переделывать его при каждом изменении структуры
        * Ошибки ввода данных проще выявлять, так как контекст визуально доступен.  
    * С помощью механизма запросов на разрешение коллизий производим необходимые операции до состояния отсутствия коллизий в системе.
        * Этот вариант не изучен.
        * Механизм должен быть заложен в архитектуру системы
        * Механизм предполагает отличные от традиционных методы работы
        * Трудоемко, так как пользователь должен обрабатывать каждый запрос
        * Потеря контекста - его вообще нет здесь, это не непрерывный процесс, а реагирование на события. Для каждого события пользователю придется создавать контекст.
        * Правильность структуры контролируется самой системой    
* Удаление данных - достаточно просто, если элемент или его свойства не используются больше нигде, кроме как в этой коллекции. Если же он используется где-то еще, тут надо разбираться согласно ситуации.
    * С помощью навигатора выбираем ячейку элемента и удаляем ее
    * Вызываем метод-деструктор для элемента
* Выборка данных

+++Другие соображения
* Как определить, какие способы в каких случаях использовать? Это должно быть описано в знаниях о классах сущностей предметной области. В зависимости от ситуации и предметной области, выполняемое системой принятие решений может занимать разное время. В стандартной софтвер-индустрии эти решения принимает пользователь, а выполняет их код, оптимизированный под данную конкретную фиксированную обстановку.
* Выходит в общем, пользователь при работе с системой должен реализовывать методами свой мыслительный процесс, а структуры данных будут аналогом памяти. При условии постоянной и индивидуальной работы с системой, со временем такая система будет отражением интеллекта пользователя в данной предметной области.

+++Обсуждение механизма запросов на разрешение коллизий
Чтобы работать, этот механизм должен быть изначально заложен в архитектуру системы.
Например, в некоторой структуре мы создаем некоторый объект, и этот объект не заполнен данными и имеет состояние, обозначающее необходимость его заполнить данными и связями. 
Система, обнаружив этот объект, для каждого свойства объекта запрашивает пользователя, требуя определить это некоторое свойство объекта. Пользователь, получив такой запрос, должен изучить контекст проблемы, и принять решение о значении свойства объекта.
Это обещает поддержание целостности всей структуры системы, но пользователь будет разгребать завалы требований.
Например, пользователь желает добавить новую книгу в коллекцию книг. Тогда он должен просто создать основную ячейку в коллекции книг. Затем система, обнаружив эту ячейку, запросит у пользователя ее свойства, по одному за раз. Пользователь может сразу установить все нужные свойства, чем избежит новых запросов. Далее, каждый элемент коллекции должен иметь структуру ячеек, и система последовательно запросит у пользователя создание этой структуры ячеек и установку всех свойств. Таким образом, пользователь будет вынужден создать требуемую структуру с требуемым набором свойств. Недостаток в том, что пользователь не контролирует правильность структуры, а система не знает, что именно хотел пользователь.
Кроме того, при некоторых ошибках могут образовываться бесконечные циклы запросов, хотя это можно контролировать, проверяя структуру на соответствие определенным правилам. Которые еще надо выработать для такой архитектуры.

Гибкая структура системы позволяет создавать методы подобно языкам программирования, но с большим разнообразием операторов. Создание, отладка и исполнение методов должно быть не сложнее, чем собственно придумывание метода пользователем. В этой концепции система является одновременно памятью, средой разработки, отладчиком, тестовой средой, справочной информацией разработчика, [Лог]ом и трекером проекта. Это разнообразие функций требует определенных соглашений, архитектурных решений и технических средств.

Метод на практически применимом уровне описывается ячейками и связями, состоит из последовательности абстракций методов, которые транслируются в реальные уже применительно к реальным данным. Тут лучше обратиться к концепции методов.

* Таким образом, запросы на разрешение должны генерироваться для ячеек и связей, для каждого свойства. И не только на наличие, но и на соответствие ранее установленным правилам.
* Эти запросы требуют проработки архитектуры и концепции для своей работоспособности. Они требуют написания специфического кода для работы движка, это нарушает права пользовательских концепций на свободу. Тут надо думать - или пользователь будет сам создавать исполняемый код для концепции, или предоставить ему возможность собирать требуемый функционал из методов.
* Получается вроде Tapp1 - в системе должны быть сущности, специально предназначенные для пометки состояния данных, и группирующие на себя ссылки, требующие разрешения. Это не самый лучший вариант, надо обдумать.
* Запросы на разрешение непонятны без контекста и будут приводить к ошибкам из-за того, что пользователь неверно понял контекст. Контекст хранится в [Лог]е. Особенно как следствие выполнения методов или после перерыва в работе. Значит пользователю надо предоставлять [Лог] для просмотра  и анализа записей о сущности запроса до момента запроса. Запросы надо иметь возможность игнорировать, иначе вся работа встанет при первой же кольцевой зависимости.
У [Лог]а должна быть хорошая информативность, навигация и структурирование. В [Лог]е и в методах нужно применять комментарии, описывающие суть или этап выполнения операции, особенно для сложных операций. Однако для частых операций это приведет к тому, что [Лог] будет быстро расти, и станет отдельной серьезной темой.
Еще для [Лог]а хорошо бы пользователю иметь возможность виртуально повторить некоторую часть процесса работы системы, или отдельный метод, по данным [Лог]а, чтобы что-то нужное выяснить.

+++Соображения о удалении сущностей из структуры
* Если сущность используется только в одном месте, то ее можно без проблем удалить.
* Если сущность используется еще где-то, то удалять ее нельзя
* Если сущность не используется нигде, но где-то используется какое-то ее свойство, то это вопрос сложный. И решать его должен пользователь.
    * Если свойство вполне обойдется без сущности, то можно оставить только свойство, но тогда оно скорее всего изменит свою семантику. То есть, его надо было заменить изначально, но придется сделать это сейчас.
    * Если свойство нельзя отделить от сущности, придется как-то организовывать семантику сущности чтобы избежать удаления [Оптимизатор]ом.
* Поскольку [Оптимизатор] реализует удаление невостребованных ячеек, концепция должна определить, каким образом [Оптимизатор] это делает, чтобы удаление не приводило к нарушению структуры данных.