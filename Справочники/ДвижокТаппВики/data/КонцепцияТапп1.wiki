++ Концепция Тапп1
[//УСТАРЕЛО] - оставить для истории и добычи полезных идей.
++++Описание концепции
Описывает старую концепцию из прошлой версии Тапп. Оставлена тут для исторического обзора развития проекта Тапп.
todo.концепция.тапп1: Составить концепцию Тапп 1 для исторического обзора, чтобы окончательно избавиться от старых документов.

Поскольку проект развивался спонтанно, то образовалась путаница в нумерации версий и архитектур.
* Сначала была архитектура Класс-ссылочная с реализацией на PHP. Сейчас она именуется здесь Тапп0.
* Затем я ее перенес на C# и назвал Тапп1. Название не было специально придумано, так был назван проект тестового ГУИ для движка. Почему-то прижилось именно это название, и еще Движок.
* Затем в архитектуру Тапп1 были введены три оси связи вместо одной, этот эксперимент выявил проблемы с проектированием. Было принято решение разрабатывать проект на основе единой концепции. Поэтому я начал создавать единую концепцию для проекта.
* Затем еще были некоторые мелкие эксперименты и получившаяся архитектура теперь считается как Тапп2.
* Затем была попытка сделать новую версию, которая должна была опробовать улучшенную архитектуру - ячейки. Эта архитектура должна была избавить меня от проблем прошлых версий Тапп, привнеся и универсальность, и минимализм, и расширяемость структуры сущностей. Эта архитектура была названа Тапп23, чтобы символизировать промежуточное положение между Тапп2 и Тапп3. Тапп23 должен был дать опыт для перехода к Тапп3.
* Тапп3 должен был стать потоковой системой. Она частично тут где-то описана.   

+++Тапп0
Это версия, которая была сделана на PHP для веб. 
* [file:///V:/МоиПроекты/SIM/OldVersions/SimOldDocs/техническое описание.doc] - про Тапп 0 на PHP.

+++Тапп1 куски концепции
* [file:///V:/МоиПроекты/SIM/OldVersions/SimOldDocs/Work.txt] - старая концепция Тапп1
* [file:///V:/МоиПроекты/SIM/OldVersions/SimOldDocs/Exceptions.txt] - Соображения по организации исключений в Тапп1.
* [file:///V:/МоиПроекты/SIM/OldVersions/SimOldDocs/Base.doc] концепция Тапп1
* [file:///V:/МоиПроекты/SIM/OldVersions/SimOldDocs/Операции.txt] - операции Тапп1
* [file:///V:/МоиПроекты/SIM/OldVersions/SimOldDocs/ToDo5.txt] - Тапп1 тодо 2010г.
++++Сущности структуры сущностей
Можно предположить, что в базе должны существовать сущности:
  	-служебный класс, имеющий специальное назначение
	- класс
  	- служебный объект класса, имеющий специальное назначение
	- объект класса
	- метод
	- экземпляр метода
 	- связь между ячейками
	- тип связи
	
++++Переделка движка Тапп1 для поддержки семантических конструкций
Из [file:///V:/МоиПроекты/SIM/OldVersions/SimOldDocs/new.txt]
Переделка движка для поддержки семантических конструкций

- необходимо ввести метатип класса в CClass. Это будет поле-перечисление Normal, Collection, CollectionElement, ...
  Соответственно, надо внести изменения в конструктор класса, интерфейс пользователя, ... (26.05.2016 11:43 Это трансформировалось потом в структуру ячеек и ТипЯчейки)
Пользователь создает класс, помечает его как коллекцию, после чего добавляет в коллекцию подклассы. 
При добавлении подклассов в коллекцию должны создаваться классы-элементы коллекции. Одновременно, иначе нельзя будет выполнить добавление. 
Это может делать GUI или API. Или еще как-нибудь.
GUI - вполне можно реализовать, но надо определить методику, чтобы организовать дуракоустойчивость.
    Однако, в этом случае сеть привязана к GUI, а это неправильно.  
API - получаются варианты операций с классом в зависимости от метатипа. Это сложный путь. Лучше хранить API простым и цельным.

Исходя из положений:
-структура классов полностью контролируется и обслуживается кодом движка. Все операции выполняются кодом движка.
-движок является самодостаточным компонентом и может быть использован в стороннем проекте.
Выбрать одно из двух не получается. С одной стороны, для GUI неважно, каким образом реализовано добавление подклассов, хотя все же надо как-то это представить пользователю.
Можно предложить абстрагировать GUI от деталей операций, переложив это на API. С другой стороны, для API это несвойственная работа. Хотя она все же должна как-то выполняться, и код должен быть в этом же модуле. С третьей стороны, предполагается код, самостоятельно работающий со структурой сети. И ему тоже нужна эта функциональность.
Таким образом, получается слоеный пирог:
1 API выполняет базовые операции в структуре (26.05.2016 11:40 Это все сведено в Движок)
2 некоторый промежуточный слой выполняет операции средней сложности, например, операции коллекций. Предоставляет обобщенный интерфейс для операций. (26.05.2016 11:39 это трансформировалось затем в ПользовательскаяКонцепцияСолюшена )
3 GUI для визуального контроля структуры сети; Некоторый слой автоматизации, управляющий структурой сети. (26.05.2016 11:41 Это [Навигатор])
4 Интерфейс для предметной области, располагающий данными и задачами. (26.05.2016 11:40 это приложение, определяемое пользователем)
 
++++Пример структур данных Тапп1
 Из [file:///V:/МоиПроекты/SIM/OldVersions/SimOldDocs/Base.doc] - концепция Тапп1
 Пример структур данных

Несколько примеров для общего представления

Построение типа Книга. Построим тип книга со свойствами автор, название.
Этот пример иллюстрирует процессы, происходящие в базе при создании ее объектов.

1 создаем класс Книга. Это будет верхний класс, его необходимо связать с классом МИР, чтобы он был доступен пользователю. 
  При создании класса будут созданы также шаблон класса и системные объекты Undefined, Unknown, Nothing. Никаких связей и пользовательских объектов не создается. 
ClassID = 256;
2 создаем класс Автор
  При создании класса будут созданы также шаблон класса и системные объекты Undefined, Unknown, Nothing. Никаких связей и пользовательских объектов не создается.
ClassID = 257;
3 связываем Автор и Книга, Книга будет надклассом, а Автор подклассом. Состояние связи нормальное. Создаются связи между шаблонами классов. Книга downlink Автор; Автор uplink Книга. Других связей не создается.
4 создаем класс Название. См. п.2. ClassID = 258;
5 связываем классы Книга и Название. Книга будет надклассом, Название подклассом. 
  Теперь существуют следующие связи между шаблонами:
  Книга downlink Автор	256:0 downlink 257:0
  Книга downlink Название 256:0 downlink 258:0
  Название uplink Книга      258:0 uplink 256:0
  Автор uplink  Книга          257:0  uplink 256:0
6 Создаем объект класса Книга. Объект получает ID = 256:256, созданные связи:
     256:256 downlink 257:2
     256:256 downlink 258:2
     257:2 uplink 256:256
     258:2 uplink 256:256
7 создаем объект класса Автор. 
ID = 257:256
	257:256 uplink 256:2
            256:2    downlink 257:256
8 связываем объект Книга и объект Автор
          257:256 uplink  256:256
          256:256  downlink  257:256
    Связи объектов Книга и Автор с соответствующими системными объектами Unknown (objID = 2) удаляются, так как теперь связь между объектами  исполнена.
9 таким же образом создаем объект Название и связываем его с объектом Книга.

В данном упражнении выполнено создание типа Книга и одного объекта этого типа.
Все операции по созданию типа или его объекта можно выполнять вручную или при помощи кода (аналог конструктора в С). Конечно, описание выглядит несколько сложно.

Создание класса коллекции.
Этот пример иллюстрирует применение методики для реализации набора элементов (коллекции). Это пример мышления, если хотите.
Нельзя связывать объект одного класса более чем с одним объектом другого класса. В любом случае, это будет «плохим стилем», поскольку невозможно различить объекты в такой коллекции, невозможно контролировать их происхождение и суть связей, неоднозначность содержимого снижает способности системы к абстракции и классификации. Для реализации коллекции необходимо ввести промежуточные сущности, изолируя таким образом  собственную энтропию объектов коллекции. 
Коллекция объектов одного или разных классов реализуется как сущность(класс)-коллекция (контейнер), несколько сущностей(классов) – элементов коллекции (первый, второй, третий, и т.д), и сопоставленные элементам объекты коллекции.
Таким образом, коллекция из трех объектов семантически отличается от коллекции из неопределенного числа объектов. Коллекция из неопределенного числа объектов реализуется другим способом, обычно не содержит средств для точной классификации содержимого, и для использования должна быть преобразована в конечную коллекцию с определенным числом объектов. Должно существовать столько классов элементов, сколько существует объектов в коллекции. Как вариант, можно применить коллекции, состоящие из коллекций, например, 3 по 3. 
Такое построение коллекций позволяет определять наиболее используемые классы коллекций, поддерживая комбинаторные особенности этих коллекций.

++++Тапп1 мощность связи и метаклассы
Версия с множественными связями

Для реализации множественных связей нужно в экземпляре связей класса хранить мощность и предел мощности.
Можно просто ввести эти поля в класс связи. Объекты не будут с ними работать, только классы.
Для теста этого достаточно.
Но поскольку связей между классами гораздо меньше, чем связей между объектами 
(тем более в данной версии, когда каждый объект хранит свою собственную копию набора связей)
(надо бы переделать так, чтобы объект хранил только действующие, а остальные при необходимости запрашивал из класса)
 то получается увеличение расхода памяти на хранение этих новых полей. Хорошо бы сделать разные версии связей для объектов и для классов.
А это потребует переделки всего кода, поскольку для хранения связей класса используются объекты-шаблоны.
Такую переделку лучше всего делать по уже отработанному API, задокументировав операции.

Замечания
Сейчас основной проблемой является реализация класса-коллекции.
Однако наверняка это не единственная проблема, и после нее еще какая-нибудь обнаружится.
Хорошо бы сразу их посчитать, чтобы предусмотреть в архитектуре.

Одиночные связи, метаклассы
Предполагается использовать существующие классы для представления метаклассов.
Для вертикальных связей надо завести отдельные списки и реализовать операции для них отдельным блоком.
Однако и здесь может возникнуть та же проблема с один. связями. К тому же, неясно, по каким правилам метаслой создавать.

++++нововедения в Тапп1 версии 2
* [file:///V:/МоиПроекты/SIM/OldVersions/SimOldDocs/сведения.txt] - про Тапп1
основные нововедения в Тапп1 версии 2:

1) state - состояние, в котором находятся связи, объекты, классы.
Состояние -  например, удалено. Хранится в экземпляре объекта в памяти. Выражается кодом в пределах 0-255
Надо уточнить концепцию

Типы состояния связей
0 – нормальная связь
1 –  связь «запрещено» – 
применение в шаблоне запрещает создание связей между любыми объектами двух указанных в ней классов.
 Применение в объекте запрещает создание  связи между указанными объектами и ее использование.
2 – связь «удалено» 
	применение в шаблоне означает, что ссылки всех объектов на конечный класс готовятся к удалению, 
	поэтому ссылки на объекты этого класса постепенно тоже отмечаются как удаляемые
	применение в объекте означает, что ссылка на конечный объект готовится к удалению
3 -  связь «неопределено»
	применение в шаблоне означает, что для связи не установлен конечный класс – то есть, 
	связь «висит», и [Оптимизатор] должен определить, что с ней делать или запросить пользователя.
	Применение в объекте означает,  что для связи не установлен конечный объект, хотя, возможно, 
	известен класс.  [Оптимизатор] должен определить сам или запросить пользователя. 

Состояние класса\объекта

Определяет состояние класса или объекта
0 – нормальное состояние
1 -  не определено пока
2 – класс или объект готовится к удалению
	если применен в классе или шаблоне, класс и его объекты готовятся к удалению
	если применен в объекте – объект готовится к удалению
3 – класс или объект неопределен – промежуточное состояние объекта или класса, означающее, что он
	 требует внимания [Оптимизатор]а\пользователя.

+++Тапп2 куски концепции
Фактически, это еще архитектура Тапп1, более поздней модификации, до перехода на систему ячеек.
Но везде в старых материалах она называется Тапп2. 
А архитектура с ячейками называется в старых материалах Тапп23.
Исправлять нумерацию я уже не буду, проще начать новую - теперь по кодовым именам версий.

* ПрототипА для концепции Тапп2
* [file:///V:/МоиПроекты/SIM/OldVersions/SimOldDocs/todo.txt] - Замечания к ГУИ Тапп2
++++Концепт Тапп2 и глоссарий
Из КонцептТапп2
2.1 Сущности

Контейнер - представляет всю систему. Содержит все остальные сущности.
Объекты - представляют данные. 
Классы - представляют абстракцию данных. Могут быть связаны в иерархию классов.
Связи классов/объектов - связывают классы с классами, объекты с объектами в одной из осей.
Связи класс-метод - связывают классы с методами.
Связи методов - связывают методы с методами.
Методы - представляют операцию. Могут быть связаны в иерархию методов.
КТА - комплект типов аргументов. Представляют использование метода.
Аргументы - аргументы метода.



2.2 Идентификаторы, пространства идентификаторов

Каждый класс имеет порядковый номер, каждый объект внутри класса имеет порядковый номер.
Идентификатор объекта состоит из номера класса и номера объекта в классе.
Номера от 0 до 255 образуют системное пространство. Объекты и классы в этом пространстве являются частью архитектуры системы.
Номера выше 255 образуют пользовательское пространство. Первый пользовательский объект первого пользовательского класса будет иметь ObjID 256:256.

2.3 Контейнер

Контейнер представляет систему, хранит список классов/методов системы, предоставляет операции.
Контейнер позволяет загрузить базу из файла, выгрузить в файл, произвести чистку и оптимизацию структуры данных, создать, удалить, изменить класс и связи класса, объекта, добавить или удалить метод, вызвать метод для объекта класса и так далее. 

2.4 Классы

Классы семантически являются классами сущностей и используются для хранения типов данных и общей структуры связей с другими классами. Связи между классами, как и между объектами, организованы по принципу главный-подчиненный. Один и тот же класс не может быть и главным и подчиненным какому-либо классу.  Следует избегать кольцевых связей в структуре классов. Вообще, структура классов требует большого внимания.  Связи между классами проецируются на пользовательские объекты класса, таким образом, структура объектов в целом повторяет структуру классов. Каждая новая связь между классами отражается на всех пользовательских объектах этих классов. Таким образом, если для некоторой сущности (объекта) a1 добавлено новое свойство, оно добавляется в абстрактной форме и к другим сущностям того же класса - сущности a2, a3, … также получают то же свойство, но пока в неопределенной форме.
 
Класс служит также шаблоном - образцом для создания новых объектов класса.
ObjID класса = 0. В классе хранятся связи класса с другими классами. Класс также хранит тип данных, но не сами данные.
Класс имеет идентификатор объекта – иконки, сопоставленной этому классу. (В этой версии не реализовано.)
Класс, как и объект, имеет три оси связей: X (aggregation), Y (abstraction),  Z (reserved).
Соответственно, шесть списков связей: X+, X-, Y+, Y-, Z+, Z-.
Классы могут использовать все оси для образования структуры классов.
Класс включает в себя список объектов класса, список связей с методами. 

2.4.1 Служебные классы

Служебные/системные классы создаются автоматически при создании базы данных.
Класс 0 – Мир/ World. Начальный класс базы. Все прочие структуры классов начинаются с него. Мир является исходной точкой навигации по структуре классов. В системе может быть несколько независимых графов классов, все они должны начинаться с класса Мир. Иначе они будут недоступны для использования и могут быть удалены [Оптимизатор]ом.
Класс 1 – Unknown. Используется в связях классов и обозначает неизвестную сущность, не поддающуюся определению.
Класс 2 – Undefined. Используется в связях классов  и обозначает, что сущность еще не определена, то есть, ее нужно определить.
Класс 3 – Nothing.  Используется в связях классов и обозначает, что сущность не существует.


2.5 Объекты

Объекты предназначены для хранения конкретных данных и связей между ними. Объекты принадлежат классу. 
Каждый объект содержит списки связей с другими объектами. 
Все объекты могут иметь несколько связей с объектами одного класса.

Тип данных объекта определяется типом данных класса. В экземпляре объекта тип данных хранится для удобства, чтобы не запрашивать класс.
Выбор типа данных ограничен возможностями применяемой платформы .NET Framework, как в части работы с типами данных, так и в части создания методов для них.

2.5.1 Служебные объекты

В каждом классе автоматически создаются служебные/системные объекты.
Объект 0 – обозначает сам класс в пространстве идентификаторов объектов.
Объект 1 – Unknown. Используется в связях объектов и обозначает неизвестную сущность.
Объект 2 - Undefined.  Используется в связях объектов  и обозначает, что сущность еще не определена, то есть, ее нужно определить.
Объект 3 – Nothing. Используется в связях классов и обозначает Cущность не существует.


2.7 Связи Класс-класс, объект-объект

Связи представляют отношения объектов. Два объекта связаны отношениями верхний-нижний, главный-подчиненный. Связи двусторонние, то есть, каждый из двух объектов имеет свою копию связи. Создание связи между объектами возможно только при наличии связи между классами. 
Связи, как и объекты и классы, также  имеют состояния. Если  связь между двумя классами помечена состоянием «запрещено», то связь между объектами этих классов не может иметь иное состояние.  
Связи не могут соединять два объекта одного и того же класса.
Связи могут ссылаться на уже удаленный объект, на предопределенный или на несуществующий объект.
Класс, как и объект, имеет три оси связей: X (aggregation), Y (abstraction),  Z(reserved).
Соответственно, шесть списков связей: X+, X-, Y+, Y-, Z+, Z-.
Классы могут использовать все оси для образования структуры классов.
Объекты используют Х-связи для отношений включения между объектами.
 Y- связи используются для отношений абстракции. Если у надкласса есть объект, и нужно создать связь с ним (то есть, если существует объект надкласса как абстракция объектов текущего класса. Нетипичная вещь.), то они связываются так же, как и для Х оси.Если связи нет, то как и в Х оси, текущий объект связывается с объектом надкласс::Undefined.
Z ось реализуется по тем же правилам, но пока не используется. Предполагается применить ее для привязки свойств объекта/класса. Пока неясно как это должно выглядеть.  
Между двумя объектами или классами может существовать только одна действующая связь. Допускается наличие нескольких недействительных (удаленных) связей между объектами.

Связи между объектами различных классов при создании дублируются в связях классов. Например, если объект класса А связывается с объектом класса В, то должна быть сначала создана связь между классом А и классом В. Она указывает на наличие и характер связи между классами А и В, и при создании нового объекта класса А у него тоже создается связь с объектом класса В, но пока абстрактная -  конечным объектом является системный объект В.Undefined.   Это механизм для автоматического поддержания структуры данных, когда «висящие» связи привлекают внимание и должны быть разрешены (указывать на что-то, быть как-то определенными). Если в результате разрешения установлено, что конечный объект связи не может существовать, то конечным объектом становится B.Nothing. Если в результате разрешения  установлено, что конечный объект связи неизвестен, и не может быть определен сейчас, то конечным объектом становится B.Unknown. 
Связь, создаваемая между классами, распространяется на все его пользовательские объекты.

2.7.1 Типы связей:

- Запрещено.  Семантически это означает, что между двумя сущностями не может быть связи.  Если  связь между двумя классами помечена состоянием «запрещено», то связь между объектами этих классов не может иметь состояние Нормально. Но может иметь состояние Неопределено. Если же в классах связь не Запрещено, то связь объектов может иметь любое состояние, в том числе и Запрещено.  
- Нормально.  Между двумя сущностями существует обычная связь.
- Неопределено. Используется [Оптимизатор]ом при обслуживании структуры. 
- Не существует. Это значение используется только как код возврата в функциях поиска связей.

2.7.2 Краткое описание правил для связей:

Обозначения: 
 	А – пользовательский класс.
	М – класс Мир. Начальная точка иерархии классов по всем осям.
	У – системный класс Undefined
	у- системный объект Undefined  пользовательского класса
 	а1 – один пользовательский объект пользовательского класса
 	а* - несколько пользов. объектов пользов. класса
	+ - создание связи между объектами или классами
	- - удаление связи между объектами или классами

1)Если А + В   то а* + ву, ау + в*; Если классы соединяются связью, то объекты также соединяются связью – с объектами Undefined целевого класса.
2)Если а1 + в1 то А + В; Если объекты соединяются связью, то классы также соединяются связью. (Реализация – сначала связать классы, потом нужные объекты).
3)Если а1 + в* то А + В; (Реализация - сначала связать классы, потом нужные объекты).
4)Если связь АВ имеет состояние запрещено, то все связи ав должны иметь состояние запрещено.
5)Связи между объектами одного класса нельзя создавать.
6)Между 2 объектами может существовать только одна действующая связь.
7)Если А не имеет ни одной связи в осях X+, Y+ или Z+, он автоматически должен быть связан с классом Мир. Если же А имеет связь в этих осях (хотя бы одну) не с классом Мир, он должен быть отсоединен от класса Мир. 
8) Если А – В, то все ав связи удалить.
9) Если а1 – в1, то а1 + ву, ау + в1;  объектом целевого класса сделать  Undefined


2.8 Связи класс-метод

Связывают классы и методы. Связь состоит из идентификатора объекта/класса и идентификатора метода/кта.
Класс может быть связан с несколькми методами, метод может быть связан с несколькими классами.
Позволяют вызвать связанный с класом метод.

++++Замечания о старом Тапп2
Из wiki:///V:/МоиПроекты/SIM/SimWiki/SimWiki.wiki?page=ОписаниеВерсииAstra
27.06.2012
Проект Tapp v2.3 "Astra"

В версии 2.2 была проведена небольшая обкатка, выявились некоторые обстоятельства:
* Концепция в целом удобна для применений в анализе данных. Вероятно, следует ее для этого использовать.
* Возможность автоматизации, реорганизации СтруктураСущностей надо улучшить и использовать.
* Версию можно продолжать обкатывать и использовать для проектирования и отработки частей.
* База объемом 300000 объектов и классов довольно долго загружается/выгружается в ФайлСнимка, и занимает почти 1 гигабайт оперативной памяти.
* Формат XML не позволяет легко добавить или удалить поле в элемент - данные перестают загружаться из-за неверного формата.
* Система работает очень медленно при поиске связей ЭлементСтруктурыСущностей, если этих связей много. 
   Следует использовать хеш-таблицы, но они не сериализуются в ХМЛ. Оптимизация этого поиска невозможна.
* Оси связи используют специфические правила создания связей, поэтому для каждого типа связи нужен собственный обработчик операции.
* Классы могут нуждаться в специальных типах служебных объектов, как следствие, в специфических конструкторах объектов/классов и других специальных вариантах стандартных операций.
* Для методов следует предусмотреть варианты C#-кода, скрипта, и новый в виде графа. Возможно, потребуются также модифицируемые обработчики операций.     
* [Оптимизатор] так и не набросан.
* В некоторых случаях применения системы удобнее использовать ячейки вместо классов/объектов. Возможно даже, это лучше чем классы+объекты.
* Класс можно использовать для хранения дефолтовых данных для объектов.
* non-Nullable типы CLR (int, float, ...) надо заменять на Nullable-типы, чтобы унифицировать - 
    использовать универсально значение null для всех типов данных объектов базы.



++++Методы в Тапп2
Из КонцептТапп2
Общее описание методов в версии 2.0. Методы существенно изменены, поэтому здесь приведено комплексное описание.

Основные сущности системы:
* [Контейнер]	- представляет систему. MEngine класс, содержит список классов, список методов, операции.
- Класс		- представляет класс сущностей. Класс содержит список объектов, списки связей с другими классами, список связей с методами, имя и другие данные, операции.
- Объект	- представляет сущность. Объект содержит списки связей с другими объектами, данные, операции.
* [Метод]		- представляет метод. Метод выполняет некоторую операцию, принимает и возвращает аргументы. Метод может быть сопоставлен одному или нескольким классам, может вызываться классом или объектом класса. 
			Метод содержит связи с другими методами, список связей с классами, список КТА, данные, операции.
* АргументМетода	- представляет аргумент метода. Аргумент имеет имя, тип, значение, другие данные.
* [КТА]		- представляет комплект типов аргументов для метода. Это вариант использования метода.
- связь класс/объект-класс/объект 	- связывает два класса или два объекта. По одному экземпляру связи для каждой стороны. 
						Содержит поля для хранения типа связей.
- связь класс-метод	- связывает метод с классом и класс с методом.
* связь метод-метод	- связывает метод с другим методом.  По одному экземпляру связи для каждой стороны.

Описание:
Контейнер содержит список методов. Все методы хранятся в этом списке.
Класс имеет список связей с методами. В версии 1 все методы жестко связаны с классом, хранятся в списке методов класса, вызываются только через класс.
В версии 2.0 методы являются самостоятельной сущностью, могут быть организованы в собственную структуру, могут вызываться через связанный с ними класс или индивидуально, по имени или номеру. Метод также может быть выбран и вызван при помощи иерархии методов,  этот вариант не изучен, но представляется перспективным, поэтому в архитектуре намечена его поддержка.

Поскольку один и тот же метод может вызываться разными классами, с разными типами данных, введены КТА. КТА хранит типы, значения, метаданные о вызове метода, это обеспечивает проверку корректности вызова метода.  КТА фиксирует использование метода для вызывающего класса. В методе есть список кта, в котором сохраняются все вызовы метода всеми классами. Предполагается использовать этот список для статистики и оптимизации выбора в иерархии методов. Планируется, что метаданные КТА позволят определять допустимый диапазон значений и типов аргументов, оценивать пригодность метода для конкретного использования и т.д. КТА содержит идентификатор класса/объекта, который вызывает метод. Для уменьшения размера списка КТА периодически, во время очередного вызова, проводится оптимизация - удаление дублирующихся записей, выделение трендов, и т.д.

Метод может быть абстрактным, не содержать кода, только обеспечивать выбор подходящего метода в иерархии абстракций. Таким образом, вместе с иерархией данных, это обеспечивает выполнение операции на всех уровнях абстракции. Это упрощает контроль и отладку абстрактных методов.

Связь класс-метод связывает классы и методы. В экземпляре метода существует список связей с классами. В экземпляре класса - список связей с методами.
Поскольку методы используются классами через КТА, то связь указывает на класс с одной стороны, и на КТА метода с другой. Таким образом, один класс может быть связан с несколькими методами, и даже с нескольким кта одного метода, различающимися типами аргументов (например, если метод абстрактный).
Метод может быть связан с несколькими классами, или ни с одним - в этом случае он может использоваться через иерархию классов.  Запрещается хранить в списке связей дубликаты.

Метод содержит основной КТА - КТА0. Этот КТА создается при создании метода, и определяет набор и типы аргументов, которые метод использует.
Предполагается, что КТА будет использоваться совместно с иерархией абстракций методов, что позволяет создавать и использовать абстрактные методы так же, как и конкретные. То есть, если КТА описывает абстрактные типы данных, то метод можно вызвать для конкретных типов данных. При этом автоматически должен быть найден и вызван подходящий метод, информация об этом выборе/вызове зафиксирована в КТА абстрактного метода, данные возвращаются как будто они исполнялись абстрактным методом.
Метод содержит поле для текста скрипта. Если поле пути к коду содержит путь, то метод вызывает CLR-код. Если нет, проверяется поле текста скрипта. Если оно не пустое, текст отправляется интерпретатору, если пустое - это абстрактный метод или ошибка. Абстрактный метод не содержит кода, используется для организации вызова конкретного метода. Информация для поиска содержится в списке кта метода.
  
Можно попробовать ввести в КТА показатель эффективности метода, который записывается по результатам метода. Можно будет выбрать подходящий метод на основе эффективности, определить границы эффективной работы метода, и прочие интересные возможности. Но это потом.

Связь метод-метод связывает методы таким же образом, как и аналогичные связи класс-класс. Можно выделить абстракци, агрегацию методов, и соответственно реализовать структуру. Для большей гибкости, методы связываются через концепцию КТА, обычно через кта0.

