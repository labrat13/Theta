++ Концепция Версии1

Это устаревшая версия концепции, в ней не стоит проводить переделки, принятые в остальной документации.

Work Project Doc wiki

Система
Система предназначена для создания, хранения, обслуживания структуры сущностей.
Исполняемый код системы совместно с структурой сущностей образует сервер системы.
Система реализована как подключаемый модуль - библиотека, для использования в составе приложения или сервера.
Структура сущностей физически хранится в БазаДанныхСолюшена, которая размещается на СерверSQLБД.
Во время работы структура сущностей частично содержится в оперативной памяти.
Код системы обслуживает статическую модель, описывающую данные, методы и отношения между ними. Эта модель строится в соответствии с концепцией, которую задает пользователь. Соответственно, система должна обеспечить минимальные ограничения свободы пользователя. Исполнение методов модели не входит в обязанности системы - поскольку устройство методов определяется пользователем, то пользователь сам создает код, работающий с методами. 
Для реализаций на неуправляемом коде целесообразно выносить исполнение методов в отдельный процесс, чтобы аварийное завершение метода не влияло на всю систему.

Дополнения в концепцию
Движок без БД. См СолюшенБезБД.
Предлагается внести изменения в движок, чтобы работать без БД.
Контейнер загружается из файла снимка, после работы результирующее состояние выгружается в файл снимка. Как в Tapp2.
Внутри солюшена используются только временные ячейки и связи. 
Таким образом можно использовать движок в любых солюшенах, без необходимости БД.
Ход работы в этом варианте:
Создание контейнера-загрузка снимка-операции ячеек и связей-выгрузка снимка-удаление контейнера
Для реализации нужно убедиться, что код, оперирующий в этом варианте, не использует БД.
Переделать соответственно код, если нужно. Можно предложить проверять флаг наличия данных о строке соединения с БД солюшена или ссылку на SqlConnection контейнера.
Соответственно, файл снимка должен содержать все необходимые для такой работы данные.
Если в операциях с временными ячейками используются ТранзакцияБД, (этого не должно быть вообще-то, но может оказаться из-за совмещенного с остальными ячейками кода), надо от них избавляться. При необходимости отката операций придется использовать предыдущие снимки или [Лог].

Структура сущностей
Сущность является смысловой единицей структуры. Сущность может быть реализована одной или несколькими связанными ячейками.
Структура сущностей физически состоит из связей, ячеек, контейнера. Ячейки и связи обобщенно именуются элементами структуры.
Структура может целиком или частично состоять из временных участков. Временные участки, образованные временными ячейками и связями с ними, не сохраняются в БД.
Структура сущностей хранится в БД. Во время исполнения постоянные сущности загружаются из БД в оперативную память для ускорения работы. Временные сущности создаются в памяти во время работы системы и могут быть сохранены - стать постоянными.


Начальное состояние

Все сущности определяются ПользовательскаяКонцепцияСолюшена с учетом ограничений реализации движка. Движок обеспечивает существование сущностей.
В первоначальной системе не существует никаких сущностей.
Нет типов данных, нет типов ячеек, типов связей, ...
Для создаваемых элементов в полях используется дефолтовый идентификатор типа. Этот идентификатор предоставляет ячейке МетодОбработчикЯчейки обработчики по умолчанию, прописанные в движке или определенные пользователем в отдельной специальной сборке.
Пользователь создает типы ячеек, типы данных, типы состояний, ...
Определяет операции для них, предусмотренные правилами движка и правилами солюшенируемой системы.
Например, чтобы добавить в систему тип данных "строка", нужно создать ячейку-сущность, и определить для нее методы, осуществляющие работу с данными этого типа. Для конверсии данных ячейки между приложением и таблицей, нужны функции-конверторы. Для поиска могут потребоваться специальные функции, и так далее. 
После того, как все необходимые элементы созданы, можно использовать новый тип данных в ячейках. Желательно структурировать элементы, чтобы организовать их представление пользователю, поиск, замену, и так далее.
Можно предположить, что в базе должны существовать сущности:
-служебный класс, имеющий специальное назначение
- класс

- служебный объект класса, имеющий специальное назначение

- объект класса
- метод
- экземпляр метода

- связь между ячейками

- тип связи

Контейнер
Контейнер представляет собой среду для существования элементов, и, соответственно, сущностей. 
Контейнер (Движок) предоставляет набор операций, с помощью которого выполняются базовые операции с элементами. Из этого набора пользователь создает специфические операции сущностей, именуемые методами. Контроль структуры сущностей выполняется пользователем или автоматическим [Оптимизатор]ом.
Контейнер имеет идентификатор, по которому его можно найти. В текущей версии идентификатор не играет никакой роли. В будущем планируется использовать его для реализации многоконтейнерных структур (См КонцепцияМультиконтейнерность).
Поскольку в текущей конфигурации контейнер доступен всему коду через статическую ссылку класса ячейки, которая используется везде, где она требуется, то следует придерживаться правила, что в одном процессе может существовать только один контейнер. Это удобно вписывается в общую концепцию контейнера-сервера.
ДОПОЛНИТЬ - особенности контейнера, поля и методы, представление контейнера в таблице и памяти.

Ячейка
Ячейка представляет минимальную единицу структуры. Ячейка хранит двоичные данные, которые интерпретируются в зависимости от ее типа. Ячейка может быть связана с другими ячейками при помощи связей. Ячейка имеет один общий список для всех связей.
Ячейка имеет уникальный идентификатор ячейки и символьное имя. Имя ячейки может быть не уникальным, поиск по имени возвращает список ячеек.

Ячейки могут быть представлены в одном из двух общих вариантов:
- типа MCellA - используются как ручки к строкам таблицы, содержащим соответствующие данные ячеек. В этом случае база всегда находится в согласованном состоянии, но работает медленнее.
- типа MCellB - полностью загружается в память, образуя цельное связное представление участка графа, что ускоряет выполнение операций, но увеличивает риск несогласованности базы при некорректном поведении. Разбиваются на подварианты: с кешированием чтения MCellB, с кешированием чтения и записи MCellBds, временные ячейки MCellBt.
Свойства, типы и другие характеристики ячеек и связей являются самостоятельными сущностями, и также представлены в виде ячеек. 
ДОПОЛНИТЬ - особенности поведения ячеек, представления, поля и методы ячейки.


Идентификатор ячейки
Ячейка имеет составной идентификатор, состоящий из ИдентификаторКонтейнера и ИдентификаторЯчейкиВнутриКонтейнера. ИдентификаторКонтейнера обозначает контейнер и используется для обозначения ячеек из другого контейнера, связанных с текущей ячейкой. При доступе к такой ячейке используются механизм коммуникации между контейнерами.
Поскольку идентификатор ячейки занимает место в связях, и механизм коммуникации контейнеров не разработан, в текущей версии солюшена нет ИдентификаторКонтейнера в ячейке. Все ячейки принадлежат одному контейнеру.
Идентификатор ячейки представлен типом int. Положительные значения обозначают постоянные ячейки, отрицательные значения обозначают временные ячейки. Значение 0 зарезервировано.
Новые ячейки получают новый идентификатор, на 1 больше максимального существующего. Временные - соответственно, с минусом. Для единообразия код, определяющий новый идентификатор, унифицирован для временных и постоянных ячеек.
Поскольку идентификатор ячейки много используется в связях, а связей больше, чем ячеек, в памяти хранится только значение (4 байта), а не объект класса идентификатора (16 байт). Операции с идентификатором - статические члены класса.

Связь
Связь соединяет две ячейки как From Up To Down. Связь имеет ось(Axis), определяющий интерпретацию связи.
Сейчас в определение связи входят только ячейки, ось, флаг активности. Остальные поля дополнительные. Между ячейками в каждой оси может быть только одна связь. (Пока пусть так, потом посмотрим). Таким образом, поле состояния связи не отличает связь от аналогичной.

Связи между ячейками двусторонние. В памяти каждая ячейка содержит ссылку на общий экземпляр связи. Кроме списков связей ячеек, связь содержится также в общем списке связей контейнера.
В таблице связей в БД каждой связи соответствует одна запись. В представление связи в памяти входят идентификаторы связанных ячеек, состояние связи, тип связи, флаг удаления, ссылки на ячейки, находящиеся в памяти. Если ячейка не загружена в память, или не записана в связь, ссылка = null. Идентификатор связи одновременно является первичным ключом в таблице связей. Связи могут быть постоянные и временные. Постоянные связи записаны в таблицу и им присвоен идентификатор записи. Временные связи не записаны в таблицу, существуют только в памяти, идентификатор записи = 0. Временные связи создаются ячейками временными или отложенной записи. Они записываются в таблицу при сохранении ячейки операцией Save().
Все ячейки могут связываться друг с другом. Проверка правильности структуры осуществляется [Оптимизатор]ом и оболочкой пользователя. 
Тип Нисходящая или Восходящая относительно ячейки, его можно вычислить для каждой ячейки вызовом функции. В самой связи он не хранится.
ДОПОЛНИТЬ - особенности поведения, представления, поля и методы связей.

Поля Axis и State
Должны хранить идентификаторы ячеек, представляющих ось и состояние связи соответственно. При создании идентификаторы = 0, это значит, что никаких таких ячеек нет и код выполняет операции по умолчанию. Если идентификатор отличен от 0, значит движок должен использовать МетодОбработчикЯчейки обработчики операций, предоставляемые этой ячейкой, если они есть.Эта концепция пока не развита, ее еще надо придумать полностью.

Между двумя ячейками может быть только одна активная связь в одной оси?
Может быть несколько неактивных связей.
Может ли быть несколько активных связей с разными состояниями? Пока непонятно — нет представления, как именно будет это работать.

Для постоянных связей, существующих в таблице, изменения полей связи (через проперти) в памяти должны немедленно записываться в таблицу. При загрузке связи данные заносятся специальной фунуцией, чтобы избежать перезаписи в таблицу. Для временных связей они записываются (создаются записи связей) при сохранении ячейки вызовом Save().





солюшен
Структура сущностей с точки зрения пользователя представлена солюшеном.
Физически солюшен представлен каталогом на диске. Логически солюшен представлен файлом солюшена.
солюшен включает в себя файл солюшена, БД, файлы и каталоги для [Лог]а, снимков, ресурсов, сборок кода методов. Пользователь может просматривать, создавать и изменять структуру системы, создавать и удалять солюшены, просматривать их свойства.
ДОПОЛНИТЬ - операции пользователя с солюшеном


Структура файлов солюшена
ProjectName - основной каталог солюшена
Methods - каталог для сборок кода методов

asm.dll 

Logs - каталог логов

ProjectName.No.log 

Snapshots - каталог снимков структуры

ProjectName.No.step

Resources - каталог ресурсов структуры

ResFileID.*

ProjectName.tapj - файл солюшена
Database – каталог для БД и ее бекапов. 
ДОПОЛНИТЬ - описать назначение и правила устройства каталогов солюшена.

Типично файлы БД располагаются на СерверSQLБД. В каталоге Database, таким образом, можно хранить лишь бекапы и прочее. При локальной БД в этом каталоге можно хранить файлы БД, но они не будут архивироваться вместе с солюшеном, когда подключены к СерверSQLБД. В целом удобно архивировать весь каталог для распространения и бекапа [Солюшен]а.

ФайлСолюшена
Файл солюшена представляет солюшен для пользователя.
Файл солюшена имеет формат XML и класс, читающий-пишущий этот файл подобно файлам настроек .NET.
Файл солюшена содержит имя и описание солюшена, версию солюшена, дату создания, необходимую версию движка, путь к серверу БД и имя БД, ...
ДОПОЛНИТЬ - добавить описание полей файла солюшена


Лог
Система содержит средства для ведения [Лог]а всех операций. [Лог] реализован как последовательность записей о событиях. [Лог] пригоден для автоматического анализа и может использоваться для отката изменений или анализа операций. Каждая запись [Лог]а содержит таймштапм, код события, текстовое описание, состояние элементов, участвующих в событии. События разделены на классы, можно записывать только выбранные классы событий, регулируя таким образом детализацию [Лог]а.
Логически [Лог] состоит из сеансов. Сеанс описывает работу движка от включения до выключения. Для сокращения размера [Лог]а можно отключать вывод текстовых описаний. 

Сейчас описана реализация [Лог]а как текстового. Если сделать [Лог] двоичным, его размер сократится вдвое, но для анализа нужен будет специальный вивер. Возможно, это даже лучше, меньше мороки. Но лучше делать после прототипа, а то переделывать вивер неохота. 
- Однако поскольку конвертеры типов данных ячейки являются частью базы, для представления данных ячейки придется использовать только двоичный/HEX формат. Это удобно для отката транзакций ТранзакцияСолюшена и восстановления базы, но неудобно для анализа и отладки, тем более если база неработоспособна. 
[Лог] имеет CSV-формат.
[Лог] состоит из последовательности сообщений. Каждое сообщение состоит из полей, разделенных разделителем. Каждое сообщение на одной строке.
Таким образом, каждое сообщение должно иметь все возможные поля, хотя бы пустыми, и не содержать в них символов-разделителей.
Сообщение записывается в [Лог] StreamWriter-ом, можно указать кодировку выходного файла. Желательно ее не менять в процессе работы, либо прописать в коде, либо хранить в настройках контейнера.

Логически [Лог] состоит из сеансов. Сеанс описывает работу базы от включения до выключения. 

Сообщение [Лог]а состоит из: ПЕРЕДЕЛАТЬ - 
Кода класса события - для поддержки фильтров.
Кода события - какое событие произошло (функция, исключение или пользовательский комментарий) 
Аббревиатуры события (для пользователя) 
Таймштампа сообщения - когда оно добавлено в [Лог].
Исходного состояния объекта: в HEX и в кратком текстовом описании
Конечного состояния объекта: в HEX и в кратком текстовом описании
Текста сообщения - для пользователя

Классы сообщений ДОПОЛНИТЬ
ошибки SQL
операции SQL-слоя кода
транзакции ТранзакцияСолюшена
чтение ячеек
изменение ячеек
чтение, поиск связей
изменение связей
ошибки движка
сеанс движка, SQL
сериализация
пользовательские сообщения
сообщения [Оптимизатор]а





Сериализация, снимки
База может быть сериализована в текстовый или двоичный файл, и обратно.
Текстовый файл для анализа пользователем, двоичный - для хранения промежуточных копий-шагов.Такой файл называется Снимком.
Сериализация также предназначена для передачи элементов структуры через сеть.

Снимок представляет собой копию структуры, сериализованную в файл. Снимок может быть десериализован обратно в структуру. Бинарный снимок используется для резервного копирования или экспорта. Текстовый снимок нужен для анализа пользователем. Его удобно создавать в HTML-формате.

Снимок может быть Полным или Частичным. 
Полный снимок представляет собой копию структуры, и при его загрузке создается новая база данных. Поэтому он должен содержать всю необходимую информацию.

Частичный снимок содержит некоторую часть структуры сущностей, объединенную неким смыслом. Такой снимок может храниться как ресурс. При загрузке эта часть добавляется к уже существующей структуре. Нужно согласовывать структуру, это усложняет загрузку и может окончиться неудачей.

При загрузке полного снимка контейнер перезаписывается, при загрузке частичного — дополняется. Соответственно разное поведение.

Типы снимков:
Бинарный полный снимок
Бинарный частичный снимок
Текстовый полный снимок

Двоичный формат:
Каждый элемент выводится записью. Формат записи фиксированный.
Запись содержит код типа элемента (ЗаголовокСнимка, контейнер, ячейка, связь, ...) и длину.
Поля произвольной длины (строки, массивы) предваряются размером поля. Размер поля хранится int 4 байтами
Идентификаторы ячеек хранятся 8 байтами. Пока ИдентификаторКонтейнера не используется, старшие 4 байта = 0.
Поскольку структура из снимка может занимать много памяти, при загрузке теоретически может возникнуть недостаток памяти.

Сериализация данных ячейки в текст должна будет использовать МетодОбработчикЯчейки обработчики из ячеек типов данных.

Полный снимок
Полный снимок представляет собой копию всех ячеек и связей из памяти и БД.
Из памяти извлекаются только временные ячейки и связи — их легко опознать по идентификаторам. Временные связи извлекаются из списка связей контейнера, там они должны быть в одном экземпляре. Постоянные ячейки и связи извлекаются из таблиц БД.
Таким образом, будет сериализована полная копия солюшена.
Если в солюшене нет БД (новый вариант), то из БД не берем ничего.
При десериализации нужно сначала создать новую БД (если она должна быть в солюшене/снимке), затем набить ее данными согласно снимку. 
На выходе процесса десериализации должен быть контейнер в том же состоянии, что и на момент создания снимка.



Частичный снимок
В_РАЗРАБОТКЕ - разработать теорию про загрузку.
Частичный снимок представляет собой копию участка структуры солюшена. Частичный снимок предназначен для экспорта части структуры в другие солюшены или для создания снимка-ресурса.
Снимок включает в себя как временные так и постоянные ячейки. Удобно использовать временные ячейки, но они также будут связываться с постоянными ячейками внутри и вне сериализуемого участка структуры. Частичный снимок не должен ссылаться на внешние временные ячейки, так как это приведет к рассогласованию структуры. Таким образом, частичный снимок должен включать в себя все временные ячейки, на которые ссылаются ячейки, находящиеся внутри снимка.
В общем, необходимо какм-то образом определить сериализуемый участок и отличить ячейки, помещаемые в снимок, от остальных ячеек в структуре. 
При десериализации необходимо проверить, что ячейки, на которые ссылаются ячейки в снимке, соответствуют по состоянию ячейкам, существующим в структуре. Поэтому в снимке предлагается также хранить хеши (ИД и имена?) внешних ячеек(или целиком эти ячейки, для удобства контроля различий), при десериализации проверять наличие и состояние ячеек и выдавать предупреждения. Иначе при несовпадении версий структуры могут быть неочевидные ошибки.
Однако такой снимок предполагает резервирование идентификаторов находящихся в нем ячеек, чтобы исключить конфликты идентификаторов при загрузке. Это не позволяет проводить дефрагментацию пространств идентификаторов. Или же при загрузке нужно будет переделывать идентификаторы ячеек снимка, это делает неудобным адресацию ячеек в методах.
Получается, формируем список ячеек для снимка, список их связей (в единственном экземпляре), список связанных ячеек — для вычисления хешей.
При десериализации нужно проверять и согласовывать идентификаторы ячеек, при необходимости заменять их, если уже заняты.




Снимок-ресурс

Снимок-ресурс представляет собой частичный снимок структуры. В него включаются ячейки и связи, которые затем удаляются из структуры. Ресурс разгружает структуру от редко используемых участков. Таким образом можно создать специализированный участок структуры, который имеет высокую сложность, но редко используется, выгрузить его в ресурс и загружать только при необходимости.


Сериализация в двоичный формат

Структура файла
ЗаголовокСнимка
СекцияКонтейнера
секция списка ячеек
секция списка связей
СекцияКонцаФайла
Каждая секция имеет описатель, размер секции в байтах, данные.
Описатель — код типа секции, 1 байт
Размер секции - поле 8 байт

Секция шапки файла содержит:
дескриптор формата — установленная последовательность байт для идентификации файла снимка.
размер секции в байтах
версию движка — для проверки совместимости при загрузке
версию структуры 
число ячеек — для пользователя, проверки доступной памяти.
число связей — для пользователя, проверки доступной памяти.
код типа снимка: полный снимок или частичный снимок.
название солюшена — для пользователя. Ввиду переменного размера, поместить в конец шапки.
...

Секция описания контейнера:

byte код секции
int размер секции
...
контрольная сумма


Секция списка ячеек:
код секции, 1 байт
размер секции, 8байт
число ячеек, 4 байта
секции описания ячеек.
контрольная сумма без учета секций описания ячеек

Секция описания ячейки:
1)код секции 1б
2)длина записи, байт 4б
3)ид ячейки 8б
4)длина строки имени 1-2б
5)символы строки имени
6)ид stateID 8б
7)ид typeID 8б
8)ид valueTypeID 8б
9)длина массива данных, байт 4б
10) массив данных
11) длина строки описания 1-2б
12) строка описания
13) isActive 1б
14) Creatime 8b
15) moditime 8b
16) readonly 1b
17) serviceflag 4b
18) checksum 2byte – контрольная сумма секции
19) 

Секция списка связей:
код секции, 1 байт
размер секции, 8байт
число связей, 4 байта
секции описания связей.
контрольная сумма без учета секций описания связей

Секция описания связи:
byte код секции 1б
int длина записи, байт 4б — длина записи без заголовка и текущего поля, т. е. добавляешь эту длину к позиции чтения и попадаешь на первый байт следующей секции.
mid downCellId 8b
mid upCellId 8b
mid axisId 8b
mid stateId 8b
bool isActive 1b
int serviceFlag 4b 
int linkId 4b — нужен для отличения временной связи от постоянной. При десериализации значение заменяется на правильное.
string description 
checksum 2byte – контрольная сумма секции

Секция конца файла
byte код секции 1б — признак конца файла

Типы секций

Временных ячеек — из памяти
Постоянных ячеек — из БД
Связанных ячеек — из БД. Это список ячеек, связанных с ячейками, входящими в частичный снимок. Эти ячейки должны быть только постоянными, временные ячейки должны включаться в частичный снимок. Секция предназначена для проверки согласованности состояния структуры при загрузке частичного снимка. Связи, связывающие эти ячейки с ячейками из снимка, хранятся в секциях снимка, остальные связи этих ячеек не сохраняются в снимке.
Для полного снимка сюда помещаются внешние ячейки (не входящие в данный контейнер, но связанные с его ячейками) точно так же, как для частичного снимка.
Временных связей — из памяти
Постоянных связей — из БД.
Секции ячеек/связей из памяти и из БД можно объединить, различать элементы при загрузке.
Поскольку связи требуют наличия ячеек, то сначала идут секции ячеек, а потом связей.
Связанные ячейки не загружать, а проверять наличие и идентичность. Если не совпадает, остановить загрузку и выдать сообщение. 

Процесс сериализации полного снимка:
Создается файл снимка имясолюшена.шаг.расширение в каталоге снимков солюшена.
В файл пишется сигнатура типа файла 8байт. Затем записывается ЗаголовокСнимка, содержащая информацию о солюшене и снимке, число ячеек и связей. Затет пишется секция контейнера, содержащая состояние контейнера. Затем идут секции ячеек — из памяти, из таблицы, связанных ячеек. Вывод ячеек и связей должен использовать небольшой объем памяти, поскольку в основном память занимает структура. Для вывода ячеек и связей из таблиц используется алгоритм ступенчатого понижения размера выборки при недостатке памяти. 
Каждая секция имеет длину и контрольную сумму. Секции связей и ячеек имеют счетчики элементов. Секции элементов в секциях следуют друг за другом. Их количество хранится в секции.
Сначала сериализуются ячейки. 
Все ячейки из памяти записываются в секцию ячеек в памяти. Эта часть снимка хранит состояние структуры в памяти на момент создания снимка — состояние ячеек MCellBt и MCellBds, присутствие ячеек в памяти итд. 
Все ячейки из таблицы записываются в секцию ячеек из БД. Эта часть снимка хранит постоянные ячейки структуры.
Если в структуре участвуют внешние ячейки — находящиеся в другом контейнере — они записываются в секцию внешних ячеек. Это позволяет при десериализации проверять состояние таких ячеек, и выдавать предупреждения о проблемах совместимости версий структуры. Ячейки пишутся полностью, хотя, конечно, не все их поля важны, переделывать и усложнять формат снимка будем потом.
Список ВнешняяЯчейка ячеек можно получить из списка связей таблицы и контейнера, выделяя их по ИдентификаторКонтейнера. В текущей версии ИдентификаторКонтейнера не применяется, поэтому ВнешняяЯчейка ячеек нет, и секция внешних ячеек в полном снимке будет пустой.
Связи сериализуются подряд, без разделения на постоянные и временные. Из списка связей контейнера берутся только временные связи, из таблицы — постоянные. 

Завершает файл байт описания секции конца файла.

Десериализация полного снимка:
Задача — восстановить исходное состояние структуры в памяти и таблице. Для этого надо очистить таблицы БД или вообще удалить и создать заново. Вероятно, после загрузки потребуется перестроить индексы таблиц. Из этого следует, что в коде не должны использоваться значения, производные от переменных состояния БД, так как при загрузке снимка они будут отличаться.
Сначала десериализуются ячейки. Удобно десериализовать сначала ячейки в памяти — меньше переделывать, если пользователь отменит операцию, и проще контролировать ошибки десериализации — доступ к несуществующей записи в таблице. Хотя структура может занимать много памяти, надо подумать...
Ячейки в память восстанавливаются в исходном виде. Необходимо обходить процедуры записи новых значений в таблицу.
Ячейки в таблицу восстанавливаются последовательно друг за другом.
Внешние ячейки должны проверяться на совпадение состояния, если не совпадают, пользователь должен разобраться и принять решение.
Связи десериализуются после создания ячеек. Временные связи помещаются в контейнер и списки связей самих связанных ячеек. Постоянные связи сначала записываются в таблицу, потом из таблицы получают новый идентификатор, затем проверяют наличие ячеек в памяти и соответственно записываются в контейнер и ячейки.

Частичный снимок:
Для сериализации надо выделить сериализуемые ячейки из структуры. Создать список идентификаторов ячеек будущего снимка. Проверить, что все внешние по отношению к будущему снимку ячейки постоянные. Временные внешние ячейки надо либо включить в список, либо запросить пользователя. Эти ячейки связаны с ячейками будущего снимка, поэтому их связи останутся в снимке — будут проблемы при загрузке снимка.
Внешние ячейки перечисляются в секции внешних ячеек снимка. 

При десериализации элементы снимка вписываются в существующую структуру. При этом нужно согласовать идентификаторы, проверить совпадение ВнешняяЯчейка ячеек, ...




Ресурсы
Система может создавать, искать, открывать, читать, писать, закрывать, удалять файлы ресурсов.
Ресурсы представляют собой файлы, привязанные к элементам структуры. Это могут быть внешние файлы, необходимые пользователю, или созданные самой системой. Файлы хранятся в каталоге ресурсов солюшена, в подкаталогах. Каждый каталог может содержать не более 1024 файлов.
ПЕРЕДЕЛАТЬ - имена файлов ресурсов, генерация имен, распределение файлов по каталогам.
Имя файла ресурса — число в HEX-формате, 8 символов. При поиске по имени файла имя транслируется в DWORD, старшие 22 бита образуют номер каталога, в котором размещается файл. Поскольку каталогов в каталоге ресурсов нельзя создать столько, для использования всего пространства имен придется усложнять структуру, но это на следующий прототип. 
Расширение файла ресурсов остается прежним. Для созданных системой ресурсов расширение .res и шапка формата, позволяющая отличить от прочих файлов.
Если потребуется хранить версии, их можно нумеровать: XXXXXXXX.VV.RES


Оптимизатор
Оптимизатор предназначен для поддержания порядка в структуре сущностей.
оптимизирует БД, индексы и таблицы.
удаляет элементы, помеченные к удалению - сборка мусора.
дефрагментация пространств идентификаторов
...

Оптимизатор запускается при работающем контейнере для удаления помеченных удаленными ячеек и связей, при работе пользователя, это разгружает систему после интенсивной работы.
Оптимизатор запускается при незагруженном контейнере для оптимизации структуры в БД и самой БД. 
Поскольку при работе системы получаются пробелы в использовании пространства идентификаторов, оптимизатор может производить дефрагментацию этого пространства, заменяя идентификаторы в ячейках, методах и связях для тех ячеек, которые не имеют связей вне обслуживаемого сейчас контейнера. Нужно полностью заменить все существующие идентификаторы ячейки. Поскольку МетодИзКода не поддается такой модификации, нужно соблюдать правило - в этих методах получать ячейки только по имени. Если это возможно.



