++ Общие Сведения О Логе
[//ПЕРЕДЕЛАТЬ] - много устаревших материалов
[//ПЕРЕДЕЛАТЬ] - разделить на общую информацию и реализацию, реализацию перенести в другие разделы или в карточку глоссария.
[//ДОПОЛНИТЬ] материалами из других разделов.

+++О концепции
Это новая версия концепции подсистемы лога. Многопользовательская с подержкой транзакций и блокировок доступа к изменяемым данным. Она создавалась для того, чтобы решить множество проблем, мелких и крупных.
Она выглядит довольно сложной, избыточной, но это точно лучшая из всех версий подсистемы лога, что у меня сейчас есть.
Она еще экспериментальная, и мне хочется ее реализовать, чтобы понять, что было сделано правильно, а что надо переделать.
Предыдущие версии подсистем лога были довольно примитивные, да и я их толком не реализовал ни разу.
Теперь эти материалы из прошлых версий тут мешаются, их надо приводить в соответствие с общей идеей. 
++++Общее строение многопользовательской системы Движка Тапп Бар
* Строение подобно веб-сайту. Есть один пользователь для БД, и один и более клиентов. У каждого клиента есть собственный логин (ИдентификаторАгента). И возможно пароль, но это сейчас не используется.
* Когда пользователь запускает [Движок], он подключается к Солюшену, в том числе, к БД Солюшена.
* Затем пользователь запрашивает для себя объект КонсольПользователя. Этот объект хранит в течение всего СеансПользователя всю информацию о пользователе: Логин, открытые транзакции ТранзакцияСолюшена, итд. КонсольПользователя скрывает от пользователя механизм идентификации.
* Пользователь работает только через КонсольПользователя, вызывая в ней операции Движка.
* КонсольПользователя передает Движку вызовы операций [Движок]а пользователем, подставляя в них объект-описатель СеансПользователя, необходимый для работы подсистем [Движок]а. 

+++Общее представление
* Движок ведет лог Солюшена, в котором отражаются события СобытиеЛога, операции и состояния элементов ЭлементСтруктурыСущностей. 
Этот лог можно использовать для отката ошибок, для анализа происходящих в базе процессов, для отладки [Метод]ов.
* Лог должен быть пригоден для автоматического анализа и будет использоваться для отката изменений или анализа операций.
* В лог выводятся сообщения о начале и окончании операции, аргументы операции, сообщения об ошибках в процессе выполнения операции. Операции можно сгруппировать в ТранзакцияСолюшена, таким образом помечая этапы выполнения сложных операций. ТранзакцияСолюшена затем можно подтвердить или откатить.
* [Оптимизатор] оставляет сообщения в [Лог]е в ходе работы.
* Пользователь может добавлять сообщения в [Лог] в ходе работы. Он может использовать эту возможность для пометки неких этапов своей работы.
* Код [Метод]а может добавлять сообщения в [Лог] в ходе работы. Он может использовать эту возможность для пометки неких этапов своей работы.
* [Лог] является частью Солюшена, данные хранит в отдельных ФайлЛогаСолюшена
* [Лог] превращается в существенную часть проекта и требует существенного внимания.

+++Виды лога - слишком много реализации, ее надо перенести в раздел ОрганизацияЛогаДвижка
Лог можно реализовать как текстовый или как двоичный. 
* ТекстовыйЛог сложнее реализовать, но он лучше подходит пользователю. Удобен при отладке грубых ошибок. 
* ДвоичныйЛог проще реализовать, он компактнее, но он плохо подходит пользователю. Удобен при отладке сложных ошибок.
* Решено вести ДвоичныйЛог, а для пользователя использовать КаналСообщенийЛога (См главу Канал сообщений лога), через который передавать только символьную информацию в течение сеанса работы пользователя. Он будет использоваться при визуальном обнаружении ошибок при отладке, и поэтому должен иметь удобный для восприятия и поиска формат
    * И такой двойной лог будет тормозить работу, так что его имеет смысл включать только по требованию пользователя. 

++++Двоичный лог
ДвоичныйЛог состоит из последовательности записей ЗаписьДвоичногоЛога сеансов СеансЛога, которые содержат записи сообщений СообщениеЛога. Каждая ЗаписьДвоичногоЛога состоит из маркера-заголовка, длины записи, таймштампа, полей сообщения в установленном формате, контрольной суммы, маркера-окончания сообщения.
Записи отражают работу [Движок]а в течение СеансЛога - от записи об открытии сеанса до записи о закрытии сеанса. 

Двоичный лог имеет меньший размер, лучшую детализацию, лучшую анализопригодность, но плохую наглядность. Для просмотра лога требуется программа-визуализатор УтилитаПросмотраЛога. Ошибки в реализации могут сделать лог нечитаемым. Маркеры начала и конца позволяют обнаружить нарушения формата сообщений и восстановить следующие за нарушением сообщения.

+++Сопоставление версии подсистемы лога и версии Солюшена
* ОбсуждениеСопоставлениеЛогаИВерсииСолюшена

++++Версии подсистемы Лога
* Эта подсистема должна реализовываться как отдельный модуль внутри или вне сборки [Движок]а. Поэтому она имеет собственную версию. См. ТемаКакИспользоватьСолюшеныВБудущем
* СписокВерсийПодсистемыЛога
* ВерсияПодсистемыЛога
* todo.концепция.лог: Нужно реализовать проверку соответствия версии ФайлЛогаСолюшена как часть проверки формата файла.


+++Контроль детализации лога
* Лог используется для отмены ТранзакцияСолюшена. Поэтому сообщения о изменении данных должны всегда записываться в лог. 
* Сообщения-комментарии предназначены только для пользователя, просматривающего лог. Вот их можно отключать.
* Степень детализации лога нужна для фильтрации СообщениеЛога, показываемых пользователю в окне приложения через КаналСообщенийЛога  (как он называется?). Приложение (если оно имеет монопольный доступ к [Движок]у) может назначить этот уровень для регулирования важности сообщений канала, чтобы получать только важные СообщениеЛога. Это быстрее, чем отправлять через КаналСообщенийЛога все сообщения и фильтровать их в приложении. Поскольку ненужные СообщениеЛога не будут преобразовываться в ТекстовоеСообщениеЛога и потом пересылаться между модулями процесса. 
* Для контроля уровня детализации лога надо в МенеджерЛога иметь ПолеСтепеньДетализацииЛога. Оно должно загружаться из НастройкиСолюшена при инициализации ПодсистемаЛога.
* ПолеСтепеньДетализацииЛога можно использовать для фильтрации комментариев в логе. Комментарии могут быть полезны внутри методов - для анализа и отладки их работы. 

+++Использование лога пользователем
++++Для отладки
* При работе Солюшена могут возникать коллизии из-за несовершенства СтруктураСущностей. При этих проблемах предполагается запрашивать пользователя с помощью диалоговых окон.
Запросы на разрешение коллизий непонятны без контекста и будут приводить к ошибкам из-за того, что пользователь неверно понял контекст. Контекст может быть извлечен из лога. Это важно при анализе выполнения [Метод]ов или после перерыва в работе. Значит, пользователю надо предоставлять [Лог] для просмотра  и анализа записей о сущности запроса до момента запроса. Запросы на разрешение коллизий надо иметь возможность игнорировать, иначе вся работа встанет при первой же кольцевой зависимости.
* В [Лог] нужно записывать комментарии пользователя, в том числе, из [Метод]ов. Это помогает понять что делалось внутри метода и в ходе работы пользователя.

++++Для восстановления контекста
* Пользователь должен в любой момент иметь возможность просмотреть лог последних операций, чтобы восстановить контекст своей работы. Система должна предоставлять пользователю достаточно подробный контекст, извлекая и представляя данные из лога. Это снизит трудоемкость при принятии решений.
* Рекурсии в операциях вызывают прерывание текущего контекста задачи и начало нового. Предыдущий контекст обычно запоминается, но может быть потерян по разным причинам. Визуально объединенное представление составляющих контекста позволяет быстро восстановить контекст. 
Например, диалоговое окно с контролами представляет контекст операции, поэтому, вернувшись к нему, пользователь понимает, какую операцию он собирался выполнить, и что для этого нужно. Хотя, возможно, он уже не помнит, зачем нужна эта операция, и тут для восстановления контекста нужен видимый пользователем лог.

++++Утилита просмотра лога
* Лог сложный, и для его прямого просмотра пользователю нужен специальный УтилитаПросмотраЛога.

++++Канал сообщений лога - разделить на общую информацию и реализацию и вынести реализацию в карточку глоссария
* Для показа сообщений лога пользователю нужен способ передавать их пользовательскому приложению.
Там они могут быть увязаны с событиями самого приложения, предоставляя пользователю лучшее понимание контекста его работы.
* Приложение должно подключиться к КаналСообщенийЛога, через который МенеджерЛога рассылает всем абонентам текстовые версии сообщений лога [Движок]а - ТекстовоеСообщениеЛога. Эти сообщения должны включать в себя классы сообщений, чтобы приложение могло само фильтровать сообщения, показываемые пользователю.
Движок может фильтровать рассылаемые сообщения, за это отвечает поле ПолеСтепеньДетализацииЛога в МенеджерЛога. См. главу Контроль детализации лога.
* Предлагается сделать некоторое СобытиеNET, которое и будет отправлять приложению эти тексты.
А приложение будет подключаться к источнику сообщений и выводить их в строку состояния или контрольную консоль. Такой источник событий может рассылать сообщения нескольким получателям.
* todo: Это нужно разработать как глобальную фичу Движка, а не только в рамках Лога. Этим должны пользоваться все подсистемы.
    * todo.концепция.лог: Надо осмотреть другие подсистемы - можно ли в них применить эту штуку.
* Это СобытиеNET должно быть публичным.
* Можно при добавлении СообщениеЛога в лог генерировать событие (надо придумать название) СобытиеNET, которому передавать текстовую версию сообщения: ТекстовоеСообщениеЛога.
* СообщениеЛога должно быть конвертировано в текст для вывода его в КаналСообщенийЛога.
* todo.концепция.лог: Тут надо решить: 
    * использовать одно такое событие для всех сообщений,
        * Разместить его источник в объекте Солюшена или Контейнера и отправлять сообщение вызовом функции этого объекта.  
    * или у каждой подсистемы сделать собственный источник событий.
        * Это повысило бы модульность подсистемы. Сообщения от модулей можно было бы собирать в одном обработчике движка и перевыпускать сообщение для приложения.
        * Тут тоже обработчик в объекте солюшена или контейнера, только он тут собирает сообщения от модулей, а конфигурируется при инициализации движка.

++++Текстовое Сообщение Лога
* Должно включать в себя класс сообщения Лога, чтобы приложение могло само фильтровать сообщения, показываемые пользователю.
* см ТекстовоеСообщениеЛога
* Двоичные данные в ТекстовоеСообщениеЛога не нужны, их нужно представить текстом, насколько это возможно, для пользователя.
* Сериализация данных ячейки в текст для показа пользователю должна будет использовать МетодОбработчикЯчейки обработчики из ячеек ЯчейкаТипаДанных. Эти конвертеры типов данных ячейки являются частью СтруктураСущностей, 

+++Многопользователи
* Один и тот же солющен не может быть открыт одновременно двумя приложениями, так как каждое из них будет вести собственный лог, чего нельзя допустить. Это никак не удастся совместить, так как будет два разных экземпляра dll в памяти разных процессов. Тут можно предложить только или единоличное использование солюшена, или использование солюшена через серверную модель. Сейчас серверную модель я не предполагаю, поэтому делаем только однопроцессную систему. 
* Хотя можно предложить синхронизацию записи лога через общий объект ядра - семафор, итп. Эта работа с семафором тогда должна быть включена в Движок везде. Процесс просто должен ждать, пока семафор освободится, и затем выполнить свою работу. Но это все равно предполагает монопольный доступ к солюшену, да и файлы лога надо закрывать-открывать каждый раз при начале-завершении операции. В целом, все это сейчас невыгодно делать - лучше делать однопроцессную систему с монопольным доступом. А в ней многопользователи вроде бы не нужны?
* Много пользователей предполагает многопоточность Движка. Эта тема сейчас не изучена.
* Однако, эта КонцепцияЛога предполагает множество пользователей. Она создается в расчете на будущее. Для однопользовательской конфигурации ее придется немного сократить, но основные решения останутся теми же. Я разрабатываю ее сразу большой, чтобы сократить потом объем переделок.

* Решено вести один общий лог [Движок]а на всех пользователей. Пользователи могут выбрать свои записи через механизм, реализуемый кодом.

+++Менеджер Лога
* МенеджерЛога представляет всю ПодсистемаЛога для остальных частей [Движок]а. Он должен быть максимально самодостаточным. Но учитывать особенности остальных частей системы.
* УтилитаПросмотраЛога использует АПИ МенеджерЛога для извлечения данных из [Лог]а.


++Обязанности Подсистемы Лога
 Тут нужно описать внешние обязанности подсистемы Лога. 
 
 У [Лог]а должна быть хорошая информативность, навигация и структурирование. В [Лог]е и в [Метод]ах нужно применять комментарии, описывающие суть или этап выполнения операции, особенно для сложных операций. Однако для частых операций это приведет к тому, что [Лог] будет быстро расти, и станет отдельной серьезной темой.
Еще для [Лог]а хорошо бы пользователю иметь возможность виртуально (понарошку) повторить некоторую часть процесса работы системы, или отдельный метод, по данным [Лог]а, чтобы что-то нужное выяснить. 
 
++Материалы


+++Обязанности менеджера лога - устарело, переделать
* Инфраструктура менеджера лога
    * См. ИнтерфейсМенеджеровПодсистем. Это функции, определяемые АПИ всех менеджеров подсистем. Единообразные для всех менеджеров подсистем.
* Ведение лога ТранзакцияСолюшена
    * todo.концепция.лог: Какие функции входят в Ведение лога?
    * Это функции, выполняющие преобразование данных, запись в ФайлЛогаСолюшена, ...
    * Операции с СеансЛога
        * Открыть (создать новый) СеансЛога
        * Завершить СеансЛога 
    * Операции с файлами лога: 
        * создание
        * открытие
        * закрытие
        * удаление
        * регулирование общего числа ФайлЛогаСолюшена
        * Возможно, сжатие файлов.
    * Создание нового имени ФайлЛогаСолюшена
    * Хранить НомерФайлаЛога
    * Поиск последнего ФайлЛогаСолюшена
    * Проверка размера ФайлЛогаСолюшена
    * Добавить сообщение в лог
    * Получить путь к ФайлЛогаСолюшена
    * Создать путь к ФайлЛогаСолюшена
    * Проверка класса события для регулировки детализации лога.
        * Лог используется для отмены ТранзакцияСолюшена. Поэтому события о изменении данных должны всегда записываться в лог. 
* Чтение лога ТранзакцияСолюшена
    * todo.концепция.лог: Какие функции входят в Чтение лога?
    * Это такие же функции, какие выполняет база данных при работе с таблицей: выборка по условиям на значения полей, сортировка, упаковка данных в объекты записей лога. INSERT, UPDATE, DELETE тут не нужны, только SELECT.
    * очевидно, сортировка записей по хронологии  и по ИдентификаторСеансаПользователя. Хотя я не уверен.
    * возможно, не все данные записи лога востребованы при анализе. Тогда можно загружать только нужные данные, чтобы не занимать память.
    * При чтении лога нужно найти начало полезных записей. Оно может располагаться в текущем ФайлЛогаСолюшена или в одном из предыдущих ФайлЛогаСолюшена. Значит, надо их открыть и прочитать. Не занимая существенно оперативную память.
Значит, нужно получать имена этих предыдущих файлов как последовательный список.    
    
+++++Операции менеджера лога - устарело, переделать
++++++Открыть лог - операция при инициализации подсистемы лога.
1) Находим последний ФайлЛогаСолюшена. (Каким образом?)
2) Если размер файла лога меньше чем МаксимальныйРазмерФайлаЛога, то открываем его.
  Иначе создаем новый файл лога и открываем его.

++++++Вывод в лог - операция вывода сообщения в лог.
1) Контролировать класс события для регулировки уровня детализации лога. Соответственно, решаем: записать событие в лог или ничего не делать.
    * Для этого контроля надо в МенеджерЛога иметь ПолеУровняДетализацииЛога. Оно должно устанавливаться при инициализации ПодсистемаЛога.
2) После записи проверить размер файла лога. 
Если размер файла лога больше чем МаксимальныйРазмерФайлаЛога,  то Закрываем файл лога, создаем новый файл лога и открываем его.

++++++Закрыть лог - завершение работы подсистемы лога
* вроде просто закрыть лог? Не так все просто...

++++++Проверка класса события для регулировки детализации лога
* Функция получает класс события добавляемой записи и сравнивает его с допустимым классом событий, указанном в поле менеджера лога. Если событие разрешено, функция возвращает Да, иначе - Нет. Вроде бы просто, но там куча нюансов, и код лучше организовать в отдельную функцию.



++++++Создание файла лога
* Нужно создать новое имя файла лога. Для этого нужен номер последнего файла лога. Как его получить?
    * А если файлы лога были вручную удалены из проекта, как быть с номером файла лога?
* Затем надо создать шапку файда лога как объект в памяти. По этой шапке код может узнать некие свойства файла лога. Какие в ней должны быть данные?
* Затем надо создать и открыть новый файл лога (для чтения и записи?). todo.концепция.лог: При этом могут возникнуть исключения, которые надо обработать правильно.
* Вывести в файл лога шапку файла лога.
* Возможно, вывести в файл лога запись о продолжении текущих СеансПользователя всех пользователей. Чтобы код, прочитав эти записи, обратился к предыдущему файлу лога за записями их сессий. 
    * todo.концепция.лог: Надо продумать вывод в файл лога связку текущих СеансПользователя пользователей.
    * Для этого надо получить откуда-то информацию о текущих СеансПользователя пользователей. Причем в любой момент времени. Откуда?
* вроде бы конец...

++++++Закрыть файл лога
* Закрытие файла лога по достижении предельного размера, или по завершении последнего сеанса пользователей.
* Это просто, в конец файла пишется маркер - байт конца файла. Или вообще ничего не пишется. Тогда код будет читать тупо до конца файла. Хотя есть риск что хвост файла пропадет и это останется незамеченным. Но это вряд ли. Там же конец последней секции, а он должен содержать данные... Это надо думать. Проще по коду разобраться.

++++++Удалить файл лога
* Пока вроде незачем их удалять.
* Удалять надо самые старые файлы лога, если превышен лимит размера лога. Ну и нельзя удалять файлы лога текущей ТранзакцияСолюшена. 
* И хорошо бы тогда удалять файлы лога по границам ТранзакцияСолюшена или СеансЛога.
* 


++++++Поиск последнего файла лога
* Нужно найти последний файл лога - по номеру файла лога и по таймштампу создания из шапки лога.
* Проще всего просто создать список всех файлов лога в каталоге, отсортировать их по имени - оно же одинаковое, кроме номера лога. - а вот и нет - такая сортировка поставит рядом 1 и 10.
* В общем, надо получить список файлов лога, сортированный по номеру лога или по дате. И из него взять последний файл лога.

++++++Получение хронологического списка файлов лога
* Нужно получить все файлы лога в каталоге лога  и отсортировать их по номеру файла лога или по таймштампу из шапки файла лога.
* Сортировать по номеру в имени файла быстрее.
* Сортировать по таймштампу надежнее, если системные часы не переводились. И не стояли из-за севшей батарейки биоса. Хотя там они все же идут, когда комп включен. Так что и это не проблема. Но надо читать каждый файл лога, чтобы получить таймштамп. Это долго.
* Надо убедиться, что номер файла лога  и таймштамп шапки лога не различаются в этом плане надежности определения.

++++++Проверка размера файла лога
* Предельный размер файла лога должен храниться в константе в МенеджерЛога. Его не предполагается изменять в процессе работы движка.
* А) Это независимая функция, которая работает при не открытом файле лога. Она берет имя файла лога и узнает его размер, потом сравнивает его с пределом и возвращает да или нет.
* Б) Это компактная функция-проверка, которая работает при уже открытом файле лога, берет объект потока открытого файла лога, получает его длину, сравнивает с пределом и выдает да или нет.

++++++Извлечение номера файла лога из имени файла лога - устарело
Нужно строку имени файла лога разделить по символу точки.
Последний элемент получившегося списка будет расширением, а предпоследний - номером файла.
Считать элементы он начала будет не правильно, так как НазваниеСолюшена может, в принципе, содержать точку.
Эту строку номера надо конвертировать в число. При этом может возникнуть исключение неправильного формата.
Его надо правильно обработать.
Число нужно вернуть как номер данного файла лога.

++++++Создание имени файла лога - устарело
Надо соединить через точку НазваниеСолюшена, номер файла лога,  расширение файла лога.
Расширение файла лога лучше хранить в настройках Солюшена, или хотя бы в статической переменной менеджера лога. А не прямо в коде каждый раз задавать. Тогда проще будет его изменить, если понадобится.  

++++++Регулирование общего числа файлов лога
* Это необязательная возможность.
* Надо где-то в настройках солюшена хранить допустимый предел количества файлов лога или общий размер всех файлов лога. И если этот размер превышен, удалять самые старые файлы лога.
* Файлы лога хранят информацию, необходимую для отката изменений. Теоретически, с их помощью можно откатить всю систему в начальное состояние. Но если файлы лога удалить, это станет невозможно.
* Нельзя удалять файлы, участвующие в текущей ТранзакцияСолюшена. Возможно, даже все файлы, созданные в текущей СеансЛога.
* Лучше пока это не реализовывать. Но предусмотреть. В шапке файла лога надо хранить таймштамп создания лога. Так как таймштамп из файловой системы ненадежен. Он сбрасывается при копировании файлов.  

 