++ Идентификатор Связи
[template: ШаблонКарточкиГлоссария]
Состояние: [//ДОПОЛНИТЬ]

Уникальный идентификатор, позволяющий однозначно указать связь при различных операциях.
См. ИдентификаторЭлементаСтруктуры.

+++Версии
* todo.глоссарий.форма: Создайте новую страницу для версии описания сущности, добавив к имени "Версия0". Так осуществляется поддержка версий страниц глоссария. 

+++Обязанности
* [//ИдентификаторСвязи/КонтрольИдентификатора]
* [//ИдентификаторСвязи/ПроверитьНеВременныйЭлемент]

+++Сущности предметной области
* todo.глоссарий.форма: Перечислите выявленные сущности предметной области здесь.
* 

+++Соответствующий класс кода
MLinkID
++++Свойства - данные
* ИдентификаторСолюшена
* ИдентификаторСвязиВнутриКонтейнера
++++Методы

+++Дополнительная информация 
ИдентификаторСвязи состоит из ИдентификаторСолюшена и ИдентификаторСвязиВнутриКонтейнера, чтобы [Связь] могла ссылаться на ячейки из другого [Контейнер]а. 
ИдентификаторСолюшена обозначает [Контейнер] и [Солюшен], и используется для обозначения связей из СтороннийСолюшен,  связанных с текущей ячейкой. При доступе к такой связи используется МеханизмКоммуникацииКонтейнеров.

++++Идентификатор связи внутри контейнера
ИдентификаторСвязиВнутриКонтейнера представлен типом int32. Положительные значения обозначают ПостояннаяСвязь, отрицательные значения обозначают ВременнаяСвязь. Значение 0 зарезервировано.
Новые связи получают новый идентификатор, на 1 больше максимального существующего. Временные - соответственно, с минусом. Для единообразия код, определяющий новый идентификатор, унифицирован для временных и постоянных связей.
Поскольку связей больше, чем ячеек, в памяти хранится только значение (8 байт), а не объект класса идентификатора (16 байт). Операции с идентификатором - статические члены класса. 

++++Хранение идентификатора
* В памяти в объектах идентификатор хранится как Int64 - так он занимает меньше места в объекте с учетом расхода на описания полей, и так он быстрее сравнивается при поиске нужного идентификатора. Разборка и сборка частей идентификатора выполняется статическими функциями класса идентификатора.
* В снимках СнимокСтруктуры ИдентификаторЭлементаСтруктуры хранится как Int64.
* В [//БазаДанныхСолюшена] идентификатор хранится двумя полями Int32. Это поскольку запрос, который ищет нелокальные идентификаторы в таблицах [//БазаДанныхСолюшена], не сможет разбить инт64 на инт32. Индексы по идентификаторам теперь должны быть на 2 поля.
    * Но можно запрос сформировать так, чтобы проверять границы пространства контейнера: 
     int min = U64(solutionid, 0);
     int max = U64(solutionid, UINT32.MaxValue);
     ... WHERE (id > min AND id < max) 
* В ФайлСолюшена ИдентификаторЭлементаСтруктуры хранится как MID. Тут надо соблюдать приличия.

++++Для КонцепцияМультиконтейнерность:
В случае, когда связь соединяет две ячейки из разных контейнеров, как назначать идентификатор для связи?
Ранее этой проблемы не было, так как у связи не было идентификатора, и она идентифицировалась по ячейкам и типу связи. 
Теперь идентификатор связи есть, и как его назначать?
todo.концепция.сс: Как назначать идентификатор связи двух ячеек из разных контейнеров?
todo.концепция.сс: Как, теоретически, взаимодействуют между собой контейнеры?

варианты:
А) в каждом контейнере свой экземпляр связи, и свой идентификатор соответственно.
    * а как тогда работать с такими связями?
        * неясно, пока не определено, как вообще работать с ячейками из других контейнеров.
Б) Кто первый создал связь, тот и назначает идентификатор. Остальные пользуются им.
    * Даже можно создать связь между двумя ячейками разных Солюшенов, и хранить ее в третьем Солюшене.
        * И зачем это может потребоваться?
        * * неясно, пока не определено, как вообще работать с ячейками из других контейнеров.    
done.концепция.сс: а зачем вообще-то необходимы идентификаторы связей? Надо выяснить, зачем они понадобились в прошлых версиях концепции.
    * для того, чтобы можно было указать связь как аргумент операции в редакторе командной строки. До этого связь идентифицировалась двумя ячейками и типом связи, что недостаточно однозначно ее определяет. И слишком длинно, чтобы вводить это в командной строке.
    * Возможно, есть и еще польза от идентификаторов связи. Но пока не выявлено.
