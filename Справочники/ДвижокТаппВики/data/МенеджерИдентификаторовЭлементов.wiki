++ Менеджер Идентификаторов Элементов
[template: ШаблонКарточкиГлоссария]
Состояние: [В РАЗРАБОТКЕ]

Управляет выдачей идентификаторов для ячеек или связей.
Абстракция для МенеджерИдентификаторовЯчеек и МенеджерИдентификаторовСвязей.


+++Версии
* todo.глоссарий.форма: Создайте новую страницу для версии описания сущности, добавив к имени "Версия0". Так осуществляется поддержка версий страниц глоссария. 

+++Обязанности
* todo.глоссарий.форма: Перечислите обязанности сущности здесь.
* 

+++Сущности предметной области
* todo.глоссарий.форма: Перечислите выявленные сущности предметной области здесь.
* 

+++Соответствующий класс кода
* MElementIdManager 
++++Свойства - данные
* Максимальный Идентификатор Временной Ячейки или Связи .
* Максимальный Идентификатор Постоянной Ячейки или Связи
++++Методы
+++++ Инициализировать менеджер
Инициализировать счетчики наибольшим ИдентификаторЭлементаСтруктуры в Солюшене.
* Поиск максимального идентификатора элемента занимает много времени.
* [//MElementIdManager].maxXxxElementId поле кэширует идентификатор последнего созданного элемента. При инициализации контейнера поле = 0. При создании нового элемента его идентификатор записывается в этот счетчик.

+++++ Создать новый идентификатор
1)Создается новый идентификатор на основе хранящегося значения счетчика. 
2)Значение счетчика увеличивается. Так как до подтверждения идентификатора еще могут создаваться идентификаторы. 
3)Идентификатор возвращается вызывающему коду.

+++++ Подтвердить идентификатор
??? вроде ничего тут не делается?

+++++ Отменить идентификатор
Если счетчик соответствует идентификатору, то есть, не было выделения других идентификаторов за это время, то счетчик просто откручивается назад.
Если счетчик не соответствует идентификатору, то счетчик сбрасывается и должен проводиться ПоискНовогоИдентификатора.
Это неточно, надо уточнить.

+++Дополнительная информация 
Менеджер хранит два счетчика: для постоянных и временных элементов. Процессы почти одинаковые.

++++Общий ход процесса:
1) Для новой ячейки или связи создается новый идентификатор.
... не относящиеся к этой теме операции с ячейкой
2а) Если создание ячейки или связи прошло успешно, идентификатор подтверждается.
2б) Если создание ячейки или связи отменено, идентификатор отменяется.

todo.концепция.сс: Надо найти лучшее описание менеджера идентификаторов ячеек и связей, или извлечь его из КодДвижка.
todo.концепция.сс: Надо написать более развернутую и понятную диаграмму работы с идентификаторами ячеек и связей.
[//ПЕРЕДЕЛАТЬ] - осовременить к существующему коду.
Рассмотрим на примере идентификатора ячейки. Для связи аналогично.
Поиск максимального идентификатора элемента занимает много времени.
[//MElementIdManager].maxXxxElementId поле кэширует идентификатор последнего созданного элемента. 
При инициализации контейнера поле = 0.
При создании нового элемента его идентификатор записывается в этот кэш.
+++++Удаление Элемента
* При удалении постоянный элемент не удаляется, только помечается удаленным. 
* [НеактивнаяЯчейка] физически удаляется [Оптимизатор]ом, если у нее нет активных связей. Неактивные связи удаляются вместе с удаляемой ячейкой.
* Одиночная НеактивнаяСвязь физически удаляется [Оптимизатор]ом.
* Таким образом, ПостояннаяЯчейка движком не удаляется, поэтому ее ИдентификаторЯчейки не освобождается. Можно ничего не делать.
* При удалении ВременнаяЯчейка, которая не может быть записана в БазаДанныхСолюшена, и уже не существует, ее ИдентификаторЯчейки освобождается. Удаляются также связи с этой ячейкой. В этом случае, создание новой временной ячейки должно проводить ПоискНовогоИдентификатора. 

+++++Поиск нового значения идентификатора
ПоискНовогоИдентификатора проводится редко, поскольку единственный вариант, когда поиск имеет смысл - когда идентификатор удаляемой ячейки совпадает со значением из кеша, то есть удаляется последняя созданная ячейка.
В этом случае, возможно, созданные перед ней ячейки уже удалены, поэтому нужно искать наибольший идентификатор.
Если идентификатор удаляемой ячейки меньше значения кэша, значит, существует ячейка, равная значению кэша, следовательно ничего искать не надо.
Если идентификатор удаляемой ячейки больше значения кеша, это либо ошибка, либо новый идентификатор еще не искали. Можно обнулить кеш, это должно вызвать поиск идентификатора при последующем создании ячейки. 

Поиск нового значения идентификатора для ячейки выполняется функцией getFreeCellId(). Поиск проводится если maxCellId = 0, то есть, при первом использовании после загрузки Контейнера.
Нужно получить максимальный ИдентификаторЯчейки в ТаблицаЯчеекБд, и максимальный ИдентификаторЯчейки в КоллекцияЯчеекКонтейнера - для учета временных ячеек, ведь они не хранятся в таблице. 
Максимальный ИдентификаторЯчейки в КоллекцияЯчеекКонтейнера кэшируется при добавлении ячейки,
в MCellCollection.maxCellId. При первом использовании он = 0, и поиск в КоллекцияЯчеекКонтейнера ведется функцией getMaxID(). При удалении ячейки из КоллекцияЯчеекКонтейнера поле сбрасывается в 0, и проводится новый поиск.

++++Получение наибольшего существующего идентификатора ячейки
При создании ячейки ей нужно присвоить новый идентификатор. Поскольку использование б/у идентификаторов нежелательно, нужно получить наибольший существующий идентификатор ячейки (НСИ).
Новый идентификатор получается как НСИ+1.
При удалении ячеек освободившиеся идентификаторы вновь используются, если они меньше НСИ. Можно бы вообще не использовать эти идентификаторы, адресного пространства достаточно. Это позволило бы явно указывать идентификаторы в коде без проблем. Но пока так. При необходимости можно переделать движок, все необходимые изменения локализованы в описываемом здесь механизме.
Для получения НСИ надо просмотреть весь список ячеек: 
В таблице — для постоянных идентификаторов;
В памяти — для временных идентификаторов.
Этот процесс долгий, и применяется кеширование. В списке ячеек контейнера нужно хранить  НСИ ячеек - для постоянных ячеек и для временных ячеек.
Новый идентификатор получаем из существующего соответственным увеличением числа.
Поиск идентификатора проводится как можно реже. Рассмотрим ключевые точки, в которых он необходим:
–	При старте системы. Первоначально кеш идентификатора = 0, это означает, что необходимо искать НСИ. Поиск идентификатора проводится при требовании его значения.
–	При создании ячейки. Нужно получить НСИ, чтобы произвести идентификатор новой ячейки. Имея кеш НСИ, можно обойтись без поиска.  Здесь надо присвоить кешу новое значение НСИ.
–	При удалении ячейки. Нужно обновить НСИ только если удаляемая ячейка имела НСИ, в противном случае НСИ не изменился, и ничего не надо делать. Нужно проводить полный поиск, чтобы получить действительный НСИ, поскольку предыдущие ячейки тоже могли быть удалены. Поиск проводится при следующем требовании НСИ, для этого кеш = 0.
Первоначально кеш идентификатора = 0, это означает, что необходимо искать НСИ. Если кеш не 0, просто используется его значение. 
Поиск идентификатора проводится при требовании его значения. Для постоянных идентификаторов проводится запрос в таблицу.
 Для временных идентификаторов проводится поиск в памяти перебором элементов. При этом, если в структуре нет временных ячеек, поиск ничего не даст, и новый запрос  НСИ  должен будет проводить новый поиск, при этом будут перебираться постоянные ячейки в памяти. Поэтому поиск НСИ для постоянных и для временных идентификаторов — раздельные операции, выполняющиеся при требовании соответствующего НСИ. При создании первой же временной ячейки ее идентификатор будет записан в кеш, и поиск не будет выполняться..

++++ Получение Нового Идентификатора Ячейки в Тапп2
При создании временной ячейки нужно получить новый идентификатор.
Получается вызовом private int MEngine.S1_intGetMaxCellTempID(): 
В контейнере в поле m_maxTempCellID хранится максимальный идентификатор существующих временных ячеек.
Если это поле = 0, например, сразу после старта контейнера, то 
вызывается функция MCelCollection.S1_getMaxTempCellID(), которая просматривает список ячеек и находит минимальный отрицательный идентификатор ячейки. Это и будет максимальный идентификатор временной ячейки.
Это отрицательное значение записывается в m_maxTempCellID, и возвращается вызывающему коду.
Получив максимальный идентификатор временной ячейки, код вызывает MID.getNewTempId(int maxId), который создает новый идентификатор согласно концепции идентификаторов ячеек. То есть, уменьшает на 1. 
Полученный новый идентификатор проверяется - что он не равен 0 и не превосходит максимально возможного предела. 

При создании постоянной ячейки нужно получить новый идентификатор.
Получается вызовом private int MEngine.S1_intGetMaxCellConstID(): 
В контейнере в поле m_maxConstCellID хранится максимальный идентификатор существующих постоянных ячеек.
Если это поле = 0, например, сразу после старта контейнера, то 
вызывается функция MDbLayer.S1_getMaxCellId(), которая делает запрос в таблицу ячеек и находит максимальный положительный идентификатор ячейки. Это и будет максимальный идентификатор существующей постоянной ячейки.
Это положительное значение записывается в m_maxConstCellID, и возвращается вызывающему коду.
Получив максимальный идентификатор постоянной ячейки, код вызывает MID.getNewConstId(int maxId), который создает новый идентификатор согласно концепции идентификаторов ячеек. То есть, увеличивает на 1. 
Полученный новый идентификатор проверяется - что он не равен 0 и не превосходит допустимого предела.
