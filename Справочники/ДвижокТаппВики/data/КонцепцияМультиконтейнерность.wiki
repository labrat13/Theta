++ Концепция Мультиконтейнерность
[//СБОР МАТЕРИАЛОВ] - собрать материалы

++++Описание концепции
описывает мультиконтейнерность в Тапп.


+++Содержимое
* АдминистраторМногоконтейнернойСистемы - роль.


++++Регистрация солюшенов
В МногоконтейнернаяСистема каждый [Солюшен] должен иметь уникальный ИдентификаторСолюшена, по которому можно отличить [Связь] или [Ячейка] одного контейнера от другого.
Этот идентификатор должен назначаться централизованно, чтобы исключить его дублирование и возможные коллизии.
Предлагается ввести глобальный механизм - РегистраторСолюшенов. Этот механизм будет вести собственную базу данных существующих солюшенов - РеестрСолюшенов. 
И соответственно выдавать новые ИдентификаторСолюшена для создаваемых солюшенов. 
И находить зарегистрированные солюшены по ИдентификаторСолюшена или по НазваниеСолюшена.
Это позволит организовать однотипную коллекцию данных, пригодную к МежконтейнерноеСвязывание и исполнению запросов.

В [Контейнер]е должен работать КлиентРегистратораСолюшенов, который будет обеспечивать работу МеханизмКоммуникацииКонтейнеров и МежконтейнерноеСвязывание. См. СсылкаЯчейкиНаКонтейнер. Этот же КлиентРегистратораСолюшенов будет работать с РегистраторСолюшенов.

Еще возможно потребуются ВерсияСолюшена, чтобы различать две ЭкземплярСолюшена. Одна обычная, а одна - восстановленная из архива для неких временных операций и экспериментов. Или как-то надо обрабатывать эту ситуацию.
todo.концепция.мультиконтейнер: Надо придумать, как различать солюшены, восстановленные из снимков или архивов и обеспечивать их работу при том, что они являются дублями уже существующих солюшенов и связаны с другими солюшенами всей МногоконтейнернаяСистема.
    * вроде никак. Так как ИдентификаторСолюшена используется в ячейкахи связях, его никак нельзя расширить и никак нельзя разрешить существование двух ЭкземплярСолюшена с одинаковым ИдентификаторСолюшена.
    * Надо исключить возможность подключения ЭкземплярСолюшена к МногоконтейнернаяСистема с уже существующим ИдентификаторСолюшена, чтобы не было путаницы.
todo.концепция.мультиконтейнер: Надо придумать название для МногоконтейнернаяСистема.
todo.концепция.мультиконтейнер: Надо описать МногоконтейнернаяСистема и ее функционирование.

++++РегистраторСолюшенов
* При создании [Солюшен]а нужно как-то получить адрес РегистраторСолюшенов, чтобы получить от него новый ИдентификаторСолюшена.
    * Можно искать РегистраторСолюшенов как локальную службу на локальной машине.
    * Можно искать РегистраторСолюшенов как сетевую службу на указанной пользователем машине, по сетевому адресу сервера.
    * todo.концепция.мультиконтейнер: Как можно реализовать РегистраторСолюшенов как сетевую службу, некий сервер?
* Как РегистраторСолюшенов будет отслеживать доступность и состояние солюшенов?
    * Если солюшен через TCP, то в регистре РегистраторСолюшенов есть путь к солюшену, он может послать запрос по этому пути.
    * Если локальный встраиваемый солюшен, то можно проверить что он существует по файловому пути, и можно его запустить в движке и проверить свойства. Или получить свойства из файла проекта.
    * Все это сейчас слишком сложно и непонятно. todo.концепция.мультиконтейнер: Придумать, как РегистраторСолюшенов будет отслеживать состояние зарегистрированных [Солюшен]ов.
* При доступе к ячейке или связи из СтороннийСолюшен ссылка на объект РегистраторСолюшенов должна быть доступна из кода [Движок]а, чтобы можно было получить прокси-объект СтороннийСолюшен для выполнения операций.
    * Объект РегистраторСолюшенов должен быть один на процесс КодДвижка.
    * Объект РегистраторСолюшенов должен предоставлять в КодДвижка прокси-объекты СтороннийСолюшен.
    * Объект РегистраторСолюшенов должен инициализироваться:
        * при запуске Движка перед открытием или созданием [Солюшен]а  
    * Объект РегистраторСолюшенов можно держать в КодДвижка в виде статического свойства [Контейнер]а. Поскольку он один на процесс. Тогда в одном исполняемом процессе нельзя открывать одновременно несколько [Солюшен]ов. Так как глобальные поля классов будут при этом перезаписываться.
        * А что делать, чтобы открывать одновременно два солюшена?
            * Передавать в РегистраторСолюшенов некий идентификатор процесса и [Солюшен]а?
            * А еще нужны меры, чтобы не открыть дважды один и тот же [Солюшен]. 
        * Это получаются две разные ссылки на один и тот же РегистраторСолюшенов. Только в разных областях памяти? 
            * Неизвестно сейчас. Еще есть Домены и Потоки. Может, они как-то разделяют эти ссылки?
            * Тогда в них нельзя держать индивидуальные для [Солюшен]а списки объектов, сообщений, прокси итд. Так как они будут путаться.      
* Тут надо сначала представить себе эту систему из разных [Контейнер]ов:
1) Что они будут делать?
    * Хранить и реструктурировать данные предметных областей, проводить выборки сущностей по запросам Методов.
2) Почему именно разные контейнеры
    * У разных предметных областей разная специфика и разная организация СтруктураСущностей. Лучше их разделить на разные Контейнеры - Солюшены. Потом их можно запустить на независимых машинах и получить быстрое использование данных из разных предметных областей.
3) Они все на одной машине или на разных?
    * Пока на одной машине будут работать контейнеры, на другой - СерверSQLБД. Или даже все на одной машине - лишь бы памяти хватило. А вообще надо бы каждый единовременно используемый Солюшен на отдельной машине и его СерверSQLБД на отдельной машине.
4) Где у меня разные машины? Какая вообще тут конфигурация сети получится?
    * Пока есть только 2 машины, на одной СерверSQLБД, вторая для отладки работы [Движок]а. Для отладки и тестов этого хватит. Для скромного набора информации или ручной работы - тоже достаточно, хватит и одной машины на все. А вот для использования методов, большого объема данных, а тем более, ИИ - недостаточно. Но тут пока нечего придумать.
5) Разве нельзя считать Движок надстройкой над СерверSQLБД? И сделать его еще одним сервером вроде СерверSQLБД?
    * Можно считать надстройкой, можно прицепить сетевой интерфейс и сделать вроде СУБД. 
6) Контейнеры будут использовать другие контейнеры?
    * Да, как продолжение СтруктураСущностей, возможно даже СлужебнаяЧастьСтруктурыСущностей, для работы [Метод]ов, в общем,  как получится. 
7) Могут ли быть циклы в графе контейнеров?
    * Да, может получиться цикл в этом графе контейнеров. Пока я не знаю примеров, где это было бы проблемой.
8) Их предполагается использовать в Интернете?
    * Возможно, потом, когда станет ясно с правами пользователей, многозадачностью и многоязычностью.
9) Как я буду их использовать?  
    * Я намерен добавлять в них сущности некоторой предметной области, изменять их структуру, достраивать и совершенствовать ее.
10) todo.концепция.мультиконтейнер: Ранее предлагались кэширующие контейнеры внутри Солюшена. Что с ними теперь?


+++Материалы
* wiki:///V:/МоиПроекты/SIM/Работать%20здесь/Concept1/Concept1.wiki?page=МультиконтейнерИМногоПользователи - обработан 19.05.2016 20:07
* wiki:///V:/МоиПроекты/SIM/Работать%20здесь/Concept1/Concept1.wiki?page=ЯчейкиМультиконтейнер - обработан 19.05.2016 20:15
* wiki:///V:/МоиПроекты/SIM/Работать%20здесь/Concept1/Concept1.wiki?page=ВАР6_МультиКонтейнер - обработан 19.05.2016 20:16
* [file:///V:/МоиПроекты/SIM/Tapp23Project/Tapp2_25072013/Tapp230/Notes3.txt] - про мультиконтейнерный вариант, есть в прошлой вики - дубликат 19.05.2016 20:17
* [file:///V:/МоиПроекты/SIM/Работать здесь/ДокиТаррНовые.djvu] - наброски про многоконтейнерность итд.

При доступе из текущего [Солюшен]а к ячейке стороннего контейнера в СтороннийСолюшен  используются МеханизмКоммуникацииКонтейнеров.

В МногоконтейнернаяСистема может быть несколько [Контейнер]ов, каждый в своей БД или группе таблиц, структуры контейнеров могут быть взаимосвязаны. Контейнеры могут располагаться на одном или разных компьютерах и связываются через сеть.

Тут получается два способа межконтейнерного взаимодействия: один через сетевой транспорт TCP, с серверами, портами итд. Другой - внутрипроцессный, когда некое приложение использует несколько экземпляров Dll движка, передавая данные через обычную память процесса. Еще можно предложить межпроцессный способ внутри машины, данные передаются через сокеты или пипы. Хотя тут уже удобнее соединиться через TCP на localhost.
todo.концепция.мультиконтейнер: Проработать и разделить варианты межконтейнерного взаимодействия друг от друга, а то они в моих описаниях слиплись, не поймешь, что зачем нужно.

++++Ссылка на контейнер
Ссылка на контейнер в старом Тапп берется из статического поля класса ячейки, одного на все ячейки. Однако в многоконтейнерном варианте (См КонцепцияМультиконтейнерность) такой способ работать не будет - надо будет или хранить ссылку на контейнер в каждой ячейке, или реализовывать сохранение изменений другим способом.

См. СсылкаЯчейкиНаКонтейнер - осмотреть и дополнить обсуждение.

public static MEngine Cell.Container - Container reference - статическая ссылка для экономии памяти. (Поскольку ссылка статическая, она действует для всех ячеек, находящихся в памяти, поэтому в будущей версии, где ячейки принадлежат разным контейнерам, СсылкаЯчейкиНаКонтейнер нужно помещать в экземпляр ячейки. Однако для ячейки из контейнера, располагающегося в другом процессе и соответственно, другом адресном пространстве, эта ссылка бесполезна, и для нее нужно разрабатывать отдельную концепцию работы. Вывод: следующему прототипу нужна концепция работы многоконтейнерной системы.

++++1
Многоконтейнерный вариант  движка предполагает взаимосвязи между несколькими контейнерами. Ячейки одного контейнера могут взаимодействовать с ячейками другого контейнера. Для различения контейнеров им присваивается глобально уникальный ИдентификаторСолюшена. Такой идентификатор назначается централизованно через РегистраторСолюшенов, что обеспечивает отсутствие конфликтов.
В [Солюшен]е может быть только один [Контейнер]. 
ИдентификаторСолюшена однозначно идентифицирует солюшен.

Поскольку ИдентификаторСолюшена широко используется в ячейках и связях, он должен иметь небольшой размер занимаемой памяти. Примем для ИдентификаторСолюшена 32-битное число, что обеспечивает достаточное количество глобально существующих Солюшенов.

todo.концепция.мультиконтейнер: Продумать концепцию регистрации и взаимодействия [Солюшен]ов. Это должен быть эффективный  механизм, стойкий на все мои эксперименты и попытки все запутать и растерять, на всех компьютерах. Эту вот бардакоустойчивость надо специально прорабатывать.

++++Мультиконтейнерность
Из wiki:///V:/МоиПроекты/SIM/Работать%20здесь/Concept1/Concept1.wiki?page=МультиконтейнерИМногоПользователи.

Ячейки в контейнере А могут иметь связи с ячейками контейнера Б.
Это чтобы использовать данные и методы других контейнеров.
Каждый контейнер специализируется на некоторой предметной области.
Другие контейнеры используют его, читая данные и запуская методы для обработки данных, находящихся в контейнере.

Создается некоторый РегистраторСолюшенов, который получает ИдентификаторСолюшена и возвращает АдресСервераСолюшена - сетевой путь и номер порта сервера, на котором контейнер находится. Аналогично DNS.
Можно обойтись без него, тогда адреса серверов хранятся на самих серверах, но так неудобно выдавать новые ИдентификаторСолюшена. Новые ИдентификаторСолюшена для вновь создаваемых Солюшенов должны быть уникальными, это предполагает централизованное управление идентификаторами.

Пример: Контейнер А с ид=7 имеет ячейку а с ид=10, связанную с ячейкой б с ид=12 из контейнера Б с ид=9.
То есть, есть связь А.а - Б.б или (7.10)-(9.12)
Для исполнения какого-то метода или операции с ячейкой нужно получить ячейку б = (9.12) из кода, работающего в контейнере А.
Данные и связи ячейки б должны быть представлены в контейнер А, но не являться частью контейнера А.
То есть, в памяти должна существовать фантомная копия ячейки б.
В идеале код из контейнера А должен работать с любого размера структурой, находящейся в контейнере В, без проблем и ограничений.

[rel://files/s1.JPG]

Выполнение:
Код в контейнере А натыкается на идентификатор ячейки б, не принадлежащей контейнеру А.
Нужно получить эту ячейку для дальнейшего выполнения кода. Сервер А отправляет ИдентификаторСолюшена на РегистраторСолюшенов, и получает ответ с путем к серверу Б, который должен содержать (но не обязательно содержит) искомую ячейку.
Затем сервер А отправляет серверу Б запрос на получение данных ячейки б. 
Сервер Б отвечает, возвращая код ошибки или данные ячейки б.

Контейнер А может иметь ограничения при работе с контейнером Б как пользователь контейнера Б:
(Хотя контейнер не пользователь, он работает для некоторого пользователя и так наследует его права)
- только чтение структуры контейнера Б.
- создание связей между контейнерами А и Б.
- создание ячеек в контейнере Б.
- создание связей внутри контейнера Б.



++++2
Из wiki:///V:/МоиПроекты/SIM/Работать%20здесь/Concept1/Concept1.wiki?page=МультиконтейнерИМногоПользователи.

Из другого контейнера ячейка будет представлена как ячейка в памяти. в таблицу она не записывается. Ее связи тоже представлены только в памяти, кроме тех связей, которые уже существуют в текущем контейнере.
Все операции чтения, записи данных, другие операции переадресуются другому контейнеру через запросы. Ячейки могут также кешироваться в памяти, но если так, то данные, которые в многопользовательской системе будут изменены, надо периодически синхронизировать с их представлениями в КэшКонтейнеровСолюшена.
Или надо будет предусматривать МеханизмБлокировокДанныхКонтейнера подобно строкам таблиц БД. Или какие-то другие варианты.
Можно разрешить писать и читать данные без кеширования - подобно сейчас MCellA, но это будет очень большой траффик между контейнерами. Лучше использовать кеширование в самом объекте - типа MCellB*.
ТипЯчейки не должен меняться - она должна быть того же типа, что и в своем контейнере. Между разными типами ячеек есть различия в функционировании, соответственно могут быть какие-то различия и между функционированиями представлений ячеек в текущем контейнере.
Например, ячейка, которая кешируется в памяти (MCellBds-MCellB), она может кешироваться в памяти и вызывающего контейнера, то есть контейнера А, и она в таком виде будет не всегда согласована с реальной ячейкой в родном контейнере Б. Тогда их надо будет синхронизировать и проверять, чтобы изменения отражались на всех представлениях ячейки.
Этот механизм уже описан в документации по базам данных и кешам.
Таким образом, мы можем передавать ячейки в другие контейнеры.
Но это все надо еще проработать.

Тогда в коде, который выполняет операции с ячейкой, надо предусмотреть перенаправление операций для чужих ячеек через МеханизмКоммуникацииКонтейнеров к другому контейнеру. Это например, проверить ИдентификаторСолюшена в идентификаторе ячейки, и если он не совпадает с идентификатором текущего контейнера (Солюшена), то передавать операцию через сеть на другой контейнер. А если совпадает, то выполнять операцию локально.
Фактически, данные-проперти и операции реализованы через операции.

Такие перенаправления надо вставлять непосредственно в операции ячеек иначе методы, работающие с ячейками, будут работать неправильно - они не различают свои и чужие ячейки.

todo.концепция.мультиконтейнер: Надо сделать КонцепцияИдентификаторовКонтейнеров - начальные значения, создание, использование, хранение, удаление, оптимизация пространства идентификаторов, итд.

Связи вроде сейчас создаются через ячейки. Это значит, что связи фактически создаются внутри контейнера, в котором обе ячейки находятся, а если связываемые ячейки в разных компьютерах, то потребуются специальные меры - эти операции надо продумать.

+++++Доступ к ячейке
Для получения экземпляра ячейки вызывается стандартная функция контейнера. Она ищет ячейку в памяти, если находит, то возвращает ее. (равно своего или чужого контейнера)
Если не находит, то пытается найти ее в таблице. 
Когда в идентификаторе ячейки встречается ИдентификаторСолюшена, отличный от текущего Солюшена, то код сначала должен получить АдресСервераСолюшена - из локального КэшАдресовСолюшенов или из РегистраторСолюшенов. Если адрес получен из РегистраторСолюшенов, он добавляется в КэшАдресовСолюшенов. Затем направляется запрос этому контейнеру, тот отсылает сериализованное представление ячейки, оно принимается, создается объект ячейки в памяти текущего контейнера и возвращается в основной код. 
Минимальные отличия от получения локальной ячейки.
Хотя могут быть разные варианты проблем, и надо это все обдумать.

РегистраторСолюшенов контролирует доступность и параметры СерверСолюшена, управляет их идентификаторами, может запускать процедуры обслуживания СерверСолюшена. 

++++Мультиконтейнерный вариант
Из wiki:///V:/МоиПроекты/SIM/SimWiki/SimWiki.wiki?page=ЗаметкаМультиконтейнерность
На основе БД или ПолныйСнимокСтруктуры.
Один экземпляр СерверСолюшена на базе Движка может рулить одним контейнером.
На одном компьютере можно завести несколько серверов, и связать их содержимое.
В одном процессе можно запустить несколько СерверСолюшена, чтобы работать с несколькими солюшенами / контейнерами. 

Контейнер (обозначим А) предполагается, содержит ячейки, образующие какую-то предметную область, функционально и идейно законченную.
Другие контейнеры (Б) ссылаются на ячейки этого контейнера, реализуя какие-то варианты использования этой предметной области. Соответственно, ячейки этих контейнеров содержат связи с ячейками контейнера А. А ячейки контейнера А должны бы содержать связи с ячейками из других контейнеров.
Если контейнеров немного, то и связей от А к Б немного.
А если какая-то из ячеек А часто используется, например, математические операции, то она будет хранить много связей с контейнерами Б, и эти связи не являются необходимыми для функционирования контейнера А. Эти связи только обозначают степень использования сущности, выраженной ячейкой.
Есть идея не хранить такие связи в ячейке контейнера А, а только в ячейках контейнера Б. Тогда контейнер А и все его ячейки можно объявить как Только-Для-Чтения для пользователей, особенно для публичных пользователей, в результате остальные контейнеры могут читать и пользоваться, но не могут повлиять на работу и содержимое контейнера. Ячейки контейнера Б имеют связи с ячейками контейнера А, и могут запрашивать оттуда нужные данные.

++++ Ячейки Мультиконтейнер
Из wiki:///V:/МоиПроекты/SIM/Работать%20здесь/Concept1/Concept1.wiki?page=ЯчейкиМультиконтейнер.
Ячейки в МногоконтейнернаяСистема.
В МногоконтейнернаяСистема каждый контейнер должен быть в некоторой степени защищен от других.
Например, пользователь А, не имеющий доступа на запись контейнера Б, создает связь с ячейкой контейнера Б.
В контейнере Б эта связь не создается, так как у пользователя А недостаточно прав.
В контейнере А тогда присутствует копия ячейки контейнера Б, у которого есть все связи из контейнера Б, и есть связи контейнера А.
Но изменения в копии не сохраняются в оригинале.
Если два контейнера соединены через локальную сеть или интернет, то они могут пересылать друг другу данные ячеек и связей.
Для синхронизации изменений могут потребоваться соответствующие механизмы. 

++++Новое 22.05.2016 23:50
РегистраторСолюшенов
* При создании солюшена нужно как-то получить адрес регистратора солюшенов, чтобы получить от него  ИдентификаторСолюшена для создаваемого солюшена.
    * Можно искать РегистраторСолюшенов как локальную службу на локальной машине.
    * Можно искать РегистраторСолюшенов как сетевую службу на указанной пользователем машине в сети.
    * todo.концепция.мультиконтейнер: Продумать процесс поиска Регистратора солюшенов для получения нового идентификатора солюшена.
* Как РегистраторСолюшенов будет отслеживать доступность и состояние солюшенов?
    * В его регистре есть путь к солюшену, он может послать запрос по этому пути. Это если используется TCP и сервер солюшена. А если локальный солюшен? Его можно обнаружить только подключив и загрузив в память. Можно только проверить что он существует как совокупность файлов, и может быть запущен для работы с ним. 
    * Все это сейчас слишком сложно. todo.концепция.мультиконтейнер: Продумать процесс поиска Регистратора солюшенов для получения сведений о существующих солюшенах и их состоянии.
* Тут надо сначала представить себе всю эту систему из разных контейнеров: 
    * Что эти контейнеры будут делать?
    * Почему именно разные контейнеры?
    * Они все будут на одной машине или на разных?
    * Где у меня разные машины?
    * Разве нельзя считать солюшены надстройкой над СУБД?
    * Они будут использовать другие солюшены?
    * Могут ли быть циклы в этом графе контейнеров-солюшенов?
    * Их предполагается использовать в Интернете?
    * Как я намерен их использовать, эти раздельные солюшены, объединенные в сеть?
    * добавить вопросы здесь
todo.концепция.мультиконтейнер: надо ответить на вопросы по  сетевой модели солюшенов.

++++Новое 26.11.2016 07:03
* РегистраторСолюшенов следует реализовать как службу windows. Обмен данными через TCP.
* Для получения сведений о свойствах солюшенов использовать ИнтерфейсРегистратораСолюшенов.
* (См. СсылкаЯчейкиНаКонтейнер - взято туда) В коде движка Тапп23 операции с ячейками использовали глобальную ссылку на статический объект текущего контейнера. Это позволяло из любого места кода получить ссылку на контейнер. И все операции можно было вызывать из объекта ячейки. Это делало код очень наглядным, вся работа шла с ячейками, контейнер практически там не использовался.
    * Сейчас можно вместо статической ссылки на текущий контейнер разместить таким же образом некий статический глобальный объект, в который направляются запросы получения контейнера для выполнения операций из кода ячейки или любого другого места кода движка. Этот запрос есть функция, которая возвращает объект запрошенного контейнера по ИдентификаторСолюшена из ячейки или связи.
    * Если запрашивается локальный солюшен, запрос возвращает ссылку на объект локального солюшена.
    * Если запрашивается СтороннийСолюшен, то возвращается ссылка на объект-прокси для этого внешнего солюшена. И через этот прокси выполняются операции в этом внешнем солюшене.
    * Таким образом операции ячеек и связей выглядят прозрачно и в рамках общей концепции.
* При написании кода движка надо учитывать, что теперь отдельно взятая ячейка может быть не в локальном контейнере. А раньше код писался исходя из того что все ячейки находились в локальном контейнере, никаких вариантов в этом плане не могло быть. 
Сами же эти сторонние ячейки (а возможно, и связи) в последующих версиях придется представлять некими классами-представителями, этакими суррогатами, прокси. Они должны внешне быть идентичными локальным ячейкам, но все операции передавать в свой контейнер через Межконтейнерное взаимодействие.
Хотя это как раз является частью КонцепцияМультиконтейнерность, и пока что я это не буду реализовывать. Поскольку не знаю, как все это увязать с остальным.
* Еще СтатистикаСолюшена должна будет указывать число ВнешняяЯчейка и ВнешняяСвязь связей и ячеек. Или ячейки не внешние, только связи? И характер связей, исходящие или входящие? Или характер не нужен?

+++Межконтейнерные связи
Связь, хранящаяся в некотором [Контейнер]е Б, может использовать не только одну, но и обе ячейки [Контейнер]а А. Тогда можно вынести в [Контейнер] Б некоторые сложные или межслойные отношения, а в [Контейнер]е А хранить простые отношения внутри некоторого слоя.
