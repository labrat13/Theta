++ Сборка Аргумент Метода1

Аргумент имеет имя, тип, значение, другие данные.

Строго говоря, аргументы в методе должны быть представлены не списком.
Каждый аргумент метода имеет свое назначение, семантику. 
Аргумент - это местодержатель для сущности, используемой в качестве аргумента.
И он задает требования, которым эта сущность должна удовлетворять.

Хотя точнее, сущности, которые используются в качестве аргумента, должны семантически подходить для этого.
Например, метод ПокормитьСобаку предполагает в качестве аргумента не собаку вообще, а именно конкретную собаку или собаку из некоторого ограниченного множества. 
То есть, собака не просто может быть прицеплена к методу в качестве аргумента, а только эта собака может быть прицеплена к методу в качестве аргумента.
Это обычно не обозначается в методологии программирования, и мало исследовано. Так что в литературе нельзя найти методику для этой проблемы, но можно найти множество случаев, когда это неявно подразумевается. Вообще, много таких нюансов не изучено, и решения подбираются в каждом случае индивидуально, по контексту, с привлечением житейского опыта и человеческого интеллекта. 

+++Представители-обертки
Представители элементов списка - новая сущность в СтруктураСущностей.
Представители являются местодержателями или обертками для элементов-ячеек в списках, графах итд.
Они принимают на себя специфичные связи и операции элементов списка, избавляя от них собственно ячейки-элементы.
Представители связаны с ячейками отношениями представления, и принимают определенный объем операций.
Их можно использовать везде, где надо разделить участие ячейки.
todo.концепция.методы: продумать концепцию и название представителей.
Представители можно предложить использовать для приведения типов - это надо обдумать и прогнать на реальных примерах.

Аргументы - это разновидность оберток. 
Аргументы должны иметь тип, описание, ... для подбора ячеек-данных. 

+++Передача аргументов
Когда создается вызов функции, в него на определенные места прицепляются ячейки данных или функций-колбеков.
Эти ячейки не связаны с алгоритмом. Они в качестве аргументов связаны в списке аргументов вызова функции отношениями последовательности.
Однако если ячейка используется как аргумент в нескольких функциях, она будет иметь несколько связей отношений последовательности от разных списков аргументов, что недопустимо.
Здесь опять же надо выполнять субклассирование или использовать некую сущность, аналогично указателям в Си.
Субклассирование применить нельзя - ячейка нужна как она есть, со всеми ее связями. Однако, добавлять связи ячейке тоже не нужно.
Надо как-то так, чтобы ячейка соединялась с аргументом в списке аргументов некоторой связью-отношением, а уже этот аргумент хранил связи в функции.
При этом операции с аргументом реально выполнялись бы с ячейкой. 
Вот в Си есть операции для указателей и операции для объекта, на который этот указатель указывает.
Тут надо думать.
Мы вводим аргумент функции как сущность, представляющую другую сущность.

Интерпретатор создает алгоритм функции для исполнения, и он должен как-то представить в нем реальные ячейки, переданные в качестве аргументов. 
Так, чтобы они были доступны по всем свойствам и операциям, но были избавлены от связей внутри алгоритма. Такой прозрачный контейнер.

Когда в Си функция возвращает объект - он возвращает его по ссылке. 
Объект создается глобально в динамической памяти, и функция возвращает на него ссылку, то есть, адрес в памяти.
То есть, если в результате исполнения функции будет создана некая ячейка или конструкция ячеек, которую надо будет вернуть в вызывающий алгоритм,
то она не уничтожается после завершения метода.
Если по значению, то надо только скопировать значение.

Функция в Си возвращает результат, она используется в качестве данного. Это данное надо как-то представить в вызывающем алгоритме.
Как константу? Или как оператор присваивания?

Как передавать аргументы? Если по значению - то просто копировать. Передавать по значению имеет смысл только константы 
и простые типы, а по ссылке все остальное.
Функции передаются в функции как? Как это выглядит?
Ячейки передаются либо копиями, либо непосредственно. Но не получать связи с алгоритмом.
Аргумент представляет какую-то ячейку в алгоритме. Хранит связи как аргумент и представляет связи и свойства ячейки.
Вроде указателя на ячейку. Такой представитель можно использовать в списках и подобных конструкциях как местодержатель для элементов списка.

Этот представитель связывается с ячейкой, которую он представляет некоторым отношением - отношением представления. И переводит к ней все операции.
Такой представитель можно поставить в список аргументов, но они должны иметь информацию о типе данных аргумента.
Представитель надо реализовать так, чтобы он работал не только в алгоритме, под управлением интерпретатора, но и как-то в остальной структуре ячеек.
Кстати, надо придумать для него официальное название, если он будет использоваться.
Представитель также вероятно сможет использоваться для приведения типов.

Еще один вариант - уже забыл...


+++1
Вся эта конструкция из ячейки-представителя функции, коллекции аргументов, в коллекции надо разместить аргументы,
чтобы пользователь потом только поприцеплял к ним ячейки реальных аргументов, как в гнезда, не заморачиваясь.
В общем, концепцию аргументов надо создавать.
Все это конечно можно графически в один интуитивно-понятный примитив собрать, но сейчас надо в виде графа, чтобы было понятно при просмотре графовой модели.

Загружаются туда аргументы, а потом, когда аргументы загрузились, они копируются или передаются? Между уровнями исполнения интерпретатора.
Интерпретатор строит алгоритм функции и перекидывает туда данные-аргументы.  
