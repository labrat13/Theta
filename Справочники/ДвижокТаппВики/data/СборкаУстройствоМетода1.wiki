++ Сборка Устройство Метода1



+++Устройство метода
Методы в СтруктураСущностей представлены совокупностью ячеек.
Метод должен включать в себя НазваниеМетода, ОписаниеМетода, АргументМетода, ОписаниеАргументаМетода,  РезультатМетода, ОписаниеРезультатаМетода, АлгоритмМетода.
Одна ячейка является ГоловнаяЯчейкаМетода, представляя собой собственно метод, другие хранят семантику операции, описание аргументов, результата, АлгоритмМетода.
Алгоритм метода может быть описан текстом скрипта (МетодСкрипт), графом ячеек (МетодГраф), или указан путь к коду (МетодИзКода).

Метод строится по образцу абстрактного метода.
Алгоритм может быть один или несколько из подклассов АлгоритмМетода.
АлгоритмГраф - ПотокУправления начинается с него и заканчивается на нем.
ПотокУправления представляет собой граф-дерево с одним началом и одним и более концами.
АлгоритмКод и АлгоритмСкрипт - поле данных содержит соответственно путь к функции и текст скрипта.
Список аргументов метода - содержит обертки-аргументы. 

++++Строение функции
Из  wiki:///V:/МоиПроекты/SIM/Работать%20здесь/Concept1/Concept1.wiki?page=ОписаниеФункций
Функция имеет имя, описание, дату создания и изменения, прочие атрибуты.
Все составные части связаны с их родительскими классами отношениями классификации.

Функция включает в себя:
* Представителя функции - ячейка, представляющая функцию.
* Список аргументов - упорядоченное перечисление аргументов функции.
* Результат - аргумент, представляющий возвращаемое значение, его тип. 
* Алгоритм - граф элементов алгоритма, операторов и данных, связанных отношениями.

Операторы связаны друг с другом отношениями перехода управления.
Цепочка операторов начинается с ячейки Алгоритм и заканчивается ею же.
Цепочки могут разветвляться операторами условных переходов.
Все ветви имеют последним оператором Return, который возвращает результат.
Алгоритм может иметь несколько Return для разных возвращаемых значений.

Данные связаны с операторами отношениями перехода данных.
ТОДО: Присваивание можно было бы реализовать как переход данных, но оно, вероятно, участвует в последовательности управления.
Поэтому присваивание пока реализуется оператором.

Аргументы - это переменные и константы, которые инициализируются вне алгоритма. 
Они имеют связи в алгоритме, и они внесены в список аргументов функции.
Все аргументы - ячейки. 
Передача по ссылке - передаем (привязываем) саму ячейку.
Передача по значению - передаем (привязываем) копию ячейки. ТОДО: Когда нужна копия ячейки? ТОДО: Как создать копию ячейки?

Результат - данные, которые инициализируются в алгоритме и возвращаются как результат функции.
Результат связан с представителем функции для быстрого доступа к результату.
(ТОДО: Подробнее проработать) 

++++Строение метода
Метод очевидно состоит из:
* собственно ячейки метода
* описание семантики для пользователя
* список аргументов (перечень ресурсов, обязательных/необязательных)
* алгоритм
* описание семантики для машины
* область действия (изменяемый элемент)
* начальные условия (для выбора метода)
* конечные условия (для выбора метода)
* история выполнения (архив)
* какие-то еще данные
Минимально необходимые здесь: ячейка-метод, алгоритм, к которому можно прицепить свойство "тип исполнения" (код/скрипт/граф), список аргументов, описание семантики для пользователя. Остальные части можно отнести к семантике для машины, их реализацию отложить пока.

Так, метод будет состоять из ячейки-метода, имя которой является описанием семантики для пользователя, к ней прицеплена ячейка алгоритма, к ней прицеплена ячейка тип исполнения и ячейка-список аргументов. Или ячейка списка аргументов должна быть прицеплена к ячейке метода? 
Если ячейка-алгоритм имеет тип граф, она является коллекцией для графа, состоящего из элементов алгоритма.
Опять же, эти элементы, наверно, должны быть заранее определены хотя бы на уровне абстракций?
Можно предположить, что алгоритм метода является классом, и должен состоять из классов-элементов алгоритма, которые используют классы-данные. Объекты этого класса содержат объекты элементов алгоритма, и используют объекты-данные. То есть, на каждое использование алгоритма создается свой экземпляр этого алгоритма, и можно прицеплять к нему данные по его исполнению.
Тогда класс должен конструировать свои объекты и разрешать (осуществлять) ссылки на используемые алгоритмом ячейки.
Даже можно предложить по графу или скрипту компилировать исполняемый код, и запускать уже его, для ускорения работы.
Поскольку метод имеет сложное строение, потребуется шаблон для создания метода, или конструктор типа. Можно предложить описать тип подобно типам данных, но как тогда быть с МетодОбработчикЯчейки обработчиками ячеек - они ведь тоже методы. Получается, чтобы создать метод, нужен метод. Варианты: 
- сделать протометод специально для МетодОбработчикЯчейки обработчиков, как часть движка
- сделать полноценную версию метода как часть архитектуры системы. Это потребует создания остальной минимально необходимой пирамиды, и система уже не будет такой универсальной, как представлялось.

++++Слои абстракций для представления устройства функции

Элементы функции связаны друг с другом отношениями.
Слои абстракции разделяют слои отношений.
Функция на 2 уровне представляет функцию как сущность. 
Функция на 3 уровне представляет использование этой функции в каком-то алгоритме, где она имеет множество связей.


1) Классы элементов функции, не связанные друг с другом.
-элементы заголовка функции:
-Класс Функция
-Класс Алгоритм
-Класс Список аргументов или класс Список - определиться.
-элементы данных:
-Класс Переменная
-Класс Константа
-...
-элементы операторов:
-Begin
-Return
-...

2)Субклассы элементов функций, собранные в функцию. 
Эта конструкция описывает устройство функции, и считается собственно функцией.
Алгоритм функции может содержать вызовы других функций и рекурсивные вызовы самой этой функции.
Эти вызовы представляют собой субклассы функции (3 уровень), без алгоритма,
их задача - представлять функцию в алгоритме - хранить связи с алгоритмом.
Операторы и данные представлены субклассами, которые хранят связи алгоритма.
Константы на этом уровне получают свои значения.

3)Субкласс функции, повторяющий ее устройство, и выполняющий реальную работу.
Этот субкласс создается на время исполнения функции, и разрушается после исполнения.
Этот субкласс может вовсе не существовать, а симулироваться интерпретатором.
Существуют вызовы функций из кода других функций, алгоритм если и строится, то одноразовый.

+++++Исполнение функции в слоях
Функция запускается либо событием (использует функцию со 2 уровня), либо из вызывающей функции (вызывает функцию с 3 уровня).
При вызове функции событием запускается интерпретатор, который будет исполнять функцию.

Функции предоставляются аргументы согласно списка аргументов функции.

Функции на 2 уровне содержат в алгоритме функции 3 уровня в виде заголовка, без тела алгоритма.
Заголовок функции хранит связи - в ход и выход управления, вход аргументов, выход результата.

Алгоритм 3 уровня создается интерпретатором при выполнении функции. 
Константы копируются со 2 уровня вместе со значением.
Интерпретатор откладывает текущий алгоритм, создает алгоритм по образцу функции 2 уровня, исполняет его,
получает значение и возвращает его в предыдущий алгоритм. 
Затем алгоритм 3 уровня уничтожается.

То есть интерпретатор действует аналогично исполняемому коду.

Рекурсивные функции вводят в рекурсию интерпретатор. 
Связи с глобальными данными, существующие внутри алгоритма функции, не видны в алгоритме функции 2 уровня
Каждая функция производит изменения, для которых надо иметь возможность просмотреть историю или полностью откатить средствами системы.

Интерпретатор может не создавать алгоритм 3 уровня, а компилировать его в исполняемый код, для ускорения работы.
Интерпретатор может интерпретировать алгоритм 2 уровня, это удобно для отладки.



