++ КонцепцияВ1

Это устаревшая версия концепции, в ней не стоит проводить переделки, принятые в остальной документации.

Functionality wiki

Концепция 1

Общее описание
Система предназначена для создания, функционирования и обслуживания структуры, состоящей из данных и операций (методов). Система ведет [Лог]и операций, оптимизирует структуру, позволяет создавать, добавлять, читать, записывать и удалять файловые резурсы, создавать снимки структуры для архивирования или экспорта.


Пользователь
Пользователь работает с проектом. Пользователь может просматривать, создавать и изменять структуру системы, создавать и удалять проекты, просматривать их свойства.


Проект
Проект представляет собой каталог, размещенный в доступном пользователю месте на диске.
Проект включает в себя файл проекта и каталоги для [Лог]а, снимков, ресурсов, сборок кода методов.
Проект сопоставлен с базой данных проекта, с контейнером, в котором работает структура.
В целом, проект вместе с БазаДанныхСолюшена и движком, образует функциональную единицу, сервер системы. 
Из нескольких серверов можно образовать кластер - несколько структур, связанных между собой через локальную сеть.



Структура
Структура системы состоит из контейнера, ячеек и связей.
Структура системы хранится в БазаДанныхСолюшена, которая размещается на СерверSQLБД. СерверSQLБД может быть локальным или удаленным - это не имеет значения.
Сущности базы предполагаются как данные и методы. Сложные сущности представляются совокупностью связанных между собой простых сущностей-ячеек.
Вся база состоит из ячеек, представляющих собой сущности, и связей между ячейками.
Ячейки и связи обобщенно называются элементами базы.
Каждому элементу соответствует строка в таблице и представление в памяти.
Представления элементов могут использоваться в двух вариантах:
-полностью загружаться в память, образуя цельное связное представление участка графа, что ускоряет выполнение операций, но увеличивает риск несогласованности базы при некорректном поведении.
-использоваться как ручки к строкам таблицы, содержащим соответствующие данные элементов. В этом случае база всегда в согласованном состоянии, но работает медленнее.
Свойства, типы и другие характеристики элементов являются самостоятельными сущностями, и также представлены в виде ячеек. Чтобы ввести новый тип, нужно как-то вписать его в существующую систему. Поскольку первоначально никаких сущностей в базе нет, ячейкам назначается тип по умолчанию (в разработке). 
Движок предоставляет набор операций, с помощью которого выполняются базовые операции с элементами. Из этого набора пользователь создает специфические операции сущностей, названные методами. Контроль структуры базы выполняется пользователем или автоматическим [Оптимизатор]ом. 

Контейнер
Контейнер представляет собой среду для функционирования и обслуживания структуры.
Ячейка представляет минимальную единицу структуры. Ячейка хранит двоичные данные, которые интерпретируются в зависимости от ее типа. Ячейка может быть связана с другими ячейками при помощи связей.
Контейнер имеет идентификатор, по которому его можно найти.



Ячейка
Ячейка имеет один общий список для всех связей (чтобы избежать проблем с двунаправленными связями - в каком списке их искать).
Ячейка может быть связана с методами. Методы могут выполнять специфическую обработку операций ячейки - переопределять операции для ячейки. Движок вызывает МетодОбработчикЯчейки или выполняет собственный код.
Ячейка имеет составной идентификатор, состоящий из ИдентификаторКонтейнера и ИдентификаторЯчейкиВнутриКонтейнера. ИдентификаторКонтейнера обозначает контейнер и используется для обозначения ячеек из другого контейнера, связанных с текущей ячейкой. При доступе к такой ячейке используются механизм коммуникации между контейнерами.
Поскольку идентификатор ячейки занимает место в связях, и механизм коммуникации контейнеров не разработан, в первой версии нет ИдентификаторКонтейнера в ячейке. Все ячейки принадлежат контейнеру.
Ячейки представляют сущности базы. Ячейки, представляющие данные, могут иметь связанные с ними методы для выполнения каких-либо операций. 
Каждый элемент (ячейка, метод или связь) имеет состояния/обозначения, в зависимости от которых варьируется его использование. Эти состояния представляют собой самостоятельные сущности, и реализуются в системе как ячейки. Для каждого состояния можно определить МетодОбработчикЯчейки, реализующие индивидуальные аспекты поведения для соответствующего состояния ячейки. Таким образом, поведение ячейки определяется обработчиками ячеек, обозначающих состояния этой ячейки. Короче, ячейка наследует [МетодОбработчикЯчейки]и ее над-ячеек. С возможностью их заменить собственными или сделать недоступными. Чтобы добавить в систему новое состояние, надо создать ячейку, олицетворяющую это состояние, и организовать для нее некоторые вещи. После этого можно прицеплять эту ячейку-состояние к нужным ячейкам. Или использовать выделенное поле в ячейке, записать в него идентификатор ячейки-состояния, если связи создавать неудобно. Нежелательно создавать поле в ячейке, это снижает универсальность системы.
Ячейка имеет уникальный идентификатор и символьное имя. Идентификаторы введены поскольку каждая ячейка хранится отдельно от других. Идентификатор для новой ячейки определяется как максимальный существующий идентификатор ячейки + 1. Имя ячейки может быть не уникальным. Поиск по имени возвращает список ячеек.
Каждой ячейке могут быть сопоставлены методы. Ячейка может импортировать методы связанной с ним над-ячейки, в зависимости от типа связи. Ячейка может подменять собственными или запрещать импортированные методы. Запрещать можно с помощью состояния связи с методом. Подменять методы можно по имени, которое играет роль семантического слота. (в разработке)
Ячейка, представленная в памяти приложения, является clr-классом, осуществляющим операции. Однако, код выполняет только базовые низкоуровневые операции, а для операций ячейки вызываются сопоставленные ей методы.
Каждая ячейка (в зависимости от типа связи) может экспортировать в под-ячейки часть своих методов. Таким образом, Б-ячейка "Тип ячейки", которая обозначает тип А-ячейки, экспортирует методы, специфичные для А-ячеек данного типа. (в разработке)
Временная ячейка не записывается в БазаДанныхСолюшена при создании, она хранится в памяти.
Ее связи хранятся в памяти, ячейка записывается специальным вызовом в нужный момент.

Идентификатор ячейки
Идентификатор ячейки представлен типом int. Положительные значения обозначают постоянные ячейки, отрицательные значения обозначают временные ячейки. Значение 0 зарезервировано.
Новые ячейки получают новый идентификатор, на 1 больше максимального существующего. Временные - соответственно, с минусом. Для единообразия код, определяющий новый идентификатор, унифицирован для временных и постоянных ячеек.
Поскольку идентификатор ячейки много используется в связях, а связей больше, чем ячеек, в памяти хранится только значение (4 байта), а не объект класса идентификатора (16 байт). Операции с идентификатором - статические члены класса. 
В следующей версии движка планируется ввести в идентификатор ячейки еще ИдентификаторКонтейнера, чтобы ячейка могла ссылаться на ячейки из другого контейнера. 


Связь
Связь соединяет две ячейки как FromUp..ToDown. Связь имеет тип, определяющий интерпретацию связи.
Связи между ячейками двусторонние. В памяти каждая ячейка содержит ссылку на общий экземпляр связи. Кроме списков связей ячеек, связь содержится также в общем списке связей контейнера.
В таблице связей в БазаДанныхСолюшена каждой связи соответствует одна запись. В представление связи в памяти входят идентификаторы связанных ячеек, состояние связи, тип связи, флаг удаления, ссылки на ячейки, находящиеся в памяти. Если ячейка не загружена в память, ссылка = null.
Все ячейки могут связываться друг с другом без ограничений. Проверка правильности структуры осуществляется [Оптимизатор]ом и оболочкой пользователя. 
Тип Нисходящая или Восходящая можно вычислить для каждой ячейки вызовом функции. В самой связи он не хранится.

Список связей контейнера
Список связей контейнера хранит все связи загруженных в память ячеек в одном общем списке.
Список связей контейнера в текущей реализации не содержит индексов, но они могут быть добавлены позже. Поэтому глобальные операции поиска связи реализованы здесь. Сейчас они должны использовать списки связей ячеек, если известны их идентификаторы.

Список ячеек контейнера
Список ячеек контейнера хранит все загруженные в память ячейки. Список реализован как словарь, что обеспечивает быстрый поиск ячейки, но медленное добавление (примерно в три раза медленнее, чем список). Также на этот список возлагаются функции поиска ячеек по шаблону, поиска наибольших существующих идентификаторов постоянных и временных ячеек (одновременно, все равно все ячейки перебирать). 

Методы
Методы могут быть реализованы в трех вариантах:
- CLR-код, вызываемый из внешней сборки.
- текст скрипта, выполняемый интерпретатором
- граф алгоритма.

Методы состоят из нескольких ячеек.
Метод представляет собой ячейку-класс, описывающую алгоритм и связанную с этим алгоритмом. Объекты этого класса являются реализациями алгоритма, связанными с конкретными объектами-данными.
Алгоритм представляет собой граф классов-элементов алгоритма, каждый из которых связан с ячейкой-методом.
Каждая реализация метода состоит из объектов-элементов алгоритма. Реализация создается классом метода, и может накапливать данные о своих исполнениях.(в разработке)



Лог
Система ведет [Лог], в котором отражаются события, операции и состояния элементов. [Лог] пригоден для автоматического анализа и может использоваться для отката изменений, анализа происходящих в системе процессов, отладки методов. Записи в [Лог] разделены на классы, можно записывать только выбранные классы записей, регулируя таким образом детализацию [Лог]а.
 [Лог]реализован как последовательность записей о событиях. 
Каждая запись содержит таймштапм, код события, текстовое описание, состояние элементов, участвующих в событии.



Снимок
Снимок представляет собой полную копию структуры, сериализованную в файл. Сериализация в двоичный файл для резервного копирования или экспорта. Снимок может быть десериализован обратно в структуру. 
Структура может быть сериализована частично, образуя файл ресурса. Этот файл будет в таком случае хранить редко используемые части структуры, которые можно загружать лишь при необходимости.
Структура может быть сериализована в текстовый или html-файл для анализа пользователем.

Ресурс
Ресурсы представляют собой файлы, привязанные к элементам структуры. Это могут быть внешние файлы, необходимые пользователю, или созданные самой системой. Файлы хранятся в каталоге ресурсов проекта, в подкаталогах. Каждый каталог может содержать не более ХЗ файлов.
Система может создавать, искать, открывать, читать, писать, закрывать, удалять файлы ресурсов.


Оптимизатор
Поскольку при работе системы получаются пробелы в использовании пространства идентификаторов, [Оптимизатор] может производить дефрагментацию этого пространства, заменяя идентификаторы в ячейках, методах и связях для тех ячеек, которые не имеют связей вне обслуживаемого сейчас контейнера. Нужно полностью заменить все существующие идентификаторы ячейки. Поскольку МетодИзКода не поддается такой модификации, нужно соблюдать правило - в этих методах получать ячейки только по имени. Если это возможно.



Начальное состояние (в разработке) 
В первоначальной системе не существует никаких сущностей.
Нет типов данных, нет типов ячеек, типов связей, ...
Для создаваемых элементов в полях используется дефолтовый идентификатор типа. Этот идентификатор ничего не предоставляет ячейке.
Пользователь создает типы ячеек, типы данных, типы состояний, ...
Определяет операции для них, предусмотренные правилами движка и правилами проектируемой системы.
Например, чтобы добавить в систему тип данных "строка", нужно создать ячейку-сущность, и определить для нее методы, осуществляющие работу с данными этого типа. Для конверсии данных между памятью и таблицей, нужны функции-конверторы. Для поиска могут потребоваться специальные функции, и так далее. 
После того, как все необходимые элементы созданы, можно использовать новый тип данных в ячейках. Желательно структурировать элементы, чтобы организовать их представление пользователю, поиск, замену, и так далее.
Можно предположить, что в базе должны существовать сущности:
-служебный класс, имеющий специальное назначение
- класс

- служебный объект класса, имеющий специальное назначение

- объект класса
- метод
- экземпляр метода

- связь между ячейками

- тип связи


