++ Сборка Виды Методов1

+++Виды методов
Методы могут быть реализованы в трех вариантах:
* МетодИзКода - CLR-код, вызываемый из внешней СборкаКодаМетодов.
* МетодСкрипт - текст скрипта, выполняемый интерпретатором
* МетодГраф - граф алгоритма.
Возможно, потребуются также модифицируемые, перекрываемые МетодОбработчикЯчейки обработчики операций.

++++МетодГраф
* МетодГраф содержит ячейки, обозначающие элементы алгоритма, этот граф исполняется интерпретатором или через МетодОбработчикЯчейки обработчики ячеек — это выбор пользователя. МетодГраф удобен для анализа и редактирования машиной или человеком.
* Методы состоят из нескольких ячеек.
* Метод представляет собой ячейку-класс, описывающую алгоритм и связанную с этим алгоритмом. Объекты этого класса являются 	реализациями алгоритма, связанными с конкретными объектами-данными.
* Алгоритм представляет собой граф классов-элементов алгоритма, каждый из которых связан с ячейкой-методом.
Каждая реализация метода состоит из объектов-элементов алгоритма. Реализация создается классом метода, и может накапливать данные о своих исполнениях.(в разработке)
* См. [file:///V:/МоиПроекты/SIM/Работать здесь/OldWikis/OldDocs/Метод-граф.doc] - перечень и описание блоков алгоритма, их графические элементы. Недоделано.   
* Элементы графа алгоритма представляют собой ячейки, из которых собраны конструкции алгоритма.
Ячейки являются членами класса «Элементы алгоритма» и сами являются классами. Граф метода собирается из объектов этих классов. Однако этот граф не выполняет код, а используется как образец для создания локальных временных копий алгоритма, которые собственно выполняются.
Ячейки имеют конструкторы/деструкторы для создания своих объектов, а также МетодОбработчикЯчейки обработчик исполнения, который собственно выполняет работу элемента. Такой обработчик можно и не использовать, в этом случае алгоритм просто описывается для интерпретатора.
* Сейчас описание элементов в разработке. Каждый элемент должен быть описан: перечислены входы, выходы потока исполнения, входные и выходные ресурсы, нарисована структура ячеек элемента и описаны их функции, описаны МетодОбработчикЯчейки обработчики и их функциональность. 
* Проект Math как прототип диаграммы алгоритма: Смотреть файл [file:///V:/МоиПроекты/SIM/Работать здесь/OldWikis/MathProjectWiki.chm]

+++++О алгоритме метода-графа
Из wiki:///V:/МоиПроекты/SIM/Работать%20здесь/Concept1/Concept1.wiki?page=ЗаметкиПофункциямА, 
wiki:///V:/МоиПроекты/SIM/Работать%20здесь/Concept1/Concept1.wiki?page=ЗаметкиПоФункциям 
Когда пользователь намерен добавить вызов функции в код, он должен создать вызов этой функции как объект функции.
То есть, создать заголовочную часть - ячейку, представляющую функцию, ячейку списка аргументов, ячейки, представляющие аргументы.
И, разумеется, связи между ними.
Затем к этому вызову функции прицепляются связи с остальными частями алгоритма.

Аргументы представлены ячейками. Ячейки имеют типы (классы) данных.
Типы данных это строка, логический, целое число, нецелое число.
Эти классы данных потом подразделяются на константы и переменные. Эти классы (их объекты) используются для построения алгоритма функции.
Когда мы создаем вызов функции, в заголовке функции в качестве ячеек-аргументов используются классы,
а при исполнении функции вместо них подставляются уже реальные аргументы.

Копирование аргументов удобно в том плане, что данные защищены от непредусмотренных изменений вследствие ошибок в алгоритме.
Копирование неприемлемо, если в коде используются связи ячеек.
Можно объявить аргумент константой, тогда интерпретатор при отладке/исполнении алгоритма обнаружит запись в константу и сообщит об ошибке.

Классы операторов такие как разрабатывались в проекте MeraMath. В алгоритме применяются субклассы операторов, они и обеспечивают работу алгоритма.
Чтобы при создании вызова функции не перепутать порядок аргументов итд, необходимо иметь метод, который по заголовку функции конструирует вызов функции.
Этот вызов помещается в некоторое определенное пользователем удобное место, 
из которого пользователь этот вызов достает и прицепляет к конструируемому алгоритму. 
К самой функции будет привязано связями классификации несколько/много таких вызовов, найти среди них только что созданный трудно.
Такой метод можно поместить в суперкласс функции, чтобы был стандартным для всех функций, как и метод запуска функции. 
То есть, все функции имеют общий суперкласс, который определяет устройство функций.
Вызову присваивается стандартное имя вроде ИмяФункции_Объект.

Кстати, сейчас проектируются функции по образцу исполняемого кода. В системе могут быть возможны и другие реализации, но пока они неизвестны.

Кроме МетодГраф, есть МетодИзКода и МетодСкрипт. Функция может хранить любой из них или даже все вместе (хотя это бессмысленно).
МетодГраф визуально представляет алгоритм и удобен для автоматического изменения алгоритма. 
Его удобно использовать при отладке алгоритма. АлгоритмГраф можно транслировать в АлгоритмКод.

++++МетодИзКода
* Движок предоставляет функцию исполнения методов-из-кода. Функция принимает комплект аргументов и путь к коду, проверяет аргументы, исполняет код, возвращает результат вызывающему коду. 
* Аргументами могут быть ячейки или данные любых типов, согласно прототипу операции. 
* Аргументы должны быть описаны в структуре ячеек, описывающих метод. Хотя это не обязательно, метод можно запустить и без такого описания. 
* Из кода извлекается прототип метода — информация об аргументах. Если типы аргументов от кода и от ячеек не совпадают с фактическими, выдается ошибка.
* Соответственно, описание метода должно совпадать с прототипом метода. 
* Можно предположить функции построения прототипа по описанию (для вновь создаваемых методов) и построения описания по прототипу — для добавляемых методов.
* МетодИзКода для исполнения загружает сборку. 
* Как сборка выгружается — в документации CLR описано, что вместе с завершением домена. Поэтому для выполнения сборок методов нужно создавать отдельный временный дополнительный домен, пото загружать в него сборку, исполнять код, потом выгружать этот временный домен. Но этот вопрос надо прорабатывать на небольшом отдельном тестовом приложении.

* Вместо ячейки Алгоритм будет ячейка ДвоичныйАлгоритм, содержащая путь к функции в сборке.
Это как в тапп2.
* МетодИзКода применяется для небольших простых и надежных операций, или для операций с большой сложностью алгоритма, требующих неоправданно большого количества ячеек для его представления.
* Например, это операции со строками или числами, которые образуют прикладной инструментарий.
* Они не изменяются и должны быть быстрыми. 
* Поскольку все Изменения в структуре записываются в [Лог], можно полностью откатить произведенные любой операцией изменения.
* Поскольку исполняемый код не контролируется интерпретатором, его трудно отлаживать и нельзя анализировать устройство.
* Код выбрасывает исключения, и интерпретатор их перехватывает для отката изменений. 
* Но если код содержт неявные ошибки в алгоритме, они так и останутся незамеченными - из-за большого размера системы.
* Код должны быть максимально надежными.
* Не позволяет использовать глобальные переменные, только аргументы.

++++МетодСкрипт
* МетодСкрипт содержит код на некотором языке, который должен как-то исполняться.
* Метод содержит поле для текста скрипта. 
    * Если поле пути к коду содержит путь к функции в сборке, то метод вызывает CLR-код. 
    * Если нет, проверяется поле текста скрипта. 
    * Если оно не пустое, текст отправляется интерпретатору, если пустое - это абстрактный метод или ошибка. 
    * Абстрактный метод не содержит кода, используется для организации вызова конкретного метода. Информация для поиска содержится в списке КТА метода.
* вместо ячейки Алгоритм будет ячейка СкриптовыйАлгоритм, содержащая текст скрипта.
* Исполняется [Интерпретатор]ом. Удобно использовать для изменения СтруктураСущностей.
* Можно использовать глобальные данные, но это использование неочевидно в СтруктураСущностей.

+++Абстрактный метод
Метод может быть абстрактным, не содержать кода, только обеспечивать выбор подходящего метода в иерархии абстракций. Это как класс для методов. Таким образом, вместе с иерархией данных, это обеспечивает выполнение операции на всех уровнях абстракции. Это упрощает контроль и отладку абстрактных методов.

Это класс, представляющий абстрактное устройство метода. По образцу этого класса строятся все методы.
Методы являются субклассами для этого класса метода.

++++Строение абстрактного метода
* Ячейка, представляющая метод - ГоловнаяЯчейкаМетода.
* Ячейка, представляющая АлгоритмМетода (суперкласс для АлгоритмГраф, АлгоритмСкрипт, АлгоритмКод. В структуре метода может быть один или несколько разных таких классов)
todo.концепция.методы: как обозначить такое условие - минимум один, или более, уникальных наследников?
* Ячейка, представляющая список аргументов. Является подклассом класса односвязных списков. Список состоит из представителя списка, он же начало и конец списка, и соединенных связями ячеек - представителей элементов списка.

todo.концепция.методы: как обозначить такое условие - ноль и более элементов списка?
todo.концепция.методы: как вообще обозначать условия для устройства частей структуры?

