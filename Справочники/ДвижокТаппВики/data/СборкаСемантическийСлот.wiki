++ Сборка Семантический Слот

++++семантический слот и переопределение методов
Из [file:///V:/МоиПроекты/SIM/Работать здесь/методыТаппНовые.doc]
Методы и их наследование – переопределение.
- ячейка наследует методы от ячейки типа.
- ячейка наследует методы от ячейки типа данных.
- …

-ячейка переопределяет некоторые наследуемые методы.
-ячейка запрещает некоторые наследуемые методы.
А что есть запрещенный метод? Он есть, но его нельзя использовать. Либо его нет и не должно быть.

Ячейка типа ячейки  предоставляет методы для работы с ячейкой этого типа. То есть вроде класса в Си.
Ячейка типа данных предоставляет методы для работы с данными ячейки. То есть, тоже вроде класса.
Это как?
Пример: ДатаВремя.
Ячейка типа ячейки предоставляет операции для работы с датой.
Ячейка типа данных предоставляет операции для работы с Int64 числом тиков, которые реально хранятся в ячейке ДатаВремя.  

+++++Семантический слот
Сущности имеют операции. Набор операций определяется смыслом сущности. 
Предполагается концепция семантических слотов, при которой сущность в соответствии со своим смыслом имеет некоторый набор семантических слотов, которые подразумевают методы, реализующие эти операции.
Имя операции является семантическим слотом, метод вызывается по имени.
Слоты наследуются из надклассов, методы и МетодОбработчикЯчейки обработчики наследуются или переопределяются.
Поскольку сущность представлен ячейкой, ячейка должна быть связана  с методами, реализующими операции. Например конструктор объекта класса, создание связи некоторого типа, удаление связи, деструктор объекта, операции класса. 
Предлагается семантический слот описывать группой ячеек, которая содержит информацию о операции, аргументах, результате. Ячейку семантического слота использовать как тип связи. Связью такого типа соединять ячейку-сущность и ячейку-обработчик.
Ячейка-обработчик содержит ссылку на код или сам код.
(Данная концепция неудобна тем, что метод (по идее) должен содержать все описание при себе, а здесь оно хранится в описании слота, отдельно от кода. С другой стороны, если обработчик будет содержать все описание он будет громоздким, а его вызов — сложным. Надо придумать что-то единообразное и красивое.)
Таким образом, сущность будет иметь обработчики, описываемые семантическими слотами - типами связей сущности.
Семантические слоты будут типами связей. Нетиповые обработчики сущности будут находиться в том же семантическом слоте, перекрывая унаследованные обработчики. Унаследованные обработчики будут импортироваться из иерархии, а не храниться в сущности.
Однако этот подход неудобен если тип связи (в общей концепции) определяет, какой способ должен использоваться для ее создания/удаления. Хотя можно на семантический слот навесить эту нагрузку, как и на остальные типы связей. 
В общем, тут надо концепцию разрабатывать.


+++++Концепция семантического слота.

Ячейка связана с методами. Ячейка обозначает связь с методом, выполняющим некоторую операцию, семантическим слотом. То есть,
А) связью определенного типа, соответствующую функции.
Б) связью типа СемантическийСлот с ячейкой, обозначающей семантический слот (как тогда прицеплять метод?)

Вариант а) выглядит проще. Тип связи обозначает семантический слот. Конечная ячейка связи – метод, который реализует семантический слот. Если слот запрещен, метод = Запрещено. Если слот неизвестен – нет метода – то конечный метод в связи  = Неизвестно.
А если метод импортируется, то конечный метод какой?

То есть, если ячейка не имеет связи семантического слота, то эта связь берется из ячейки типа, то есть, надячейки, или вернее от всех этих надячеек по иерархии.
Эту концепцию надо дорабатывать.

Вариант а) предполагает просмотр всех ячеек связанных с текущей ячейкой, для сбора методов. Это может быть долго. Надо просмотреть все ячейки иерархии и определить, какие методы наследовать.

Вариант б) предполагает, что каждая ячейка содержит свой комплект связей с методами. Это значит, очень много связей будет в структуре.

Можно предложить вариант с):
Ячейки-объекты содержат объявления семантических слотов. Не содержат связи с методами. Методы экспортируются от ячейки типа, которая будет играть роль класса.
Ячейка типа содержит все связи с методами, которые будут экспортироваться ячейкам-объектам.

Методы перекрываются при помощи концепции семантического слота, то есть, по имени.

Ячейка – объект может перекрыть какой-то метод созданием связи с методом, занимающим соответствующий семантический слот.

Ячейка может запретить слот метода, создав связь с специальным объектом Запрещено в этом слоте.

Таким образом, получаем, что число связей ячейки зависит от концепции системы сущностей.

Концепцию семантических слотов надо еще обдумать и придумать как ее реализовать.

++++Семантический слот
* как подменять методы в ячейках? Можно по имени. Имя метода является семантическим слотом, метод вызывается по имени. Можно установить связь с другим методом того же имени, поэтому при вызове операции будет вызываться новый метод. Метод можно запретить с помощью состояния связи с этим методом.
Выводы:
* Методы должны вызываться только по имени.
* Импорт методов из других ячеек надо продумать 
* Нужно разработать концепцию семантических слотов для ячейки
* Методы можно организовать в классы по семантике, и вызывать не конкретный метод, а его класс. Тогда нужный метод будет найден по связям с ячейкой или подобран автоматически, если такой связи нет. Собственно, класс метода упрощенно является семантическим слотом, но этот механизм позволяет лучшую универсальность при большей сложности.


Семантический слот как тип связи между ячейкой и методом.
Семслот соединяет ячейку данных и обработчик связью специального типа.
Слоты наследуются от классов. Методы/обработчики наследуются и переопределяются.
Сем слот описывает операцию,аргументы и результат. Т.о. метод-обработчик семантического слота может хранить только код или ссылку на код.

Если допустить, что все методы имеют одинаковую структуру, то МетодИзКода может в качестве алгоритма хранить блок вызова кода. См алгоритм МетодГраф, блоки.

Аналог foreach - это процедура, выполняемая для каждого элемента коллекции. процедура может содержать общие переменные, то есть контекст групповой операции.

Надо как-то сделать вызов метода-кода без прицепления к ячейке, в рамках общей концепции. Сейчас предполагается, что метод обозначаетсся специальным типом ячейки / типом данных ячейки, но это уже входит в ПользовательскаяКонцепцияСолюшена.

Нужна концепция параллельного и последовательного набора элементов - массив и список

