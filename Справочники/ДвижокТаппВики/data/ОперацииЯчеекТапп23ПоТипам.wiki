++ Операции Ячеек Тапп23 По Типам
[template: ШаблонКарточкиГлоссария]
Состояние: [В РАЗРАБОТКЕ]


+++Операции ячеек по типам 

rel://files/celltable.png

Сокращения:
id – ячейка не загружена в память. Есть только ее идентификатор, который можно использовать для операций  загруженной в память ячейки с незагруженной. Например чтение или создание связей.
СОЯ — создание объекта ячейки в памяти. 
УРС — Просмотр общего списка связей в памяти, установка в связях ссылок на загруженную ячейку. Для учета временных связей и связей, загруженных в память ячейками MCellB. 
ЗСМ - загрузка связей ячейки в память из таблицы. Вариант для DelaySave и Temporary, когда на загружаемую ячейку уже есть связи, не существующие в таблице (временные), требует запроса из памяти также т. е. SelectT+SelectM
selectT – выборка связей ячейки из таблицы
selectM – выборка связей ячейки из памяти

Порядок загрузки ячейки:
-создание ячейки
-просмотр связей в памяти и формирование списка связей ячейки, уже размещенных в памяти. 
-загрузка связей из таблицы, исключая связи, уже присутствующие в памяти.
-установка ссылок на ячейку в связях

Перечисление связей ячейки:
MCellB, MCellBds ячейки содержат копию связей в памяти, поэтому для них не требуется поиск в таблице. Временные ячейки хранят связи только в памяти, поэтому связи с ними отсутствуют в таблице. Поскольку MCellA  могут быть связаны с временными ячейками, для них нужно учитывать связи, находящиеся в памяти.

Сохранение временной ячейки: Переделать на новую концепцию идентификаторов.
До сохранения идентификатор временной ячейки находится в диапазоне идентификаторов временных ячеек. 
-записать ячейку, получить ее постоянный идентификатор, изменить статус ячейки.
-изменить идентификатор в связях ячейки.
-записать связи ячейки.
Запись созданием (insert), поскольку ячеек и связей еще нет в таблице.

Ячейки MCellBds:
Могут быть произведены из ячейки MCellB путем смены статуса или загружены сразу с таким статусом. Ввиду возможности наличия несохраненных связей перевод из DelaySave в Default следует выполнять только после  Save(). Ограничить смену статуса в коде неудобно, так как он используется при загрузке ячейки из таблицы.
Загрузка: загружается ячейка и существующие в таблице связи.
Изменения данных не записываются в таблицу немедленно.
Вновь созданные  связи и изменения существующих связей не записываются в таблицу немедленно, хранятся в памяти, записываются вместе с ячейкой.
Поскольку часть связей ячейки существует в таблице — созданы до того, как ячейка получила статус DelaySave, то эта часть обновляется при записи, а записи новых связей создаются в таблице.
Новые связи имеют идентификатор = 0, связи, уже записанные в таблицу, имеют идентификатор отличный от 0. Идентификатор сохраняется в памяти после сздания связи в таблице.


При сохранении ячеек (в части сохранения связей ячеек) порядок: См. таблицу.
1)Если одна из ячеек связи имеет статус Temporary, то связи сохраняются только при сохранении этой ячейки. 
2)Если одна из ячеек имеет статус DelaySave, то связи сохраняются только при сохранении этой ячейки.
3)Иначе (когда обе ячейки не temp/delaysave), сохранять связи не имеет смысла, так как они синхронны с таблицей.

rel://files/celltab2.png


Детальное описание операций

++++MCellBt (Temporary)
+++++Создание ячейки
Вызывается CreateCell с параметром, указывающим создать временную ячейку. (Иначе никак нельзя получить временную ячейку.)
Создается экземпляр ячейки, устанавливается флаг Temporary, остальные поля по умолчанию, присваивается новый временный идентификатор, ячейка НЕ записывается в БД.
Ячейка добавляется в список ячеек контейнера.
Созданная ячейка возвращается вызывающему коду.

+++++Загрузка ячейки
Временная ячейка не может быть загружена из БД. Неприменимо.

+++++Создание связи
Связь может быть создана с ячейкой любого типа. Связь создается только в памяти, в таблицу не пишется. Связи  присваивается идентификатор = 0, отличающий ее от связей, записанных в таблицу. (Таким образом, ячейка MCellA может иметь связи, которые отсутствуют в таблице, и поэтому при перечислении связей такой ячейки надо соединять список связей из таблицы и список связей из памяти. Для этого необходим общий список связей контейнера, чтобы не перебирать все ячейки в поисках нужных связей. Поскольку временные связи можно отличить от постоянных, можно просто добавлять в список из таблицы временные связи из памяти). Указание связи по идентификатору, таким образом, годится только для постоянных связей, и в общем случае неприменимо.

+++++Перечисление связей ячейки
Все связи временной ячейки располагаются в памяти. Поэтому делается выборка из списка связей в памяти (то есть, списка связей ячейки).

+++++Удаление связи
Все связи временной ячейки располагаются в памяти. Поэтому связь удаляется  из списка связей ячейки, контейнера, и из списка связей связанной ячейки также.

+++++Сохранение ячейки
Временная ячейка и ее связи отсутствуют в таблице, поэтому при сохранении записи в таблицах создаются, а не обновляются. Ячейке перед сохранением присваивается новый идентификатор из постоянных, связям также присваиваются постоянные идентификаторы.
Идентификаторы ячейки в связях также надо обновить. Ячейка получает статус Default (MCellB).

+++++Удаление ячейки
Ячейка и ее связи помечаются удаленными. Удаления не происходит. Для освобождения памяти нужно выгрузить ячейку. (Unload())

+++++Выгрузка ячейки
Если выгрузка с сохранением, выполняется сохранение, затем выгрузка как MCellB.
Если выгрузка без сохранения, выгружаются все связи ячейки,  затем ячейка.
Для временной ячейки выгрузка эквивалентна полному удалению — удаляются все связи с ячейкой и сама ячейка.

+++++Смена режима ячейки
Происходит при сохранении ячейки и ее связей вызовом Save(). Все прочие способы смены режима должны выдавать исключение. 


++++MCellBds (DelaySave)
+++++Создание ячейки
Вызывается CreateCell с параметром, указывающим создать ячейку c DelaySave. 
Создается экземпляр ячейки, устанавливается флаг DelaySave, остальные поля по умолчанию, присваивается новый постоянный идентификатор, ячейка  записывается в БД.
Ячейка добавляется в список ячеек контейнера.
Созданная ячейка возвращается вызывающему коду.

+++++Загрузка ячейки
Аргументы: тип ячейки, идентификатор ячейки.
Создается экземпляр ячейки, устанавливается флаг DelaySave, загружаются поля из таблицы по идентификатору ячейки.
В список связей ячейки и в список связей контейнера загружаются связи ячейки.
Можно сперва из списка связей контейнера извлечь уже имеющиеся связи с этой ячейкой, а затем добавить из таблицы остальные связи (которые надо добавить в контейнер). 
Таким образом, список связей ячейки будет содержать все связи ячейки (большая часть которых не нужна).
 Устанавливаются в связях ссылки на ячейку и на конечные ячейки. 
Ячейка добавляется в список ячеек контейнера.
Созданная ячейка возвращается вызывающему коду.

+++++Создание связи
       Поскольку ячейка DelaySave, связи создаются в памяти без записи в таблицу. Они записываются при сохранении ячейки.

+++++Перечисление связей ячейки
Все связи ячейки существуют в памяти, использовать список связей ячейки.
+++++Удаление связи
В общем, связь нужно удалить из памяти (если она там есть), и из таблицы (если она там есть). В зависимости от типа конечной ячейки можно оптимизировать операции.
–	MCellA, id, MCellB, MCellBds   -  deleteM, если связь постоянная, то deleteT;
 Постоянные связи могут образоваться когда ячейка была MCellB, поэтому их тоже надо учитывать.
–	MCellBt      -  deleteM;  Только временные связи, в памяти. 
+++++Сохранение ячейки
Ячейка образовывает временные связи, но может иметь и постоянные. Поэтому нужно сохранить ячейку, временные связи с ячейками MCellA, MCellB, MCellBds создать в таблице, постоянные связи записать в таблицу (update), так как они могли изменить состояние. Связи ячеек MCellBt записываются при сохранении этих ячеек.

+++++Удаление ячейки
Ячейка и ее связи помечаются удаленными. Удаления не происходит. Для освобождения памяти нужно выгрузить ячейку. (Unload())

+++++Выгрузка ячейки
Если выгрузка с сохранением, выполняется сохранение.
Выгружаются связи ячейки с незагруженными ячейками, выгружается ячейка, обнуляются ссылки на ячейку в списке связей контейнера. ?

+++++Смена режима ячейки
Режим можно сменить на Default. Из-за возможности создания временных связей, запись которых откладывается,  необходимо записать ячейку перед сменой режима, но пока пользователь  должен явно сохранять ячейку, поскольку особенности реализации  ячейки.

++++MCellB (Default)
+++++Создание ячейки
Вызывается Create() с параметром, указывающим создать ячейку c Default. 
Создается экземпляр ячейки, устанавливается флаг Default, остальные поля по умолчанию, присваивается новый постоянный идентификатор, ячейка  записывается в БД.
Ячейка добавляется в список ячеек контейнера.
Созданная ячейка возвращается вызывающему коду.

+++++Загрузка ячейки
Аргументы: тип ячейки, идентификатор ячейки.
Создается экземпляр ячейки, устанавливается флаг Default, загружаются поля из таблицы по идентификатору ячейки.
В список связей ячейки и в список связей контейнера загружаются связи ячейки.
Можно сперва из списка связей контейнера извлечь уже имеющиеся связи с этой ячейкой, а затем добавить из таблицы остальные связи (которые надо добавить в контейнер). 
Таким образом, список связей ячейки будет содержать все связи ячейки (большая часть которых не нужна).
 Устанавливаются в связях ссылки на ячейку и на конечные ячейки. 
Ячейка добавляется в список ячеек контейнера.
Созданная ячейка возвращается вызывающему коду.

+++++Создание связи
 В зависимости от типа конечной ячейки различные операции.
–	MCellA, id – insertM, insertT; связи дублируются в памяти и таблице.
–	MCellB       - insertM, insertT; связи дублируются в памяти и таблице.
–	MCellBds   -  insertM;  Поскольку ячейка DelaySave, связи создаются без записи в таблицу. Они записываются при сохранении ячейки.
–	MCellBt      -  insertM;   связи только в памяти.

+++++Перечисление связей ячейки
Все связи ячейки присутствуют в памяти. Поэтому использовать список связей ячейки.
+++++Удаление связи
В общем, связь нужно удалить из памяти (если она там есть), и из таблицы (если она там есть). В зависимости от типа конечной ячейки можно оптимизировать операции.
–	MCellA, id – deleteM, deleteT;
–	MCellB       - deleteM, deleteT;
–	MCellBds   -  deleteM, если связь постоянная, то deleteT;
–	MCellBt      -  deleteM;  
+++++Сохранение ячейки
Поскольку все изменения немедленно записываются в таблицу, сохранять ячейку и связи не требуется. Временные связи сохраняются их DelaySave/Temporary ячейками.
+++++Удаление ячейки
Ячейка и ее связи помечаются удаленными. Удаления не происходит. Для освобождения памяти нужно выгрузить ячейку. (Unload())

+++++Выгрузка ячейки
Если выгрузка с сохранением, выполняется сохранение.
Сбросить все ссылки на ячейку в связях ячейки, выгрузить из памяти (списка контейнера) все связи этой ячейки с незагруженными в память ячейками, выгрузить ячейку.
Смена режима ячейки
Режим можно сменить на DelaySave только. 


++++MCellA 
+++++Создание ячейки
 Аргументы — тип создаваемой ячейки, кроме Temporary.
Создается экземпляр ячейки, остальные поля по умолчанию, присваивается новый постоянный идентификатор, ячейка  записывается в БД.
Ячейка добавляется в список ячеек контейнера.
Созданная ячейка возвращается вызывающему коду.

+++++Загрузка ячейки из БД
Аргументы — тип создаваемой ячейки, кроме Temporary, идентификатор ячейки.
Создается экземпляр ячейки MCellA. Из БД читается идентификатор ячейки. (Вариант: проверяется наличие в БД такой ячейки, затем копируется идентификатор) Ячейка добавляется в список ячеек контейнера и возвращается как результат операции.

+++++Создание связи
 В зависимости от типа конечной ячейки различные операции.
–	MCellA, id – insertT; связи только в таблице.
–	MCellB       - insertM, insertT; связи дублируются в памяти и таблице.
–	MCellBds   -  insertM;  Поскольку ячейка DelaySave, связи создаются без записи в таблицу. Они записываются при сохранении ячейки.
–	MCellBt      -  insertM;   связи только в памяти.

+++++Перечисление связей ячейки
Ячейка MCellA не имеет списка связей. Список получается в результате запроса из БД, и не сохраняется, только для чтения.
Постоянные связи ячейки  размещены в таблице.  Постоянные связи с загруженными в память ячейками MCellB размещены в памяти. Временные связи размещены в памяти. Таким образом, память содержит часть постоянных связей ячейки и все временные связи. Запрос из БД возвращает постоянные связи ячейки, не привязанные к контейнеру. Поэтому, в общем случае, нельзя манипулировать этими связями  по-экземпляру.
Список связей из БД дополняется связями из памяти. В памяти могут быть дубликаты постоянных связей — от уже загруженных в память ячеек. В памяти размещаются временные связи. 
Поэтому тут есть варианты:
–	привязывать связи MCellA к контейнеру — долго. Это значит вставить их в список связей контейнера и снабдить ссылкой на экземпляр ячейки. Зачем они там нужны?
–	Заменять в списке ячейки связи на аналогичные, размещенные в контейнере — часть связей будет привязана, часть нет. Как потом будут использоваться связи ячейки?  
–	Обрабатывать их особо, при необходимости — как отличать от остальных?
TODO: доработать. 

+++++Удаление связи
В общем, связь нужно удалить из памяти (если она там есть), и из таблицы (если она там есть). В зависимости от типа конечной ячейки можно оптимизировать операции.
–	MCellA, id – deleteT;
–	MCellB       - deleteM, deleteT;
–	MCellBds   -  deleteM, если связь постоянная, то deleteT;
–	MCellBt      -  deleteM;  

+++++Сохранение ячейки
Для MCellA сохранение не требуется. Временные связи сохраняются при сохранении их ячеек. 
Удаление ячейки
Ячейка и ее связи (в таблице) помечаются удаленными. Удаления не происходит. Для освобождения памяти нужно выгрузить ячейку. (Unload())

+++++Выгрузка ячейки
Если выгрузка с сохранением, выполняется сохранение.
Сбросить все ссылки на ячейку в связях ячейки, выгрузить из памяти (списка контейнера) все связи этой ячейки с незагруженными в память ячейками, выгрузить ячейку.

+++++Смена режима ячейки
Для MCellA не имеет смысла, возвращает Default, но поскольку интерфейс у двух подтипов ячеек общий, выдается исключение при попытке сменить Default на что-то другое.

++++Сумма по операциям — переработать, описать все используемые процедуры

+++++Создание ячейки - сделано
Идеи: 
–	 если хранить в таблице еще и cellMode, его можно использовать для обозначения предпочтительного формата ячейки.
–	...
Mengine.intCreateCell(cellMode):
Создается экземпляр ячейки MCellB с значениями по умолчанию.  Присваивается cellMode.
Если MCellBt, присваивается новый временный идентификатор. Иначе — новый постоянный идентификатор. 
Если не MCellBt,  ячейка добавляется в таблицу.
Если MCellA, берем идентификатор, уничтожаем старую ячейку, создаем MCellA, присваиваем идентификатор. (Поскольку ячейка MCellA не содержит полей, а нужно создать запись в таблице, используем MCellB как заготовку.)
Добавляем ячейку в список ячеек контейнера. Возвращаем ссылку на ячейку. 

++++++MCellBt
Вызывается CreateCell с параметром, указывающим создать временную ячейку. (Иначе никак нельзя получить временную ячейку.)
Создается экземпляр ячейки, устанавливается флаг Temporary, остальные поля по умолчанию, присваивается новый временный идентификатор, ячейка НЕ записывается в БД.
Ячейка добавляется в список ячеек контейнера.
Созданная ячейка возвращается вызывающему коду.
++++++MCellBds
Вызывается CreateCell с параметром, указывающим создать ячейку c DelaySave. 
Создается экземпляр ячейки, устанавливается флаг DelaySave, остальные поля по умолчанию, присваивается новый постоянный идентификатор, ячейка  записывается в БД.
Ячейка добавляется в список ячеек контейнера.
Созданная ячейка возвращается вызывающему коду.
++++++MCellB
Вызывается Create() с параметром, указывающим создать ячейку c Default. 
Создается экземпляр ячейки, устанавливается флаг Default, остальные поля по умолчанию, присваивается новый постоянный идентификатор, ячейка  записывается в БД.
Ячейка добавляется в список ячеек контейнера.
Созданная ячейка возвращается вызывающему коду.
++++++MCellA
Создается экземпляр ячейки, остальные поля по умолчанию, присваивается новый постоянный идентификатор, ячейка  записывается в БД.
Ячейка добавляется в список ячеек контейнера.
Созданная ячейка возвращается вызывающему коду.

+++++Загрузка ячейки из БД — сделано
Mengine.intLoadCell(cellId, cellMode);
Пи загрузке ячейки загружаются в память все связи ячейки без разбора.
Проверяем идентификатор. Если временной ячейки — возвращаем нуль или исключение. 
 Для MCellA: Создается экземпляр ячейки MCellA. Проверяется наличие в БД такой ячейки, затем в экземпляр копируется идентификатор. Если ячейки в БД нет, выдается исключение или возвращается null. Ячейка добавляется в список ячеек контейнера. Связи не надо загружать, поскольку некуда. Ссылки на ячейку в связях будут нуль, поэтому получать ячейку через общий механизм, и записывать ссылку в связь, раз она уже под рукой.
Для MCellB, Bds: Получаем ячейку из БД. Если ее нет, возвращаем нуль или исключение.
Загружаем в ячейку связи из списка связей контейнера проходом по всем связям контейнера, ищем где один из идентификаторов соответствует ячейке. Одновременно устанавливаем ссылки на ячейку. В результате список связей ячейки содержит связи с загруженными в память ячейками и рабочими ссылками. Процесс долгий, надо ускорить.
Загружаем список связей из таблицы: Получаем список связей ячейки из таблицы. Для каждой связи из этого списка: Если связи нет в списке связей ячейки, добавляем ее туда, устанавливаем ссылки на ячейки, добавляем в контейнер. 
В результате список связей ячейки соответствует списку связей в таблице+памяти. Все связи добавлены в контейнер и снабжены ссылками на ячейки. Проверить.
Если в процессе этой работы возникают ошибки, возвращаем нуль. Поэтому может получиться, что связи загружены в контейнер и ссылки на ячейку есть, а самой ячейки нет. Надо сделать полный откат изменений или хотя бы сбросить ссылки на ячейку в связях контейнера.
Ячейка добавляется в список ячеек контейнера и возвращается вызывающему коду.

При доступе к конечной ячейке связи (полю ссылки на ячейку в связи — потребуется ссылка на  контейнер, поэтому код придется выносить в ячейку. Как вариант — сделать отдельной функцией, с аргументом - контейнером): проверяем ссылку на ячейку. Если ссылка недействительна, получаем ссылку через getCell(), вписываем ее в связь, а лучше для конечной ячейки (не MCellA) вызываем функцию, которая проходит по всем связям ячейки и заносит в них ссылки на ячейку. Если же MCellA, то просто вписываем ссылку в связь, поскольку некуда больше.
В этом случае нет необходимости явно загружать ссылки в связи, таким образом, при сбое загрузки ячейки ссылки в связях до использования ячейки будут пустыми, и не нужно ничего откатывать.

++++++MCellBt
Временная ячейка не может быть загружена из БД. Неприменимо.
++++++MCellBds
Аргументы: тип ячейки, идентификатор ячейки.
Создается экземпляр ячейки, устанавливается флаг Default, загружаются поля из таблицы по идентификатору ячейки,  устанавливается флаг DelaySave. (Это уже выполняется в MDbLayer)
В список связей ячейки и в список связей контейнера загружаются связи ячейки.
Можно сперва из списка связей контейнера извлечь уже имеющиеся связи с этой ячейкой, а затем добавить из таблицы остальные связи (которые надо добавить в контейнер). 
Таким образом, список связей ячейки будет содержать все связи ячейки (большая часть которых не нужна).
 Устанавливаются в связях ссылки на ячейку и на конечные ячейки. 
Ячейка добавляется в список ячеек контейнера.
Созданная ячейка возвращается вызывающему коду.
++++++MCellB
Аргументы: тип ячейки, идентификатор ячейки.
Создается экземпляр ячейки, устанавливается флаг Default, загружаются поля из таблицы по идентификатору ячейки.
В список связей ячейки и в список связей контейнера загружаются связи ячейки.
Можно сперва из списка связей контейнера извлечь уже имеющиеся связи с этой ячейкой, а затем добавить из таблицы остальные связи (которые надо добавить в контейнер). 
Таким образом, список связей ячейки будет содержать все связи ячейки (большая часть которых не нужна).
 Устанавливаются в связях ссылки на ячейку и на конечные ячейки. 
Ячейка добавляется в список ячеек контейнера.
Созданная ячейка возвращается вызывающему коду.
++++++MCellA
Аргументы — тип создаваемой ячейки, кроме Temporary, идентификатор ячейки.
Создается экземпляр ячейки MCellA. Из БД читается идентификатор ячейки. (Вариант: проверяется наличие в БД такой ячейки, затем копируется идентификатор) Ячейка добавляется в список ячеек контейнера и возвращается как результат операции.

+++++Создание связи
Идентификатор связи присваивается после записи в таблицу, поскольку является первичным ключом в таблице. Временные связи имеют идентификатор = 0 и отсутствуют в таблице.
Аргументы: cellId1, cellId2, axis, … 
Создается экземпляр связи с идентификатором = 0. Заполняется свойствами.

Далее по типам ячеек (см ниже): Проверяется отсутствие такой связи в памяти и/или таблице. добавляется в таблицу, Добавляется в списки связей связываемых ячеек, в контейнер. Ссылки на ячейки можно установить сразу при создании связи.

Сделать диаграмму — создание связи между ячейками можно переложить на конечную ячейку — они равноправны, поэтому можно упростить код.
По диаграмме: код целесообразно привязать к ячейке, чтобы ячейка сама определяла создание связей с ней. Приоритет:  MCellBt, MCellBds, MCellB, MCellA.
Код состоит из комбинации однотипных операций, их разместить где удобно согласно диаграмме.

++++++MCellBt
Связь может быть создана с ячейкой любого типа. Связь создается только в памяти, в таблицу не пишется. Связи  присваивается идентификатор = 0, отличающий ее от связей, записанных в таблицу. (Таким образом, ячейка MCellA может иметь связи, которые отсутствуют в таблице, и поэтому при перечислении связей такой ячейки надо соединять список связей из таблицы и список связей из памяти. Для этого необходим общий список связей контейнера, чтобы не перебирать все ячейки в поисках нужных связей. Поскольку временные связи можно отличить от постоянных, можно просто добавлять в список из таблицы временные связи из памяти). Указание связи по идентификатору, таким образом, годится только для постоянных связей, и в общем случае неприменимо.
Проверка отсутствия связи: checkM
++++++MCellBds
      Поскольку ячейка DelaySave, связи создаются в памяти без записи в таблицу. Они записываются при сохранении ячейки. Связи  присваивается идентификатор = 0, отличающий ее от связей, записанных в таблицу.
Проверка отсутствия связи: checkM
++++++MCellB
 В зависимости от типа конечной ячейки различные операции.
–	MCellA, id – checkTorM, insertM, insertT; связи дублируются в памяти и таблице. Проверять связь через таблицу, если у ячейки много связей, поскольку в таблице есть индексы. Если связей мало, проверять связи в памяти, так быстрее.
–	MCellB       - checkTorM, insertM, insertT; связи дублируются в памяти и таблице. Проверять связь через таблицу, если у ячейки много связей, поскольку в таблице есть индексы. Если связей мало, проверять связи в памяти, так быстрее.
–	MCellBds   -  checkM, insertM;  Поскольку ячейка DelaySave, связи создаются без записи в таблицу (id = 0) Они записываются при сохранении ячейки. 
–	MCellBt      -  checkM, insertM;  связи только в памяти.

++++++MCellA
 В зависимости от типа конечной ячейки различные операции.
–	MCellA, id – checkT, insertT; связи только в таблице.
–	MCellB       - checkTorM, insertM, insertT; связи дублируются в памяти и таблице. Проверять связь через таблицу, если у ячейки много связей, поскольку в таблице есть индексы. Если связей мало, проверять связи в памяти, так быстрее.
–	MCellBds   -  checkM, insertM;  Поскольку ячейка DelaySave, связи создаются без записи в таблицу. Они записываются при сохранении ячейки.
–	MCellBt      -  checkM, insertM;  связи только в памяти.

InsertM
Создать экземпляр связи, добавить в списки связей ячеек и список связей контейнера. Если можно, установить в связи ссылки на ячейки.
InsertT
Создать экземпляр связи, вставить в таблицу. Получить идентификатор связи, если он требуется.


+++++Перечисление связей ячейки
Ячейка должна хранить все существующие связи. Поэтому загружаются все связи без фильтрации.
Возвращается список связей ячейки, фильтрованный по критериям. Типично в списке не нужны неактивные связи. Пользователь может устанавливать параметры отбора или использовать типичные варианты (которые пока надо определить и реализовать). 

++++++MCellBt
Все связи временной ячейки располагаются в памяти. Поэтому делается выборка из списка связей в памяти (то есть, списка связей ячейки). 
++++++MCellBds
Все связи ячейки, включая временные, существуют в памяти, использовать список связей ячейки.
++++++MCellB
Все связи ячейки присутствуют в памяти. Поэтому использовать список связей ячейки.
++++++MCellA
Ячейка MCellA не имеет списка связей. Список получается в результате запроса из БД, и не сохраняется, только для чтения.
Постоянные связи ячейки  размещены в таблице.  Постоянные связи с загруженными в память ячейками MCellB размещены в памяти. Временные связи размещены в памяти. Таким образом, память содержит часть постоянных связей ячейки и все временные связи. Запрос из БД возвращает постоянные связи ячейки, не привязанные к контейнеру. Поэтому, в общем случае, нельзя манипулировать этими связями  по-экземпляру.
Список связей из БД дополняется связями из памяти. В памяти могут быть дубликаты постоянных связей — от уже загруженных в память ячеек. В памяти размещаются временные связи. 
Поэтому тут есть варианты:
–	привязывать связи MCellA к контейнеру — долго. Это значит вставить их в список связей контейнера и снабдить ссылкой на экземпляр ячейки. Зачем они там нужны?
–	Заменять в списке ячейки связи на аналогичные, размещенные в контейнере — часть связей будет привязана, часть нет. Как потом будут использоваться связи ячейки?  
–	Обрабатывать их особо, при необходимости — как отличать от остальных?
TODO: доработать. 

+++++Поиск/проверка существования связи - доработать
checkTorM
Постоянные связи ячеек MCellB, MCellBds можно искать или через память, или через таблицу. Если у ячейки связей больше порогового значения, ищем через таблицу — там есть индексы. Если меньше — ищем в списке ячейки перебором — так быстрее. Пороговое значение выделено в статическое поле ячейки  [//Ячейка/КонстантаПорогЧислаСвязей]. Значение нужно подобрать для улучшения производительности.
CheckM - ДОРАБОТАТЬ
Поиск связи в списке связей контейнера. Если обе ячейки загружены в память, ищем связь перебором в меньшем списке. Если только одна ячейка загружена в память, ищем связь в ней.
 В списках ячеек MCellA связи не ищем. 
CheckT
Ищем связь в таблице запросом. Только для постоянных связей.

MCellBt
MCellBds
MCellB
MCellA


+++++Удаление связи
Связи не удаляются, а помечаются удаленными. Временные связи также не удаляются, но и при сохранении, помеченные удаленными, не записываются в таблицу. Однако надо обеспечить единый интерфейс операций, согласованность версий связей в памяти и БД.
Чтобы пометить связь удаленной, ее надо получить, пометить и записать. Поскольку не известно, где искать связь, надо анализировать типы ячеек.
Порядок:
1)Если хотя бы одна из ячеек MCellBt, связь временная и только в памяти. Сохранять в таблице не надо.
2)Если хотя бы одна из ячеек MCellBds, связь надо искать в памяти. Сохранять в таблице только  если связь постоянная.
3)Если хотя бы одна из ячеек MCellB, искать в памяти, сохранять в таблице, если связь постоянная.
4)Обе ячейки в связи MCellA. Искать в таблице, сохранить в таблице.
Еще проще:
Поскольку ячейки имеют список связей, Кроме MCellA, искать надо в списке связей текущей ячейки, записывать в таблицу только если связь существует в таблице.
Для MCellA: Если конечная ячейка не MCellA, искать в ее списке связей. Иначе искать в таблице.



Ниже рассматривается удаление связи [Оптимизатор]ом.
Построить  диаграмму удаления связей.
[Оптимизатор] может не париться —. Для удаления связи просто пометить ее удаленной, потом  проходом по списку связей контейнера удалить связи, помеченные удаленными, из этого списка и из ячеек. И из таблицы, если связь постоянная.
Так что диаграмма для общего представления.
Приоритет:
MCellA – у нее нет постоянного списка связей, а собирать его долго.
MCellBt – у нее нет связей в таблице.
MCellBds  и MCellBt практически одинаковые, но MCellBds требует большей функциональности.
++++++MCellBt
Все связи временной ячейки располагаются в памяти. Поэтому связь удаляется  из списка связей ячейки, и из списка связей связанной ячейки также.
++++++MCellBds
В общем, связь нужно удалить из памяти (если она там есть), и из таблицы (если она там есть). В зависимости от типа конечной ячейки можно оптимизировать операции.
–	MCellA, id, MCellB, MCellBds   -  deleteM, если связь постоянная, то deleteT;
 Постоянные связи могут образоваться когда ячейка была MCellB, поэтому их тоже надо учитывать.
–	MCellBt      -  deleteM; Только временные связи, в памяти. 
++++++MCellB
В общем, связь нужно удалить из памяти (если она там есть), и из таблицы (если она там есть). В зависимости от типа конечной ячейки можно оптимизировать операции.
–	MCellA, id – deleteM, deleteT;
–	MCellB       - deleteM, deleteT;
–	MCellBds   -  deleteM, если связь постоянная, то deleteT;
–	MCellBt      -  deleteM;  

++++++MCellA
В общем, связь нужно удалить из памяти (если она там есть), и из таблицы (если она там есть). В зависимости от типа конечной ячейки можно оптимизировать операции.
–	MCellA, id – deleteT;
–	MCellB       - deleteM, deleteT;
–	MCellBds   -  deleteM, если связь постоянная, то deleteT;
–	MCellBt      -  deleteM;  

+++++Сохранение ячейки
Сохранение временных связей ячейки: Если сохраняемая ячейка MCellBds или MCellBt, (а для других операция сохранения и не нужна) и если конечная ячейка MCellBds или MCellBt, то связь не сохраняется, поскольку иначе получится, что временная ячейка соединена постоянной связью с постоянной ячейкой, что неправильно.

++++++MCellBt
Временная ячейка и ее связи отсутствуют в таблице, поэтому при сохранении записи в таблицах создаются, а не обновляются. Ячейке перед сохранением присваивается новый идентификатор из постоянных, связям после сохранения присваиваются постоянные идентификаторы.
Обновить идентификаторы ячейки в связях перед записью в таблицу. Ячейка получает статус Default (MCellB).
++++++MCellBds
Ячейка образовывает временные связи, но может иметь и постоянные. Поэтому нужно сохранить ячейку, временные связи с ячейками MCellA, MCellB, MCellBds создать в таблице, постоянные связи записать в таблицу (update), так как они могли изменить состояние. Связи ячеек MCellBt записываются при сохранении этих ячеек.
++++++MCellB
Поскольку все изменения немедленно записываются в таблицу, сохранять ячейку и связи не требуется. Временные связи сохраняются их DelaySave/Temporary ячейками.

++++++MCellA
Для MCellA сохранение не требуется. Временные связи сохраняются при сохранении их ячеек. 

+++++Удаление ячейки - готово
Ячейка и ее связи помечаются удаленными. Удаления не происходит. Для освобождения памяти нужно выгрузить ячейку. (Unload())

+++++Выгрузка ячейки — почти готово

Для MCellBds, MCellBt - если выгрузка с сохранением, выполняется сохранение,(ячейка превращается в MCellB) затем выгрузка как MCellB. Остальные типы ячеек не нуждаются в сохранении.
Для MCellB типовой процесс:
Получить все связи ячейки. Связи с загруженными ячейками изменить — сбросить ссылки на ячейку. Связи с незагруженными ячейками удалить из списка связей контейнера.
Незагруженные ячейки — это ячейки, которые отсутствуют в списке ячеек контейнера; если в связи отсутствует ссылка на ячейку, это не означает, что ячейка отсутствует в памяти.
Загруженные ячейки присутствуют в списке связей контейнера, могут иметь ссылку на ячейку в связях.
Очистить список связей ячейки. При этом связи, на которые нет ссылок в контейнере или списках других ячеек, будут со временем удалены.
Удалить ячейку из списка контейнера.
++++++MCellBt
Для временной ячейки выгрузка эквивалентна полному удалению — отовсюду удаляются все связи с ячейкой и сама ячейка.
++++++MCellBds
Ячейка может содержать временные связи с другими ячейками. Поскольку ячейка не была сохранена, эти связи (пока положим так) должны быть выгружены без сохранения, за исключением связей с временными ячейками. (Подумать, как могут использоваться временные связи с другими ячейками и как их обрабатывать — а как будет использоваться сама ячейка?).
Выгружаются связи ячейки с незагруженными ячейками, выгружается ячейка, обнуляются ссылки на ячейку в списке связей контейнера. ?
++++++MCellB
Сбросить все ссылки на ячейку в связях ячейки, выгрузить из памяти (списка контейнера) все связи этой ячейки с незагруженными в память ячейками, выгрузить ячейку. См выше.
++++++MCellA
Сбросить все ссылки на ячейку в списке связей контейнера. Лучше всего проходом по списку связей контейнера. Одновременно? удалить из списка связей контейнера  все связи этой ячейки с незагруженными в память ячейками (а они там могут быть? Связи MCellA-MCellA и MCellA-id не хранятся в контейнере, не должны.), удалить ячейку из списка ячеек контейнера.
Ячейка может иметь временные связи, их  не выгружать.

+++++Смена режима ячейки - готово
Можно в режим ячейки добавить поле для обозначения MCellA  ячейки, но надо обдумать.
++++++MCellBt
Происходит при сохранении ячейки и ее связей вызовом Save().  Меняется на Default. Все прочие способы смены режима должны выдавать исключение. 
++++++MCellBds
Режим можно сменить на Default. Из-за возможности создания временных связей, запись которых откладывается,  необходимо записать ячейку перед сменой режима, но пока пользователь  должен явно сохранять ячейку, поскольку особенности реализации  ячейки.
++++++MCellB
Режим можно сменить на DelaySave только. 

++++++MCellA
 Для MCellA не имеет смысла, возвращает Default,  выдается исключение при попытке сменить Default на что-то другое.

++++Вспомогательные функции - уже разнесены по сущностям вики
+++++Получение наибольшего существующего идентификатора ячейки
При создании ячейки ей нужно присвоить новый идентификатор. Поскольку использование б/у идентификаторов нежелательно, нужно получить наибольший существующий идентификатор ячейки (НСИ).
Новый идентификатор получается как НСИ+1.
При удалении ячеек освободившиеся идентификаторы вновь используются, если они меньше НСИ. Можно бы вообще не использовать эти идентификаторы, адресного пространства достаточно. Это позволило бы явно указывать идентификаторы в коде без проблем. Но пока так. При необходимости можно переделать движок, все необходимые изменения локализованы в описываемом здесь механизме.
Для получения НСИ надо просмотреть весь список ячеек: 
В таблице — для постоянных идентификаторов;
В памяти — для временных идентификаторов.
Этот процесс долгий, и применяется кеширование. В списке ячеек контейнера нужно хранить  НСИ ячеек - для постоянных ячеек и для временных ячеек.
Новый идентификатор получаем из существующего соответственным увеличением числа.
Поиск идентификатора проводится как можно реже. Рассмотрим ключевые точки, в которых он необходим:
–	При старте системы. Первоначально кеш идентификатора = 0, это означает, что необходимо искать НСИ. Поиск идентификатора проводится при требовании его значения.
–	При создании ячейки. Нужно получить НСИ, чтобы произвести идентификатор новой ячейки. Имея кеш НСИ, можно обойтись без поиска.  Здесь надо присвоить кешу новое значение НСИ.
–	При удалении ячейки. Нужно обновить НСИ только если удаляемая ячейка имела НСИ, в противном случае НСИ не изменился, и ничего не надо делать. Нужно проводить полный поиск, чтобы получить действительный НСИ, поскольку предыдущие ячейки тоже могли быть удалены. Поиск проводится при следующем требовании НСИ, для этого кеш = 0.
Первоначально кеш идентификатора = 0, это означает, что необходимо искать НСИ. Если кеш не 0, просто используется его значение. 
Поиск идентификатора проводится при требовании его значения. Для постоянных идентификаторов проводится запрос в таблицу.
 Для временных идентификаторов проводится поиск в памяти перебором элементов. При этом, если в структуре нет временных ячеек, поиск ничего не даст, и новый запрос  НСИ  должен будет проводить новый поиск, при этом будут перебираться постоянные ячейки в памяти. Поэтому поиск НСИ для постоянных и для временных идентификаторов — раздельные операции, выполняющиеся при требовании соответствующего НСИ. При создании первой же временной ячейки ее идентификатор будет записан в кеш, и поиск не будет выполняться..

+++++Получение нового идентификатора ячейки
Поскольку идентификаторы бывают временные и постоянные, новый идентификатор для них вычисляется по-разному. Для постоянных идентификаторов +1, для временных -1. Если идентификатор достигает предельного значения, выдается исключение.

+++++Контроль идентификатора ячейки
Зарезервированные значения идентификаторов:
0 -  для индикации  ошибок типа «Отсутствует идентификатор ячейки»
int32.MIN –  если число временных  ячеек превысило выделенный диапазон.
Int32.MAX –  если число постоянных ячеек превысило выделенный диапазон.
Контроль должен выполняться при операциях с идентификаторами ячеек, но это снижает производительность, поэтому внедрение проверок отложено до формирования общей структуры кода.
Типично проверка выбрасывает исключения «Неправильный идентификатор ячейки».

+++++Проверка, что идентификатор ячейки временный
Функция возвращает TRUE, если идентификатор < 0. Код выделен в отдельную функцию для изоляции концепции идентификаторов от реализации. Если возможно, следует его инлайнить. Можно дополнить его другими функциями проверки.

+++++Получение списка связей ячейки из контейнера
Аргументы: Идентификатор ячейки, ссылка на ячейку в памяти или null если ссылки нет.
Проходом по всем связям в списке связей контейнера включаем в возвращаемый список связи, которые содержат идентификатор ячейки. Присваиваем в связи ссылку на ячейку.
Возвращаем список связей для указанной ячейки.

+++++Вычитание списков связей — уточнить
Аргументы:  список1, список2
Результат: Список связей, отсутствующих в списке1, присутствующих в списке 2.
Если в списке 1 отсутствует связь, аналогичная связи в списке 2 по всем полям, кроме ссылок, комментария, …, она должна быть помещена в выходной список.
Типовой алгоритм — последовательный перебор n1 элементов n2 раз.
Как ускорить?
–	сформировать 64-битный хеш из данных связи. Одинаковые связи имеют одинаковый хеш, таким образом только одно сравнение вместо нескольких. Однако надо его где-то хранить.
–	Сортировать связи по значению хеша. Поиск быстрее, но время на сортировку.
–	Построить двоичное дерево по значению хеша для меньшего из списков. Из большего списка перебором искать в дереве одинаковые по хешу.
Вывод:
В целом применимо для больших списков, для малых перебором быстрее. Запланировать фукцию генерации хеша для связи. Потребуется несколько вариантов, для разных применений поиска. Запланировать класс двоичного дерева поиска по хешу и его функционал универсально для связей, ячеек и так далее. 
Можно пока попробовать словарь, если гарантируется уникальность хеша.

+++++Получить связь между ячейками из списка связей контейнера
Аргумент — шаблон связи, в котором указаны обе ячейки, ось связи, ...
Предполагается, что обе ячейки существуют в памяти.
Поэтому получаем размер списка связей обеих ячеек. Ищем связь в меньшем списке перебором.
Если в памяти только одна из ячеек, то поиск перебором по ней.

+++++Проверка что связь временная
Возвращает TRUE если идентификатор связи = 0.

rel://files/celltab4.png

rel://files/celltab41.png
