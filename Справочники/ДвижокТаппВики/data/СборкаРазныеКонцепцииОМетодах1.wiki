++ Сборка Разные Концепции О Методах1


+++импорт методов или спецификаторы видимости
Решение: Предлагается вернуться к этой идее после опыта работы с движком.
Можно предложить помечать методы спецификаторами видимости, чтобы обозначать экспортируемый набор операций класса.
Спецификаторы должны храниться в ячейке, методу они не нужны.
Спецификаторы можно возложить на связи ячейки с методами, но неясно как. В си спецификаторы обозначают экспорт методов, здесь тоже. Поскольку связи с методами вообще определяют экспортируемый набор, логично использовать их для спецификации экспорта.
Только как реализовать? Специальные типы связей, дополнительные свойства связей?
public - экспортировать МетодОбработчикЯчейки обработчик
private - не экспортировать обработчик
? protected - экспортировать только производным (а чужие тут и не ходят)
? internal - экспортировать только в пределах некоторого региона (какого?)
abstract - экспортировать, но необходимо переопределить обработчик.

+++Разные концепции про методы
++++Попробуем с другого конца
Вот есть пустая база. Создаем ячейку-сущность. Для создания ячейки нужно указать идентификатор типа - сущность, которая является шаблоном типа и может предоставлять конструктор типа. Еще надо указать идентификатор типа данных - сущность, которая предоставляет функции трансляции данных ячейки. И идентификатор состояния ячейки - сущность, которая тоже чего-то там может обозначать, а пока не используется. Поскольку этих сущностей нет, вместо них пишем 0. 
Нужно заметить, что эти поля идентификаторов в принципе не являются необходимыми для создания ячейки. Их можно заменить на связи, которые, разумеется, можно не создавать. То есть, в пустой базе их все равно что нет. Будет ячейка дефолтового типа, дефолтового типа данных, дефолтового состояния. Правда, код, обслуживающий существование ячейки, предполагается вызывать МетодОбработчикЯчейки обработчики для выполнения операций, а эти обработчики импортируются из сущности-типа ячейки. Вызов обработчиков предполагает стандарт на аргументы и формат. Допустим, что дефолтовый тип поддерживается в коде: его обработчики реализованы в коде.
Далее, мы создали эту сущность, используем ее в качестве типа ячейки. Прицепили к ней обработчики в соответствии с придуманной системой семантических слотов, и теперь по ней можно создавать ячейки нового типа.
Теперь можно создать еще несколько сущностей, сделать из них еще типы ячеек, а затем типы данных и прочую минимально необходимую оснастку. Поскольку типы ячеек не используют поле данных, они могут оставаться дефолтового типа данных. Дефолтовый тип данных, очевидно, Object. Как он сериализуется в varchar, и как его можно использовать, нужно поэкспериментировать.
Теперь вопрос создания связи. Для создания связи надо указать идентификатор сущности-оси, и сущности - состояния.
Поскольку этих сущностей в нашем случае нет, пишем туда 0. 
Ось связи должна что-то означать. Допустим, дефолтовая ось означает "Все что угодно". Так можно связать две сущности, это обозначает, что они связаны, но непонятно, для чего.
Ось связи предоставляет МетодОбработчикЯчейки обработчики для создания оси. Вернее, для соблюдения правил создания оси. Обработчики должны вызываться из кода или из семантического слота "CreateLink" ячейки? 
Допустим, для дефолтовой оси обработчик реализован в коде и просто создает ось без всяких проверок.
(Все время возникает вопрос: как бы так реализовать систему семантических слотов, чтобы она задавалась в базе самими ячейками?
Можно бы вообще отделаться от обработчиков в коде, возложив их вызов или невызов на методы ячейки. Надо разобраться, как должны работать вызовы операций ячеек.)
Теперь можно представить, что сначала создаются связи дефолтового типа, потом создаются сущности-типы связей, и связи переделываются на новые типы. Этакая реорганизация системы в результате развития.
Состояние связи дефолтовое должно означать, что связь действительна. Ну или не мешать ее использовать хотя бы. 
Кстати, как это состояние влияет на связь, какой механизм? С учетом случая его отсутствия из-за отсутствия сущностей этого состояния?
Теперь методы. Методы отсутствуют в пустой базе. Соответственно, если ячейка будет использовать вызов МетодОбработчикЯчейки обработчиков, то обработчиков нет, поскольку методов нет.
Создание метода в пустой базе. Методу нужны данные, поэтому база уже точно не пустая. Должны быть сущности - типы данных, сущности - данные, связи, типы связей, обработчики для семантических слотов. В простом случае алгоритм реализован в коде.

Как сделать обработчики для ячеек, не имея обработчиков?
Данные состоят из одной ячейки, метод-обработчик из нескольких. Чтобы выкрутиться из ситуации, надо просчитать весь процесс, и необходимый для функционирования метода код вынести в движок, хотя бы для создания и работы обработчиков самого метода. 
Пусть семантические слоты задаются ячейками, описывающими тип ячейки. 
Например, просто копируются методы из типа. Эти методы должны уже существовать. Поэтому просто рассмотрим создание метода, для простоты, МетодИзКода.
1 Создаем ячейку для будущего метода. Надо иметь сущность типа-метода, которая обозначает, что эта ячейка является методом.
Эта сущность будет шаблоном структуры метода, и вообще-то, она может быть классифицирована как шаблон сущности в базе, наряду с шаблонами коллекций и прочих конструкций. Эта сущность типично предоставляет метод-конструктор для создания своих подопечных, но в данном случае конструктора нет. Эта сущность может ссылаться на несуществующие методы или на специальный местодержатель, чтобы показать, что метод должен быть, но пока не определен. (Это, кстати, способ обозначить интерфейс, не имея пока реализации.) 
Для ячейки еще надо указать идентификатор типа данных. Что в методе может обозначать это поле, и поле данных? Возвращаемое значение относится к аргументам метода. Вроде бы не нужно это поле здесь.
Может быть, проблема в том, что данные и связи - атомарные сущности, а метод получается составной сущностью?
Метод сложнее данных - он содержит последовательность элементов алгоритма, список аргументов, имеет несколько разных вариантов строения. В предполагаемом виде метод является результатом эволюции. Эволюция, по видимому, должна начинаться с методов, не имеющих аргументов и возвращаемых значений, и с одним всего действием. (?) Или даже вовсе без действия.
Или может метод может быть устроен как-то иначе?
2) создаем ячейку для алгоритма. В поле типа ячейки вписываем тип - алгоритм-код.
3) создаем ячейку для списка аргументов. В поле типа ячейки вписываем тип - список аргументов. Этот тип относится к классу упорядоченных коллекций. (Блин, что-то сложно.)

Так, что-то мутное получается. Может, ввести концепцию стандартного обработчика без аргументов и результата? Обработчик вызывается ячейкой, и что-то делает в этой ячейке... Аргументов нет, поэтому он сам добывает себе данные. Объект ячейки отсылается в метод как стандартный вызов - он в любом методе отсылается, без вариантов. Обработчик ничего не возвращает - он изменяет состояние системы, зачем что-то еще возвращать? Алгоритм можно реализовать в коде или в скрипте. В поле данных можно хранить скрипт или путь к коду, в поле типа данных - тип метода: код или скрипт. Для МетодГраф придется добавлять еще связь с коллекцией-алгоритмом, и тип данных будет МетодГраф. Тип метода снабдить обработчиком, исполняющим метод. Этот обработчик реализовать в коде.
Вроде бы все. Одна ячейка - один метод. Надо обдумать.

В общем, так и не понятно, как создать базу с нуля, без стартового набора сущностей. Данные вроде бы можно создать, но надо подумать и повозиться. А методы сами по себе не получаются. Причем именно МетодГраф, который соблазнительно в пустой базе иметь (чтобы вообще отказаться от программирования), не получается завести без кучи обработчиков из кода. Хотя наверно, я что-то упустил. Надо сделать прототип движка и попробовать весь стартап системы в нем сделать.

++++О методах
Если предположить, что методы ячейки собираются из ее надячеек, комбинируются в методы самой  ячейки, то:
А) если ячейка не привязана к унаследованным методам, то надо собирать все методы надячеек, сопоставлять переопределения, чтобы вернуть пользователю набор доступных ячейке операций.
Б) если ячейка связана с унаследованными методами, то получение списка методов будет быстрым, но число связей ячейки будет большим. Смену метода будет проще согласовать.

Функция – аргументы, результат, алгоритм.
rel://files/метод%20табл1.jpg

rel://files/мет2.png

Операторы являются объектами классов и связаны отношениями:
- потока управления  - друг с другом.
- классификации – с классами операторов
- потока данных – с данными.
- принадлежности к функции – с функцией.

Данные-объекты классов данных связаны отношениями:
- использование данных – потока данных – с операторами
- классификации – с их классами данных
- принадлежности к функции – с функцией.

Аргументы – это данные, которые инициализируются вне алгоритма. Они используются в алгоритме, но для удобства их можно внести в список в функции.
Результаты – это данные, которые инициализируются в алгоритме и возвращаются в вызывающий код. Для удобства пользователя их можно внести в информацию о функции.

rel://files/мет3.png
 
rel://files/мет4.png


Функция это объект, содержащий объекты. Это конструкция, декларация функции. Когда функция исполняется, создается …

Функция хранится в контейнере как шаблон. Функция состоит из объектов классов. То есть, функция это класс, из которого производятся реальные объекты для использования в других функциях  (исполнения?).
Алгоритм – класс.
Операции алгоритма – класс некоторого суперкласса операции.
Данные – 
Список аргументов – 
Результаты – 

Слои абстракций
1)	классы элементов, отдельно друг от друга.
2)	Сборки подклассов, образующие прототип функции и ее структуру.
3)	Объекты подклассов, повторяющие строение функции и реально выполняющие ее работу.

Использование функций в функциях.
Функция А вызывает функцию Б. Функция С вызывает функцию Б,
Тогда получается, на уровне 2 функция Б будет содержать ссылки из А и С и в А и С. Куда же ей идти при выполнении? Так нужно чтобы функции 2 уровня использовали в алгоритме функции 2 уровня.

Это можно представить так:
Функции на 2 уровне содержат в алгоритме функции 3-го уровня. В виде только основной ячейки функции – только для связей потока управления и потока данных (результатов и аргументов).
Собственно 3 уровень создается интерпретатором при вызове этой функции. Это аналогично вызову в исполняемом коде, когда функция сполняется изолированно от семантического контекста.
Таким образом, алгоритм функции содержит объекты функции, которые имеют вход и выход управления, вход аргументов и выход результатов. Любые связи с глобальными данными, существующие внутри функции, не видны снаружи.
При исполнении функции интерпретатор создает ее структуру и исполняет, затем возвращает результаты и уничтожает структуру функции. (Можно ее не создавать, а просто интерпретировать)
Рекурсивные функции – сами себя вызывают – погружают в рекурсию интерпретатор. Ведь тело-алгоритм на уровне 3 не существует в системе, а создается динамически. То есть, рекурсивные функции будут работоспособны.

Константы – в алгоритме на уровне 2 заявлена константа, например, число 7. Это на уровне 3 копируется константу=7 и так работает дальше.
Эта константа есть класс целочисленных констант, для которого значение не задается – абстрактный класс.
Все аргументы – ячейки. Есть передача по ссылке – то есть, передеют саму ячейку. Есть передача по значению – передают копию ячейки. Надо определиться, когда нужна копия, когда оригинал.

ТранзакцияСолюшена – каждая функция должна полностью откатываться.

rel://files/мет5.png


++++ Заметки О Выполнении Задач
Из wiki:///V:/МоиПроекты/SIM/SimWiki/SimWiki.wiki?page=ЗаметкиОВыполненииЗадач
Это сырой материал, его надо переработать, доописать свойства сущностей и раскрыть затронутые темы.

ИИ нужен для того, чтобы собирать знания и выполнять поставленные перед ним задачи. Причем содержание и обслуживание базы знаний тоже требует наличия развитой технологии выполнения задач.

Задача, вообще говоря, всегда состоит в том, чтобы получить новое состояние какой-либо системы сущностей. Эта система сущностей обычно существует в реальном мире, а в разуме она представлена логической моделью, которая должна отражать состояние реальной системы.

Задача должна быть классифицирована (каким образом?), чтобы можно было выбрать метод ее решения/исполнения.
Метод должен быть уже известен. Эти методы или перечислены прямо в алгоритме, как А или Б или С, или подбираются из уже известных методов с помощью механизма симуляции исполнения и контроля результата.
Выбранный метод снабжается аргументами и исполняется. Результат сравнивается в процессе исполнения и оценивается пригодность метода для решения поставленной задачи.
(Следует отметить, что подробный [Лог] реальных выполняемых человеком дел должен дать достаточно информации о процессе выполнения задач, выборе вариантов, и неочевидных этапах и ситуациях при выполнении работы. Для получения такого [Лог]а нужно разработать Органайзер, где задачи представлены алгоритмами, чтобы пользователь создавал алгоритм задачи и работал по этому алгоритму.)
Таким обраом, алгоритм задачи не исполняется непосредственно, как машинный код, а исполняется под наблюдением. Наблюдение оценивает текущее состояние объекта действия и сравнивает его с эталонным, ранее запомненным состоянием в этой точке алгоритма. И соответственно, разрешает продолжение исполнения алгоритма или прерывает алгоритм. Тут нужен и алгоритм (как поток управления и потоки данных) и запись процесса его исполнения, чтобы сравнивать и оценивать действенность метода.

+++++Выводы
* Для выполнения задач используются алгоритмы, в своем текущем виде алгоритмы достаточно совершенны для такого использования.
* Исполнение алгоритма должно сопровождаться наблюдением для оценки исполнения и сбора полезных данных, накопления опыта.   
* Метод (алгоритм) выбирается из имеющихся подобно тому, как выбираются предметы для выполнения задачи. Вероятно, оценивая признаки предмета на соответствие некоторым условиям. Вероятно, это такой универсальный способ для всех сущностей мышления.
* Информация, полученная в процессе наблюдения, записывается в некоторый поток и хранится связанно с исполнявшимся алгоритмом. Это, в общем, можно сказать, рабочая копия алгоритма, исполняемая и дополняемая данными наблюдений об исполнении. Можно представить себе это так: Что-то вроде [Лог]а, привязанного к процессу выполнения алгоритма. Или объединенного с ним. Алгоритм как шаблон - блок-схема а [Лог] - слой-калька поверх него, на нем записываются значения переменных и всякие попутные соображения. Хотя соображения не могут в такой схеме быть попутными - они либо в алгоритме, либо их не может быть. Зато могут быть данные наблюдений, и действия по их обработке. И вот они взаимодействуют с алгоритмом и должны отображаться на этой кальке. То есть, калька отображает два процесса: процесс исполнения алгоритма и процесс наблюдения алгоритма. И эти процессы взаимодействуют между собой. И все это надо хранить как единицу информации, в одном потоке. Тут важно придумать, как это можно сделать. 

+++++Абстракция метода
1)операция - информация о типе производимой операции. Возможно, ссылка на надкласс более общего метода. Также, возможно, некоторые дополнительные сведения о операции... 
2)аргументы - инф-я о количестве аргументов, их типе, допустимых значениях, ... 
3)результат - инф-я о результате операции, типе, допустимых значениях, достоверности, ...
4)описание метода - условия применения, история применения, степень достоверности, точность, ...

Можно поискать похожее описание методов в разных областях науки (медицина, экономика, математика, физика) и собрать все атрибуты описания воедино. Обобщить, и т. д.
Пока так:
- абстрактное представление операции
- правила, описывающие результат операции
- правила, описывающие применимость метода

+++++Методы:
- отвязать методы от классов
- организовать вертикальные связи между методами подобно классам - иерархию абстракции методов
- горизонтальные связи - используемые классы (уточнить концепцию)
таким образом, у методов есть ID, по которому их можно найти в БД,
то есть, потребуется аналог CLink для связи между методами.
Если выделить для методов служебный classID, то можно использовать CLink - но поскольку код для связей методов все равно писать отдельно, то нет смысла. Лучше создать новую структуру.
Потребуется связь класс-метод (пока неясно, как это будет выглядеть)

2 варианта использования методов:
Когда методы были жестко сопоставлены классу, этот вопрос не возникал. Сейчас методы предлагается сделать самостоятельными, и использоваться они могут несколькими классами, в том числе производными от абстрактных.

1 код выбирает метод и типы аргументов.
2 аргументы объединяются в комплекты типов аргументов (КТА). КТА образует вариант использования метода. КТА включает в себя типы аргументов и результата метода. У каждого метода может быть несколько КТА. 
Метод должен иметь имя и комментарий, описывающие его назначение для пользователя.
Метод может принимать абстрактный класс в виде аргумента. Метод обычно использует аргументы - объекты классов, но возможно указать аргументом абстрактный класс.

Должен ли метод принимать Y-подклассы при проверке типов аргументов? То есть, если аргумент метода - абстрактный класс, а этот метод вызван с аргументом - подклассом, как обрабатывать?
а) отказать из-за несоответствия типов.
б) найти и вызвать Y-нижележащий метод, подходящий по типам.
в) принять аргумент.  

Еще надо как-то хранить историю действий по выбору метода, для оптимизации, отладки, обслуживания структуры методов.

В целом, реализация методов на С# - неправильно, так как операции должны выполняться самой структурой, классами, образующими эти данные.
Сейчас это делается искусственно, поэтому могут возникнуть сложности в реализации.
Нужно ли создать также списки связей метода с методами, использованными внутри него? 
	Вообще, можно последовательность операций метода заменить на граф, и это лучше впишется в концепцию системы. Но пока неясно, как это сделать.

Поскольку пока нет опыта работы с метаклассами, трудно определить взаимодействия и строение новых частей системы.
Предварительно:

Method: 				класс метода
YupLinkM	list<MethodLink>  	список связей с надметодами
YdownLinkM	list<MethodLink>	список связей с подметодами
classIDs	list<ClassLink>		список связей с вызывающими классами
KTAlist		list<KTA>		список КТА
... 					other members

MethodLink:				Класс связи между методами
srcId		methodId		Id исх метода - при XML можно исключить для экономии памяти, для SQL оно надо для поиска по таблицам.
dstId		methodId		Id конечного метода
dstMethod	Method			ссылка на конечный метод в памяти - для ускорения доступа
...					другие члены

ClassLink:				класс связи метод-класс
classId		CID			Id класса
methodId	methodId		Id метода
DstAddr		Object			адрес класса или метода для ускорения доступа
...					другие члены

KTA:
argList		list<argument>		список аргументов метода
...					другие члены

