++ Доки Тапп Новые

002
Поскольку нельзя различить пользователя контейнера А из контейнера Б, то предлагается считать контейнеры за пользователей по правам доступа.
Это будет проблематично. У контейнера А может быть много разных пользователей, и права пользователя контейнера А на доступ к Б могут отличаться от прав этого же пользователя на доступ к Б.

С правами пользователей надо думать. Тут много проблем.

Контейнеру еще надо хранить список пользователей и их права на операции.
На одном только сервере их проверять недостаточно:
 - операции включают в себя другие операции.
 - методы вообще нарушают всю безопасность – их надо распределять по группам и каждому прицеплять инфу о разрешения для групп. Это проблема.  

Представим контейнер А, например, математика.
Есть пользователь а, который имеет доступ на чтение структуры.
Есть пользователь б, который может читать структуру и запускать методы.
Есть пользователь в, который может читать структуру, запускать методы, изменять свою часть контейнера А. 
(То есть, элементы структуры должны иметь владельца и категорию доступа. Владелец-Группа – Все, как в ACL)
Есть пользователь с,   который может читать структуру, запускать методы, изменять свою часть контейнера А, изменять все остальное.
- Тут мног творчества получается. Пока в системе нет владельца и ACL. Если вводить владельца, то его надо регистрировать где-то, чтобы иметь его ACL.
Пользователь может иметь свою часть структуры в контейнере и иметь доступ к общей части контейнера. Тогда пользователь может иметь части в нескольких контейнерах и связывать их между собой. Тогда идентификация между контейнерами должна быть единой. Пользователь регистрируется и получает ИД где-то на каком-то менеджере.
Таким образом, права между контейнерами заменяются на права пользователя к контейнеру А и к контейнеру Б.
И есть центр – менеджер, где регистрируются пользователи и серверы-контейнеры. Ячейки и связи хранят ИД владельца, ACL итд.
Пользователи работают с контейнерами на основании своих прав а не отношений между контейнерами.


Теперь можно рассмотреть цепочку.
Пользователю доступен метод в А, который использует что-то из Б. Контейнер Б недоступен пользователю. Метод из А тоже будет непригоден для пользователя.
Варианты решения проблемы:
- имперсонификация пользователя – подмена  пользователя.
- вывод сообщения о недостатке прав на Б вместо исполнения метода.
Аналогия с сетевыми службами – можно поискать там решения.

Контроль ACL предполагает, что функциям будет доступен ИД пользователя – как минимум, для доступа к данным ячеек и связей, операциям и прочему подобному.
Тогда надо ввести глобальный сеанс пользователя, в котором хранится ИД пользователя , и каждый код его может прочитать, соотнести с группой и ACL элемента.
Этот сеанс надо держать пока пользователь работает с контейнером.
А пользователь может не завершить сеанс, тогда сеанс повиснет и БазаДанныхСолюшена будет несогласованной.
- можно откатывать изменения в незавершенных сеансах. То есть, пользователь работает этапами, фиксируя завершение этапа.
- можно вести [Лог] для каждого пользователя или делать выборку из общего [Лог]а (это лучше) чтобы пользователь видел историю своей работы.

Недостаток ACL – пользователь не может управлять доступом к своим данным, кроме как выложить их в общий доступ.
Можно предложить УК сущностям прицеплять разрешенных пользователей как ячейки, через связи.
Завести ячейки, представляющие пользователей, и прицеплять к ним сущности, которым нужно сделать такой доступ. Каждой сущности можно таким образом описать пользователей и их права доступа. Только тогда связей будет очень много, лучше просто поле ID ячейки для этого сделать в ячейке, как уже в связях применяется.
Тогда пользователей всей системы тоже хранить в виде ячеек в отдельном контейнере/ сервере.

006
Функция создания ресурса требует ПользовательскаяКонцепцияСолюшена.
Консольный навигатор требует язык описания команд.
Навигатор требует концепцию представления ячейки и ее связей.
Приложение-диаграмма требует концепцию представления ячеек и связей.
Требует формат диаграмм для их хранения.
Приложение-справочник или каталог требует ПользовательскаяКонцепцияСолюшена, файлы ресурсов, концепцию представления структуры данных.

Каталог радиодеталей с даташитами и параметрами, присоединяемыми файлами, картинками, заметками.
- представление каталога?
А) ярлыками-ячейками и категории-оси связи
Б) гиперссылки-ячейки и категории-связи
В) страницами представлений, HTML, IIS, методы ячеек.
Вообще, это не структура представлений, а структура данных. Представление генерируется отдельно.

008

 rel://files/доки.jpg

-World  - начало структуры
- служебная часть структуры System
- коллекция ячеек типов ячеек Type
  - ячейки типов ячеек
- коллекция ячеек типов данных ячеек Datatype
  - ячейки типов данных ячеек
- коллекция ячеек состояния ячеек  State
  - ячейки состояния ячеек
- коллекция ячеек типов связи Axis
  - ячейки типов связи
- коллекция ячеек состояния связи State
  - ячейки состояния связи
- специальная ячейка Nothing

010

Ресурс: ячейка + файл.

Ячейка: имя=имя файла, тип=ресурс файл, данные=значение ResourceFileId, тип данных = ResourceFileId  идентификатор ресурса.

Создание:
Аргументы: файл.
-помещаем файл в ХранилищеРесурсовСолюшена
- получает ИД файла
- создаем ячейку
- вписываем имя, описание
- значение = ИД файла
- тип значения = ResourceFileId  идентификатор ресурса  (CellId)
- тип ячейки = файл ресурса (CellId)

Удаление:
-удаляем ячейку
- удаляем файл


Иерархия абстракции типов: (Ячейка типа ячейки) Тип файл ресурса => Тип файл ресурса pdf.

rel://files/доки1.png

World – начальная точка структуры
System – служебная часть структуры
LinkStates – коллекция состояний связей 
LinkAxises – коллекция осей связи
DataTypes – коллекция типов данных ячейки
CellTypes – коллекция типов ячеек
CellStates – коллекция состояний ячеек
CellState – базовый класс состояния ячеек. Все состояния ячеек являются производными от этого класса.
Пока из типов связей вводим абстракцию и агрегацию.
Ячейки-коллекции элементов используют агрегацию. В коллекцию могут входиь все ячейки данной области, или только главные, или только конечные – надо потом определиться. Коллекция служит точкой обзора в данной области. Ячейки области связаны междусобой отношениями.
Nothing – служебная ячейка, представляет идентификатор для использования в элементах, где нельзя назначить идентификатор, но он необходим.
Username  -  ячейка, обозначающая пользовательскую часть структуры. В этой части пользователь хранит свои данные.

0014

Наброски концепции ресурсов.
Ресурс в структуре представлен ячейкой типа Resource или производной от нее. Тип данных ячейки ресурса представлен производным от некоторого типа данных.
Тип данных ячейки ресурса:
А) это идентификатор файла ресурса.
Б) это строка пути к файлу ресурса.

Таким образом, надо разработать иерархию типов данных ячеек. Для начала можно просто объявить нужные типы, а иерархию прицеплять потом, когда она будет удобна. Однако можно и не прицеплять иерархию, она будет существовать независимо.

Файл ресурса в системе сам по себе не нужен, кроме частичных снимков. Файл нужен пользователю. Он должен отображаться где-то, чтобы пользователь мог выполнять над ним действия. Например, открыть и прочитать. Файл рассматривается как внешние данные, изолированные от структуры.
Файл ресурса может входить в группы по содержанию, смыслу файла итд. В процессе организации ресурсов можно выделить:
- классы сущностей – типы ячеек
- сущности – ячейки
- отношения – связи
- классы отношений – типы связей
Для такого выделения надо описать концепцию ресурсов в рамках ПользовательскаяКонцепцияСолюшена.
Важно здесь то, что создание системы этих сущностей позволит выявить законы, по которым они создаются. Это позволит понять принципы, по которым создаются такие системы, принципы анализа информации и ход этого процесса. А это позволит создавать операции, которые будут выполнять некоторую часть необходимой работы, такой небольшой интеллект.

Итак, файл сейчас должен только выдаваться пользователю. Наибольший смысл здесь в связывании файла с сущностями структуры.
Например, БД деталей. Она должна содержать:
- детали, имеющиеся в наличии
- детали существующие, которые можно приобрести
- справочные данные на детали
--параметрические данные
--корпус, цена
--внешний вид – фото, рисунок
--источник
--документы, даташиты
--дополнительные материалы и ресурсы
---апноуты
---софт
---библиотеки и примеры кода
--ассоциированные детали

Логично будет, что каждый класс деталей может содержать подклассы, каждый класс имеет собственную организацию.

Сама эта организация может быть заимствована из инета, на сайтах производителей бывают удачные решения такой организации.
Таким образом, радиодетали очевидно будут классифицированы, затем по классам созданы объекты, забиты данными, затем объекты связать ассоциативными связями в группы. Каждой детали сопоставлены документы итд.
+) Получится модель, которую можно использовать в работе.
-) Очень много работы при создании, при переделках структуры и ее поддержании.
--надо автоматизировать операции, но для этого нужны методы.
Можно отработать эту организацию на небольшой модели – по несколько деталей каждого класса.
1)	выявить и перечислить классы деталей
2)	описать каждый класс и его структуру
3)	описать типы данных класса и свойств класса
4)	описать иерархию классов
5)	выписать и определить назначение типов сущностей и типов связей
6)	создать структуру классов
7)	подобрать реально полезные объекты для классов, чтобы работа с моделью действительно шла.
8)	Все действия с моделью записывать в специальный журнал-лог. Это позволит понять ход работы.
9)	Все идеи по ходу работы записывать в журнал-лог, но не реализовывать, пока не возникнет тупик. Так будет проще довести работу до конца.
10)	После того как накопится достаточно материала, подвести итоги, отметить верные и неверные решения.
11)	 Создать операции, автоматизирующие работу. Необходима концепция методов.

017
Всего есть два основных варианта:
1)Тапп 1 и 2.  Создаем класс сущности, ее свойства обозначаем связями с другими классами. Затем создаем копию этой структуры для хранения объектов сущности.
2) Neo4J. Свойства сущности обозначаем типами связей, данные сущности храним в ячейках.

1 вариант удобен, если для всех деталей свойство представлено одним и тем же классом. Неудобен, когда свойство представлено объектами разных классов, которые не принадлежат общему суперклассу.
Удобен при прямом указании. Неудобен при косвенном указании. Косвенное указание это «В качестве основания применена керамическая статуэтка». Прямое указание: материал-алюминий.

2 вариант 
+) не требует предварительного создания классов
+) свойствами могут быть любые классы или несколько классов
-) невозможно проверитьтипы данных свойств, поскольку нет четкого шаблона – что это.
-) много типов связей будет.
Наверно, есть какой-то средний вариант, который :
-представляет семантические слоты свойств сущности
- обеспечивает гибкость и типизацию свойств.

Эволюционный подход:
1)	свойства просто прицеплены к сущности ассоциативными связями
2)	классификация поэтапная. Несоответствия обрабатываются отдельно, по мере обработки всей структуры. Часть связи остается нетронутыми, пока не будет найден подходящий способ организации.

Распознавание потока – подход
Свойства начально классифицируются, прицепляются и обрабатываются как см выше. Поток хранится и несет информацию для последующего анализа семантики. Остальное – как эволюционный подход.

Очевидно, цена и сумма денег относятся к одному и тому же суперклассу, но могут храниться раздельно. Это поскольку табличные данные уже прошли обработку и абстракцию, а реальная модель есть часть общей структуры.

Таким образом, сначала заносим все данные в ячейки, связываем их по варианту 2, потом проводим классификацию и переводим в вариант 1 то что возможно.

019
Распознавание потока – подход.
Изначально данные о сущности входят в систему в виде многомерного потока данных. Когда система умеет выделять характеристики, она умеет выделять из потока параметры по каналам. Например, вес, цвет, твердость, запах, шероховатость итд. Сущности классифицируются по этим параметрам по усредненной шкале.

rel://files/доки3.png

Одновременно с этим, хранится полный поток сущности.

По мере освоения система набирает много сущностей и проводит сравнение и анализ, добывая недостающие данные из потоков восприятия сущностей. Это обычное сравнениес поиском аналогий. Так появляются классы сущностей, когда аналогии группируются в абстракцию.
В дальнейшем процессы стандартизируются и формализуются, совершенствуются.

Для каждого класса объектов существует свое характерное свойство или набор свойств, которое помогает идентифицировать объект.
Например, яблоко – оно может быть разного цвета, веса размера, но оно идентифицируется по характерной форме и характеру поверхности и запаху. Конечно, в памяти хранятся данные о десятках яблок. И вероятно, один и тот же механизм сжимает эти представления, создает логические модели, находит аналогии, формирует общие усредненные характеристики объектов этого класса. Эти характеристики используются для идентификации объекта в потоке. Что-то вроде: Если А=0.1..0.11; В=0.5..0.8;С=0.95..1.0, то это вероятно, яблоко.

Тогда для изучения этого механизма нужно смоделировать поток. Пока это сложно. Проще отправлять на анализ уже готовые данные об объектах, но надо учитывать, что некоторые детали такого потока данных отсутствуют – поток не полный, поэтому созданные модели анализа будут отличаться от ожидаемых.

То есть, входной поток упрощенно будет как метроном.
Система должна уметь записывать входной поток.
Система должна уметь анализировать входной или сохраненный поток.
Система должна уменьшать затраты на работу с событиями.
Система должна выделять событие из потока.

В этом примере каждое событие запускает работу над ним. Поскольку события регулярны, они рано или поздно приводят к формированию механизмов, если их возможно сформировать.
И если общее состояние системы немного изменяется циклически.

Работа:
Событие – записываем входной поток.
Событие – записываем входной поток.
Событие – записываем входной поток.
…
Устали записывать – записываем более абстрактно, теряя детали.

Каким-то образом вместо записывания просто находим подходящий поток
- устаем, теряем детали. Ошибаемся при поиске.
Сравнение выдает несоответствие.
- а почему проводится это сравнение?
-Как в результате формируется механизм реакции?
-Что вообще представляет из себя эта реакция?















