++ Концепция Много Пользователей
[//СБОР МАТЕРИАЛОВ] - многопользовательская концепция недостаточно проработана, и не будет пока реализована в версии Тарр Bar. Но надо навести в ней порядок, на будущее.
[//ПЕРЕДЕЛАТЬ] - надо переработать тексты с учетом существующих решений.
++++Описание концепции
Описывает средства поддержки нескольких пользователей системы.
Так как для множества пользователей весьма вероятны разные языки, требуется еще КонцепцияИнтернационализация.

+++Состояние
* Концепция намечена на будущее,сейчас недостаточно опыта работы с Тапп, чтобы ее проектировать.
* Концепция совершенно новая, много сырых предположений. Тут много работы по наведению порядка. Сама тема очень сложная и малознакомая.
* Хотя есть некоторые решения, они рассеяны в тексте.
* Есть проблемы в многопользовательскости - оно предполагает также (хотя не обязательно) одновременную работу пользователей, многозадачность. А вот эта тема пока не изучена.
    * *Поддержка нескольких пользователей требует либо серверную версию Движка, в которой пользователи разделены сетевым интерфейсом и поочередно используют Движок монопольно, либо многопоточной версии Движка, а эта тема совсем не изучена и требует несколько другой архитектуры Движка.*  
* Предлагается концепцию многопользователей отрабатывать после создания внутрипроцессной версии Движок. Потому, что там большая часть непонятных сейчас мест будет уже решена. И можно будет проверить идеи непосредственно в СтруктураСущностей, а не умозрительно, как сейчас.
* Пока что можно просто свести сходные идеи вместе, чтобы они меньше объема занимали и лучше читались. И отобрать полезное для КонцепцияПользователи - она неполная и ее надо расширять.
* 26.06.2016 22:17 Сейчас из этих материалов надо построить:
    * Процесс входа пользователя на сеанс работы: от регистрации до передачи идентификатора пользователя в Движок при вызове функции Движка. 
    * Процесс определения прав пользователя при доступе к ячейке при выполнении функции Движка.
    * а то я так не сдвинусь никуда в этом ворохе обстоятельств. 


+++Вопросы
* todo.концепция.пользователи: Что входит в данные о пользователе Тапп в РегистраторПользователей?
    * ИдентификаторАгента. 
* todo.концепция.пользователи: Что входит в данные о пользователе в Солюшене?
* todo.концепция.пользователи: Где хранятся данные о пользователе Солюшена?
* todo.концепция.пользователи: Поскольку РегистраторПользователей глобальный, у него должен быть глобальный регистр.
  Он не может размещаться в КаталогСолюшена. Где должен размещаться этот регистр?
    * Фактически это сервер, локальный или сетевой.
    * Можно реализовать как отдельно устанавливаемая служба Виндовс на локальном компьютере.
    * Поддержка нескольких пользователей и РегистраторПользователей востребована только на СервернаяВерсияДвижка, как серьезное промышленное решение.
        * В этом случае РегистраторПользователей должна быть отдельная служба Виндовс, сервер.
* todo.концепция.пользователи: Эти Регистраторы являются частью Движок dll? Или они отдельные и их версии могут не совпадать?
	* Хорошо бы их все в одну dll впихать. 
        * Но регистр удобно держать на SqliteСУБД или AccessСУБД, а ее коннектор тогда будет загружаться в процесс вместе с Движок и жрать память. 
        * Может, динамически подгружать коннектор для Регистратора? 
        * Нет, он же используется при начале работы [Движок]а, придется ее все равно загружать. А потом из процесса не выгрузить никак. Сборки нельзя выгрузить из процесса. Уточнить это.
    * Это зависит от версии [Движок]а. Для внутрипроцессной версии [Движок]а обязательно должна быть одна dll.
        * А где в внутрипроцессной ВстраиваемаяВерсияДвижка необходимы несколько разных пользователей?  
    * Для РегистраторПользователей пока нельзя придумать решение. 
* todo.концепция.пользователи: Что входит в данные СеансПользователя?
* todo.концепция.пользователи: Что хранится в ячейке? ИдентификаторВладельца? Некие данные о правах доступа пользователей?
* todo.концепция.пользователи: Что входит в набор данных о правах доступа пользователей в ячейке? Тут много работы.
* todo.концепция.пользователи: Чем пользователь Тапп отличается от Пользователя Солюшена? Можно ли их внести в глоссарий как разные сущности?
* todo.концепция.пользователи: Пользователь будет приходить в регистрацию нового пользователя Тапп и/или пользователя Солюшена через Навигатор или через стороннее приложение, работающее с Солюшеном.
	* Как это выглядит?
	* Как Движок должен поддерживать это? Чтобы предоставить приложениям удобный набор функций для работы с Солюшеном, скрыв детали реализации.  



+++Материалы
* См. КонцепцияПользователи - надо взаимно дополнить с этим.
* ВстраиваемаяВерсияДвижка - Когда пользователь использует локальный внутрипроцессный контейнер, это один случай. 
    * Тут права пользователей не существенны, пока вроде бы.
    * Тут важна скорость работы и объем занимаемой в процессе памяти.
    * Но все же разделением прав пользователей не следует пренебрегать, так как тут тоже может быть несколько пользователей. И этот контейнер тоже может быть (или стать в будущем) частью СерверСолюшена.
* СервернаяВерсияДвижка - Когда пользователь использует Солюшен в составе МногоконтейнернаяСистема, это другой случай. 
    * Тут многопользовательская серверная сетевая распределенная система, она предполагает более сложный подход к пользователям.
    * Тут скорость работы не так важна, так как она ограничена задержками сетевого трафика. 
* Предлагается поэтапно разрабатывать и улучшать [Движок]. Сначала разработать концепцию безопасности СервернаяВерсияДвижка, потом перенести ее на ВстраиваемаяВерсияДвижка, потом реализовать, потом провести опытную эксплуатацию модели, потом усовершенствовать и разработать СервернаяВерсияДвижка. 
* todo.концепция.пользователи: Надо сначала представить себе, что это вообще такое будет - многопользовательская СтруктураСущностей? Что в ней будут делать пользователи, что там будет храниться? Почему пользователи пожелают там заводить аккаунты и собственные ПринадлежащийПользователюУчастокСтруктурыСущностейСолюшена? Что для этого нужно реализовать в [Движок]? А сейчас, без этой информации, вся эта моя работа может оказаться невостребованной.   
* В ВстраиваемаяВерсияДвижка механизмы РегистраторСолюшенов и РегистраторПользователей придется встроить в [Движок] как самостоятельные механизмы, обращение к которым выполняется не через сеть, а вызовом их функций АПИ. Общая схема взаимодействия будет, вероятно, такой же, как и в СервернаяВерсияДвижка.
    * Поскольку ВстраиваемаяВерсияДвижка будет хранить настройки и реестры этих РегистраторСолюшенов и РегистраторПользователей, ее ФайловаяСистемаСолюшена будет отличаться от СервернаяВерсияДвижка.
    * Нет, скорее всего, механизмы РегистраторСолюшенов и РегистраторПользователей придется реализовывать отдельно от [Движок]. Наверно, как службы Виндовс. Тогда они будут глобально доступны; и их можно встроить в  dll [Движок]а; они не будут занимать память процесса; не будет несовпадения версий с остальным функционалом [Движок]; ФайловаяСистемаСолюшена будет без отличий. 

++++новое
* Когда создается сеанс пользователя при входе в Солюшен, Движок отправляет в РегистраторПользователей логин и пароль, введенные пользователем, чтобы получить от него данные АккаунтПользователя, или отказ.
* Если АккаунтПользователя существует, то его данные пишутся в СеансПользователя. Затем в СеансПользователя добавляются данные пользователя Солюшена.
	* А где они хранятся? А что в них содержится?
	* Если данные пользователя Солюшена хранятся в Солюшене, то где?
		А) в отдельной БД или ХМЛ-файлах.
		Б) в отдельной таблице БД Солюшена.
	* а как это будет в СолюшенБезБД?	
* Как происходит доступ к РегистраторПользователей?
Это просто монопольный доступ к файлу регистра, который лежит по некоторому глобальному пути.
	* Но не в ProgramFiles инсталляции Движка, так как там запись запрещена.
	* Путь можно прописать в реестре виндовс, но для этих регистров нужен собственный, выделенный каталог в Виндовс.
	* Можно устанавливать Движок в отдельную папку вне каталога ProgramFiles, где у пользователя есть права на запись. Как это для Линуксовых программ сейчас у меня сделано.
    * Хорошо бы разобраться, как это сделано для программ типа MySqlСУБД, которые там же в ProgramFiles держат свои базы данных.
* Лучше все-таки сделать Регистраторы отдельным приложением (-ями), и повесить их как службы Виндовс, запускаемые вручную.
    * Но сначала надо определить, что и как они будут получать и выдавать. Через сокеты TCP или именованные каналы. Как плеер в XProject.

++++Сущности предметной области
* СтруктураСущностей
* ЭлементСтруктурыСущностей
* [Солюшен]
* МногоконтейнернаяСистема
* СерверСолюшена
* РегистраторСолюшенов
* РегистраторПользователей - механизм, управляющий идентификацией и правами пользователей
* МенеджерДоступа
* АккаунтПользователя
* ИдентификаторПользователя
* СеансПользователя  - сеанс работы пользователя с [Солюшен]ом.
* ИдентификаторСеансаПользователя
* ИдентификаторВладельца
* ПрофильПользователя
* ШаблонПрофиляПользователя 
* ПринадлежащийПользователюУчастокСтруктурыСущностейСолюшена - персональный участок для пользователя Солюшена.
* ОбщийДляПользователейУчастокСтруктурыСущностейСолюшена - общий участок для всех пользователей Солюшена.
* ПраваДоступаПоУмолчанию - это ПраваДоступа, предварительно назначаемые для вновь создаваемого ЭлементСтруктурыСущностей.  
* ПраваДоступа - набор прав пользователя к некоторому ЭлементСтруктурыСущностей.
* ГруппаПользователей - совокупность пользователей по сходному набору ПраваДоступа. Это сущность из концепции ACL.
* ВладелецЭлементаСтруктуры - пользователь, считающийся владельцем ЭлементСтруктурыСущностей. Это сущность из концепции ACL. 
* ГруппаПравДоступа - это ПраваДоступа ГруппаПользователей.
* КэшГруппПравДоступа - это механизм быстрого доступа и проверки ПраваДоступа.
* ИдентификаторВладельца - ИдентификаторПользователя пользователя ВладелецЭлементаСтруктуры.
* ИдентификаторПравПользователя - некий хеш ПраваДоступа пользователя.
* ГруппаВсе - обозначает всех пользователей [Солюшен]а.
* ЯчейкаПользователя - ячейка, представляющая пользователя в целях описания его ПраваДоступа. Для схемы с описанием ПраваДоступа через ячейки и связи.

++++Варианты концепции
Рассматривается два варианта реализации прав доступа: стандартная и на ячейках. Но они в текстах перемешаны, их надо отделить друг от друга. 
Кроме этого, в текстах есть проработка варианта с правами контейнеров а не пользователей. Ее тоже надо отделить как-то.
+++++Общие черты
* Тут надо описать отдельные детали и несколько вариантов общей схемы. Чтобы проще было их рассматривать потом и собирать что-то.
* Введение ПраваДоступа пользователей в концепцию [Движок] полезно:
    * Подготовка к серверной многопользовательской версии.
    * Защита МногоконтейнернаяСистема от ошибок методов и ошибочных действий пользователя.
* В целом, перевод системы Тарр из настольной в серверную - штука сложная, и лучше ее отложить, тем более, оно не скоро потребуется. Но придумать какой-то фундамент надо для уменьшения последующих переделок.

* Пользователем тут обычно считаются люди. Но пользователем (Агентом) может быть также метод из СтороннийСолюшен, [Оптимизатор] или еще какой-либо процесс. Всем им нужны не только атрибуты пользователя, но и специальные меры, которые лучше сразу предусмотреть, чтобы потом меньше было проблем и переделок.

* МногоконтейнернаяСистема в этой части состоит из РегистраторСолюшенов, РегистраторПользователей и нескольких СерверСолюшена. Все эти элементы связаны сетью передачи данных.
* РегистраторСолюшенов (ранее назывался сервер имен) обеспечивает поиск СерверСолюшена по ИдентификаторСолюшена.
* РегистраторСолюшенов контролирует доступность и параметры СерверСолюшена, управляет их ИдентификаторСолюшена, может запускать процедуры обслуживания СерверСолюшена.
* РегистраторПользователей обеспечивает идентификацию пользователей для всей МногоконтейнернаяСистема.
* Вероятно, авторизация пользователей при доступе к СерверСолюшена тоже проходит через РегистраторПользователей.
* СерверСолюшена хранит СтруктураСущностей.
* Каждый [Солюшен] содержит свой набор ПраваДоступа для каждого зарегистрированного в нем пользователя.
* Пользователь может иметь в каждом [Солюшен]е доступ к какой-то части СтруктураСущностей согласно ПраваДоступа.

* Пользователь использует АккаунтПользователя в РегистраторПользователей для входа на СерверСолюшена.
* Пользователь работает с СерверСолюшена внутри СеансПользователя.
* Пользователь или РегистраторПользователей использует ПрофильПользователя для хранения индивидуальных настроек пользователя.

* ИдентификаторПользователя надо будет передавать через МеханизмКоммуникацииКонтейнеров в другие [Солюшен]ы. Но не напрямую, чтобы его не подделывали хакеры, а через ИдентификаторСеансаПользователя.
* В [Солюшен] нужно ввести еще МенеджерДоступа и АккаунтПользователя.
* МногоконтейнернаяСистема систему будет конструировать АккаунтПользователя администратора.
* Пользовательскую часть будет эксплуатировать АккаунтПользователя пользователя.
* Методы запускать под АккаунтПользователя, определяющим минимально необходимые ПраваДоступа.

* На РегистраторПользователей можно возложить задачу управления идентификаторами ИдентификаторПользователя и контактными данными пользователей ПрофильПользователя - логин, хеш пароля, емайл, другие сведения.
* Пользователи должны иметь системно-уникальные ИдентификаторПользователя, поэтому им нужен единый механизм управления, а не разнесенный по разным СерверСолюшена.
* todo.концепция.пользователи: Нужно описать примерный перечень ПраваДоступа пользователя в Солюшене. Примерно предполагается, что будут типичные ПраваДоступа и специальные ПраваДоступа.
* Авторизацию пользователя возложить на РегистраторПользователей, и там же сделать ШаблонПрофиляПользователя.
Хотя это все зависит от устройства структур, и пока рано это обсуждать.
    * todo.концепция.пользователи: Что такое ШаблонПрофиляПользователя, зачем он нужен?
* Для единообразного исполнения межконтейнерных методов у пользователя должен быть централизованный АккаунтПользователя. Это позволит избежать авторизации пользователя в процессе исполнения методов.
Однако на каждом [Солюшен]е могут быть свои настройки пользователя - свой язык, свои права доступа, итд. Следовательно, часть настроек пользователя берется из АккаунтПользователя на РегистраторПользователей, а часть - из ПрофильПользователя [Солюшен]а. То есть, данные АккаунтПользователя на РегистраторПользователей переопределяются данными из ПрофильПользователя [Солюшен]а. И надо разработать эти правила переопределения.

* Типично в серверах на каждый запрос пользователя создается отдельный процесс, который обрабатывает данные и возвращает результаты.
* Контейнер загружен в процесс. 
* СерверСолюшена обрабатывает подключение пользователя и его операции, 
* Одновременно с контейнером могут работать несколько пользователей.
* Каждый контейнер устанавливает свои ПраваДоступа пользователя. 
* Пользователи работают с контейнерами на основании своих ПраваДоступа, а не взаимоотношений между серверами контейнеров.
* Хорошо бы пользователю показывать [Лог] его операций, которые лучше выбирать из общего [Лог]а контейнера.

Тогда можно рассмотреть случай:
Пользователю доступен метод Солюшена А, который использует доступ к объектам Солюшена А или Б, на доступ к которым у пользователя нет прав. Метод будет непригоден в этих условиях.
Варианты решения проблемы:
- имперсонификация - подмена пользователя
- вывод сообщения о недостатке ПраваДоступа на Солюшен Б вместо исполнения метода.
Аналогия с сетевыми службами - можно посмотреть способы решения там.

++++++Виды пользователей
Для МногоконтейнернаяСистема предполагаются разные виды пользователей:
* Администратор - АдминистраторМногоконтейнернойСистемы следит за целостностью и согласованностью МногоконтейнернаяСистема.
* Модератор - Он должен следить за работой других пользователей, исправлять их ошибки, но не может выполнять функции Администратора. Это нечто среднее между Администратором и Пользователем по ПраваДоступа, но выделенное в отдельную группу из-за специальных социальных функций.
* Разработчик - РазработчикДвижка и РазработчикСолюшена - Прикладной  программист, использует ApiUserLayer для создания [Метод]ов обработки данных. Пока нельзя сказать, чем он отличается от Пользователя.
* Пользователь - ПользовательСолюшена  - Пользователи используют СтруктураСущностей, запускают [Метод]ы, добавляют и удаляют данные.
* Гость - может просматривать СтруктураСущностей, но не может ничего изменять в ней.
* Чужой - не может получать доступ к СтруктураСущностей.
* Служба - Некоторый механизм, часть концепции Тарр, выполняющий определенную функцию. Например, [Оптимизатор].
* Бот - Некоторый механизм, созданный сторонними разработчиками, выполняющий определенную функцию. Подобен пользователю. 

todo.концепция.пользователи: Надо составить список возможностей пользователя [Солюшен]а. Тогда можно будет проектировать ПраваДоступа и учитывать их нюансы.

++++++Сеанс пользователя
* Контроль ACL предполагает, что функциям ( [Движок]а ?) будет доступен ИдентификаторПользователя – как минимум, для доступа к данным ячеек и связей, операциям и прочему подобному.
* Тогда надо ввести глобальный СеансПользователя, в котором хранится ИдентификаторПользователя, и каждый код его может прочитать, соотнести с группой и ACL элемента.
* Этот СеансПользователя надо держать активным, пока пользователь работает с контейнером.
* Пользователь может бросить, не завершить СеансПользователя, тогда СеансПользователя повиснет, и БД будет несогласованной.
    * можно откатывать изменения в незавершенных СеансПользователя. То есть, пользователь работает этапами, фиксируя завершение этапа.
    * или можно закрывать СеансПользователя по истечении отведенного времени бездействия. Так сделано в WEB.
* можно вести [Лог] для каждого пользователя или делать выборку из общего [Лог]а (это лучше) чтобы пользователь видел историю своей работы.
* Пользователя надо регистрировать где-то, пользователь работает в СеансПользователя. 
* СеансПользователя содержит ИдентификаторПользователя, его группу, эти данные глобально доступны через переменные сеанса СеансПользователя.
* Надо использовать концепцию СеансПользователя - контейнер постоянно загружен в память, а запросы пользователей исполняются и отдаются в течение СеансПользователя. СеансПользователя закрывается, и контейнер закрывается, если нет других пользователей.
* Если пользователь неожиданно прекратил работу, (См. ТемаНеожиданноеПрекращениеРаботыДвижка) БД будет в несогласованном состоянии. Можно предложить разбить работу пользователя на этапы, и каждый этап до завершения можно откатить, а по завершении фиксировать, как транзакцию.
Тогда при обрыве соединения просто откатить изменения СтруктураСущностей до последнего устойчивого состояния.

++++++Регистрация и собственный участок структуры сущностей пользователя
* Эта концепция предполагает, что СтруктураСущностей, созданная одним пользователем, может, при наличии соответствующих разрешений, частично использоваться другими пользователями. Так, пользователь может получать контент (участки СтруктураСущностей), созданный другими пользователями, как естественную часть своей СтруктураСущностей. Бесшовно. И предоставлять, в свою очередь. Как структурированные данные и методы обработки.
Но тут важную роль играют ПраваДоступа, так как они обеспечивают это разделение доступа.
* Пользователь при регистрации получает свой ПринадлежащийПользователюУчастокСтруктурыСущностейСолюшена, в котором хранит свои данные и методы.
* Пользователь, кроме того, может ограниченно использовать ОбщийДляПользователейУчастокСтруктурыСущностейСолюшена, в соответствии со своими ПраваДоступа к нему. Например, использовать общие или системообразующие типы данных, типы ячеек итд.
* Пользователь может достраивать свой ПринадлежащийПользователюУчастокСтруктурыСущностейСолюшена.
* Пользователь может ограниченно использовать некоторые части участков других пользователей Солюшена, в соответствии со своими ПраваДоступа к ним. Эти ПраваДоступа дают ему пользователи-владельцы этих участков.
* Пользователь может иметь свои ПринадлежащийПользователюУчастокСтруктурыСущностейСолюшена в нескольких контейнерах, и естественно будет связывать их между собой, чтобы использовать, поскольку концепция это предполагает. При этом идентификация пользователя должна быть унифицированной для всех контейнеров, то есть, пользователь имеет один и тот же ИдентификаторПользователя на всех контейнерах, а это предполагает единый сервер авторизации пользователей РегистраторПользователей. Пользователь регистрируется и получает ИД где-то на таком РегистраторПользователей.
* Пользователь регистрируется на головном сервере РегистраторПользователей, получает ИдентификаторПользователя, и затем выбирает (или создает собственный?) контейнер и получает доступ в этом каком-то контейнере.
Там он может завести ПринадлежащийПользователюУчастокСтруктурыСущностейСолюшена, и использовать ее и ОбщийДляПользователейУчастокСтруктурыСущностейСолюшена. Также он сможет давать доступ к участкам своей части контейнера другим пользователям, которые есть в этом контейнере или в МногоконтейнернаяСистема вообще.


++++++Модификация ячеек и связей
* Для поддержки многопользователей каждому ЭлементСтруктурыСущностей нужно прицепить ИдентификаторВладельца и ACL вроде линуксового.
* Вместо старого флага ReadOnly в ячейку и связь следует ввести поля ИдентификаторВладельца и ПраваДоступа пользователей на ячейку.
* Имеет смысл зарезервировать поля в ячейке и связи, и хранение их в БД. С реализацией можно определиться позже.
* Проектирование системы контроля ПраваДоступа целесообразно отложить до наличия опыта в работе с МногоконтейнернаяСистема.
* Нужно ли определять доступ пользователя к связям ячеек отдельными дескрипторами?
    * Вывод: неизвестно, надо провести опыты над большой СтруктураСущностей. Пока просто зарезервируем поля. 
    * если да, то даже отображение существования некоторой связи между ячейками будет зависеть от полномочий пользователя. Это удобно, если при помощи связей реализовывать какие-то особые механизмы.
    * если нет, то доступ к связи определяется наилучшим доступом пользователя к ячейкам связи.
* Для ячейки таким образом потребуется хранить 
    * ИдентификаторВладельца
    * ПраваДоступа владельца в виде какого-то набора флагов
    * Идентификатор некоторой сущности, хранящей совокупность ПраваДоступа для разных пользователей.    
* То есть, мы будем хранить в ячейке ИдентификаторВладельца - чтобы пользователь имел свою ПринадлежащийПользователюУчастокСтруктурыСущностейСолюшена и чтобы отделять общее от частного.
* Мы будем хранить список пользователей и их ПраваДоступа, чтобы владелец или администратор мог предоставить, изменить или отозвать доступ к некоторому ЭлементСтруктурыСущностей индивидуально для пользователей или групп пользователей. Этот список пользователей мы будем прицеплять к каждой ячейке. Потребуется также список пользователей по умолчанию, который цеплять к ячейке при ее создании.
* Собственно, тогда не нужно *поле ReadOnly [Ячейка]и*, так как его значение следует из ПраваДоступа пользователя.
* Если у ячейки нет списка ПраваДоступа пользователей, то применяются ПраваДоступаПоУмолчанию соответственно ПраваДоступа пользователя в контейнере.
* Тогда зачем хранить ИдентификаторВладельца ячейки? Можно вынести его в список ПраваДоступа пользователей ячейки.
    * Обдумать.
* Какие ПраваДоступа должны быть у пользователя к ячейке, связи, контейнеру?
* Надо осмотреть соответствующие операции и тогда уже выписать ПраваДоступа.
* Поле ReadOnly из ячейки убрать - оно будет заменено ПраваДоступа текущего пользователя.
    * И что, для разных пользователей ведь разные ПраваДоступа. Тут надо додумывать идею. 
* Добавить поле ИдентификаторЯчейки владельца и поле ИдентификаторЯчейки для ПраваДоступа.
* todo.концепция.пользователи: надо нарисовать такую диаграмму, представить все эти сущности на ней, чтобы понимать, что и как связано и используется. Нарисовать ячейку, прицепить к ней объект ИдентификаторВладельца и объект ПраваДоступа, и нарисовать другие объекты сущностей. И как они взаимодействуют.

++++++Кэширование прав доступа текущего пользователя
* ПраваДоступа работают только в контексте СеансПользователя, поэтому для исполняющегося кода важно быстро определить ПраваДоступа пользователя. Соответственно, их надо организовать. Кэшировать.
 * Добавить в код сущность МенеджерДоступа, который будет содержать КэшГруппПравДоступа пользователя и быстро возвращать разрешение на выполнение операции для ЭлементСтруктурыСущностей.
* Тогда ПраваДоступа к ячейке в СеансПользователя будут зависеть от наличия и строения списка пользователей.
* Просматривать список пользователей в каждом объекте - это медленно. Надо быстрее.
    * кешировать просмотры, так как в сущности каждая ячейка-список ПраваДоступа пользователей является группой, которую в результате анализа можно свести к ПраваДоступа текущего пользователя. 
    * Сопоставить ИдентификаторЯчейки и ПраваДоступа пользователя в некотором КэшГруппПравДоступа для быстрого разрешения запросов. 
    * Этот КэшГруппПравДоступа и его код будет частью СеансПользователя.

++++++Проблемы многопользовательской системы
* Реальной многопользовательности не получается - несколько пользователей одновременно будут исполнять запросы к контейнеру. Это предполагает кучу проблем при работе методов.
* Каждый СеансПользователя включает в себя работу Интерпретатора. 
    * Сессии СеансПользователя  выполняются в разных потоках и в этом не мешают друг другу.
    * Но пользователи в течение СеансПользователя могут изменять данные в МногоконтейнернаяСистема, в ОбщийДляПользователейУчастокСтруктурыСущностейСолюшена, это приводит к различным проблемам.
    * Можно предложить поочередно исполнять запросы. тогда следующий запрос выполняется после того, как завершится предыдущий. 
    * Тогда пользователи будут ожидать, когда запросы завершатся.
    * Иначе придется вводить механизм планирования исполнения запроса с учетом уже работающих запросов. Это сейчас неинтересно.

+++++Стандартная реализация прав пользователя
* Недостаток ACL - пользователь не может гибко управлять доступом к своим данным - он может выложить их в общий доступ или предоставить только своей группе.
* пока информация рассеяна в тексте  

+++++Реализация прав пользователя на ячейках
* Вероятно, ПраваДоступа на доступ к ячейке будут задаваться специальной ячейкой, а в ней уже связями с ячейками ЯчейкаПользователя.
* Можно предложить обозначить пользователей и их ПраваДоступа ячейками, а потом прицеплять их к выбранным сущностям через связи или через поле свойства, как уже применяется для состояний ячеек и связей.
* Недостаток ACL – пользователь, в сущности, не может управлять доступом к своим данным, кроме как выложить их в общий доступ, как минимум, для чтения.
Можно предложить к сущностям прицеплять разрешенных пользователей как ячейки, через связи.
Завести *ячейки, представляющие пользователей*, и прицеплять к ним сущности, которым нужно сделать такой доступ. Каждой сущности можно таким образом описать пользователей и их ПраваДоступа. Только тогда связей будет очень много, лучше просто поле ID ячейки для этого сделать в ячейке, как уже в связях применяется.
Тогда пользователей всей МногоконтейнернаяСистема тоже хранить в виде ячеек в отдельном контейнере или сервере.

++++++Реализация прав пользователя на ячейках
* Это кривое однобокое представление, его надо рассматривать с разных сторон, и лучше всего на реальной СтруктураСущностей.

Систему безопасности организовать так:
К каждой сущности в СтруктураСущностей привязана (без связи) ЯчейкаГруппыДоступа.
ЯчейкаГруппыДоступа принадлежит пользователю-владельцу элемента, и связана с его АккаунтПользователя в контейнере.
Эта ЯчейкаГруппыДоступа представляет для пользователя - некий набор, коллекцию доступных ему сущностей.
Пользователи, также представленные ячейками, связаны с ЯчейкаГруппыДоступа связями, которые определяют группы ПраваДоступа пользователей, вроде МожетЧитать, МожетПисать, МожетИсполнять итд.
(Группу доступа надо переименовать, так как с точки зрения любого пользователя это группа доступных объектов.)

Поскольку ЯчейкаГруппыДоступа связаны с *ячейками пользователей*, пользователи могут посмотреть эту структуру и попытаться ее изменить.
Поскольку ЯчейкаГруппыДоступа принадлежат пользователю А, а другие пользователи не имеют ПраваДоступа на операции с ними, то другие пользователи не могут изменить содержимое ЯчейкаГруппыДоступа. Однако, это содержимое не имеет значения, имеет значение только тип ячейки - ЯчейкаГруппыДоступа, ее связи и методы. Если другие пользователи не могут создавать связи с ЯчейкаГруппыДоступа, то и добавить себе ПраваДоступа они не смогут.
Правило: для создания связи нужны ПраваДоступа на создание связи в обеих ячейках.
Правило: для удаления связи нужно разрешение на удаление связи в обеих ячейках.
Созданная связь принадлежит создателю.
Это правило не позволит создавать связи с ячейками других пользователей для указания их в *группах доступа*. То есть, это фундаментальное правило, и его в данном случае надо как-то обойти.

Пользователь может создать свою *ячейку, представляющую другого пользователя*, и к ней прицепить связи. Такой ячейке нужен ИдентификаторПользователя другого пользователя. В общем, вроде бы реализуемо.
Надо все это обдумать.
Есть вариант - *ячейка, представляющая пользователя*, находится в общем специальном владении, к ней все могут создавать связи, но никто не может изменить ее данные. Поскольку эта ячейка является частью сервера, представляя пользователей сервера.
Каждый пользователь может создавать с ней связи, и удалять эти свои связи.
Поскольку пользователь С разрешает всем создавать связи с с, то пользователю А разрешено создавать связи а-с, и пользователю Б разрешено создавать связи б-с.
Поскольку пользователь С разрешает удалять связи с с, то соответственно.
Однако поскольку пользователь А не разрешает пользователю Б создавать и удалять связи, то пользователь Б не сможет удалить связь а-с и соответствнно, А не сможет удалить б-с
 
Вся эта система довольно непонятная, надо собрать структуру, и в ней определять все это устройство и реализацию, на реальном примере, чтобы обкатать на практике.
-выходит, что первичная ячейка ЯчейкаГруппыДоступа рекурсивно привязывается к первичной ЯчейкаГруппыДоступа. Сама к себе? Или первичную ЯчейкаГруппыДоступа сделать дефолтовой?
Или все-таки прописать каждой ячейке владельца?
-Флаг ридонли тогда выносится в группу прав как связь между владельцем и ячейкой. Тогда оно должно кешироваться и легко добываться механизмом сервера.
-просмотреть жизненный цикл временных ячеек  - как они будут работать в такой схеме?

Если таким образом реализовывать ПрофильПользователя на ячейках, то можно предложить и на РегистраторПользователей реализовать ПрофильПользователя на ячейках как шаблон, а потом на СерверСолюшена копировать этот  ПрофильПользователя и редактировать его пользователем.
 


+++++Права по контейнерам
Поскольку (без передачи сведений о пользователе) при выполнении методов нельзя различить пользователя контейнера А из контейнера Б, то предлагается считать контейнеры за пользователей по ПраваДоступа.
Это будет проблематично. У контейнера А может быть много разных пользователей, и ПраваДоступа пользователя контейнера А на доступ к Б могут отличаться от прав ПраваДоступа этого же пользователя на доступ к Б.

С ПраваДоступа пользователей надо думать. Тут много проблем.

Контейнеру еще надо хранить список пользователей и их ПраваДоступа на операции.
На одном только сервере их проверять недостаточно:
 - операции включают в себя другие операции.
 - методы вообще нарушают всю безопасность – их надо распределять по группам и каждому прицеплять инфу о разрешениях для групп. Это проблема.  

Представим контейнер А, например, математика.
Есть пользователь а, который имеет доступ на чтение СтруктураСущностей.
Есть пользователь б, который может читать СтруктураСущностей и запускать методы.
Есть пользователь в, который может читать СтруктураСущностей, запускать методы, изменять свою часть СтруктураСущностей контейнера А. 
(То есть, элементы СтруктураСущностей должны иметь владельца и категорию доступа. Владелец-Группа – Все, как в ACL)
Есть пользователь с,   который может читать СтруктураСущностей, запускать методы, изменять свою часть СтруктураСущностей контейнера А, изменять все остальное.
- Тут много творчества получается. Пока в системе нет владельца и ACL. Если вводить владельца, то его надо регистрировать где-то, чтобы иметь его ACL.
Пользователь может иметь ПринадлежащийПользователюУчастокСтруктурыСущностейСолюшена и иметь доступ к ОбщийДляПользователейУчастокСтруктурыСущностейСолюшена. Тогда пользователь может иметь части СтруктураСущностей в нескольких контейнерах и связывать их между собой. Тогда идентификация между контейнерами должна быть единой. Пользователь регистрируется и получает ИД где-то на каком-то менеджере.
Таким образом, ПраваДоступа между контейнерами заменяются на ПраваДоступа пользователя к контейнеру А и к контейнеру Б.
И есть центр – менеджер, где регистрируются пользователи и серверы-контейнеры. 
Ячейки и связи хранят ИД владельца, ACL итд.
Пользователи работают с контейнерами на основании своих ПраваДоступа а не отношений между контейнерами.

Выводы:
* Считать контейнеры за пользователей в части ПраваДоступа не хорошее решение.
* Пользователи работают с контейнерами на основании своих ПраваДоступа.
* Методы могут оказаться неработоспособными ввиду отсутствия у текущего пользователя необходимых ПраваДоступа для выполнения вложенных методов из СтороннийСолюшен. Это требует аккуратного проектирования методов с точки зрения прав доступа к СтруктураСущностей.
todo.концепция.пользователи: Надо изобразить схему работы пользователя на нескольких контейнерах в МногоконтейнернаяСистема. Просмотр СтруктураСущностей, исполнение методов. Желательно реалистичный пример из какой-нибудь знакомой предметной области.


++++Описание действия прав пользователя
+++++Перечень прав пользователя
todo.концепция.пользователи: Указать категории и права пользователя на операции с элементами СтруктураСущностей
- нужен перечень операций с элементами СтруктураСущностей
todo.концепция.пользователи: придумать реализацию описания прав пользователей в *ячейке группы прав пользователей*
todo.концепция.пользователи: придумать управление пользователем доступом пользователей к элементам принадлежащей ему СтруктураСущностей
todo.концепция.пользователи: придумать защиту прав пользователя от посягательств других пользователей.
todo.концепция.пользователи: Придумать лучшее название для сущности Права пользователя. 


В части прав пользователей рассмотрим следующие случаи:
* регистрация нового пользователя
* дерегистрация - удаление пользователя
* авторизация пользователя на СерверСолюшена
* вход пользователя на СерверСолюшена
* выход пользователя с СерверСолюшена
* проверка ПраваДоступа пользователя к ЭлементСтруктурыСущностей в СерверСолюшена


+++++Регистрация нового пользователя
Пользователь входит на РегистраторПользователей или на СерверСолюшена.
Пользователь намерен создать новый АккаунтПользователя в МногоконтейнернаяСистема.
Пользователь перенаправляется на страницу создания АккаунтПользователя на РегистраторПользователей.
Пользователь вводит логин, пароль, емайл, ... и нажимает кнопку создать АккаунтПользователя.
Тут можно вставить подтверждение через емайл или чего-то еще.
Создается запись в БД, пользователю присваивается ИдентификаторПользователя.
Затем пользователь направляется на один из СерверСолюшена.
Далее см. Авторизация пользователя на СерверСолюшена.


+++++Дерегистрация пользователя
Дерегистрация на СерверСолюшена - пользователь намерен удалить АккаунтПользователя на СерверСолюшена.
Эта операция удалит запись о пользователе из сведений о пользователях СерверСолюшена.
Это не приведет к удалению АккаунтПользователя из всей МногоконтейнернаяСистема.
Тогда ПринадлежащийПользователюУчастокСтруктурыСущностейСолюшена остается ему принадлежать по ИдентификаторПользователя, хотя у него уже нет АккаунтПользователя на сервере.
И он может продолжать ею пользоваться. 
Смысл такого удаления? 
Смысл АккаунтПользователя на СерверСолюшена? 
- АккаунтПользователя позволяет посмотреть список пользователей СерверСолюшена.
- Список пользователей СерверСолюшена может формироваться автоматически просмотром всех ИдентификаторПользователя в СтруктураСущностей Солюшена
- АккаунтПользователя позволяет другим пользователям включать его в ПраваДоступа к частям СтруктураСущностей Солюшена.
- пользователи могут просто указать ИдентификаторПользователя нужного им пользователя без добавления его в контейнер.
- АккаунтПользователя позволяет посмотреть список доступных пользователю частей СтруктураСущностей Солюшена
- АккаунтПользователя описывает ПраваДоступа пользователя к СтруктураСущностей Солюшена.
- Если пользователь имеет доступ к некоторой части СтруктураСущностей Солюшена, то после удаления АккаунтПользователя следующий запрос доступа к частям СтруктураСущностей Солюшена от этого пользователя приведет к созданию АккаунтПользователя с параметрами по умолчанию.
Соответственно параметров доступа АккаунтПользователя, пользователю будет разрешен или запрещен доступ к части СтруктураСущностей Солюшена. 

Дерегистрация на РегистраторПользователей - удаление пользователя из МногоконтейнернаяСистема в целом
Эта операция удалит запись о пользователе из сведений о пользователях на РегистраторПользователей.
Запрос авторизации будет отклонен.
Следовательно, пользователь не сможет войти на СерверСолюшена. Доступ к операциям со СтруктураСущностей Солюшена регулируется АккаунтПользователя на СерверСолюшена. Если он не будет удален, то пользователь может использовать ПринадлежащийПользователюУчастокСтруктурыСущностейСолюшена и другие доступные ему участки СтруктураСущностей, хотя он не может войти на СерверСолюшена и вообще не представлен в МногоконтейнернаяСистема.


+++++Авторизация пользователя на СерверСолюшена
Пользователь перенаправляется на РегистраторПользователей.
СеансПользователя продолжается, и служит контейнером, в рамках которого проводятся защищаемые параметры.
Там пользователь вводит логин и пароль или другое средство идентификации
Если идентификация успешна, пользователь перенаправляется на СерверСолюшена с ИдентификаторПользователя. (ИдентификаторПользователя можно перехватить/подделать на этом этапе, вместе со всей СеансПользователя).


+++++вход пользователя на СерверСолюшена
Пользователь желает войти на СерверСолюшена
Открывается СеансПользователя со случайным идентификатором. ( Что это за идентификатор?)
Производится авторизация пользователя на СерверСолюшена, на СерверСолюшена возвращается ИдентификаторПользователя.
Далее если пользователь с этим ИдентификаторПользователя существует на СерверСолюшена, он попадает в свой АккаунтПользователя, если не существует - создается новый АккаунтПользователя.
Пользователь начинает работу на СерверСолюшена.


+++++выход пользователя с СерверСолюшена
Поьзователь желает выйти с СерверСолюшена.
Проводится завершение работы со СтруктураСущностей Солюшена - всякие там проверки, сохранения итд.
Закрывается СеансПользователя.
Пользователь получает сообщение о завершении СеансПользователя.


+++++проверка прав доступа пользователя к объекту сервера
 

Проверка производится внутри СерверСолюшена. Каждый ЭлементСтруктурыСущностей должен иметь поле описания для ПраваДоступа пользователей. Вероятно, ПраваДоступа пользователей будут представлены группами ГруппаПользователей ВладелецЭлементаСтруктуры, ВладелецЭлементаСтруктуры и ...
То есть, каждый ЭлементСтруктурыСущностей сопоставлен с ГруппаПравДоступа группой ПраваДоступа пользователей. В этой группе каждому пользователю сопоставлены ПраваДоступа к ЭлементСтруктурыСущностей. В каждой ГруппаПравДоступа записан обязательно ВладелецЭлементаСтруктуры, и опционально пользователи и группы ГруппаПользователей. Каждой этой записи сопоставлены ПраваДоступа пользователя. 
При проверке доступа текущего пользователя используется КэшГруппПравДоступа пользователя. В этом кеше хранятся группы ГруппаПравДоступа и соответствующие им ПраваДоступа пользователя. Группа добавляется в КэшГруппПравДоступа при первом использовании. КэшГруппПравДоступа существует в пределах СеансПользователя.
ИдентификаторВладельца в элементах ЭлементСтруктурыСущностей не хранится - хранится только ГруппаДоступа, в ней прописан ВладелецЭлементаСтруктуры.
По умолчанию при создании ЭлементСтруктурыСущностей ему присваивается дефолтовый ИдентификаторПравПользователя. В нем только ВладелецЭлементаСтруктуры и его ПраваДоступа полного доступа, и ГруппаВсе, о всех пользователях, не упомянутых в ГруппаПравДоступа явно, для нее устанавливаются ПраваДоступа по умолчанию, ВладелецЭлементаСтруктуры может их изменить.
Это несколько неудобно - лучше бы связывать ЭлементСтруктурыСущностей с группами ГруппаПравДоступа, но для ЭлементСтруктурыСущностей-связей это неудобно еще более.
В общем, реализацию прав доступа надо обдумывать.


+++++Кража идентификатора пользователя
ИдентификаторПользователя представляет собой некоторое число, которое можно узнать или подобрать.
Поскольку работа с СерверСолюшена предполагает передачу этого ИдентификаторПользователя, то можно просто передавать нужный ИдентификаторПользователя при операциях со СтруктураСущностей Солюшена.
Обычно эта проблема решается так - передается одноразовый ИдентификаторСеансаПользователя, который имеет смысл только внутри СерверСолюшена.
СеансПользователя работают только на участке сервер-пользователь.
На участке сервер-сервер нужны другие механизмы идентификации контейнеров и пользователя.
Тут можно предложить шифровать траффик, но все равно безопасность цепочки зависит от владельца сервера.

++++Приложение. Дескрипторы доступа к файлам в Линуксе

Для файлов:
r-чтение
w-запись
x-выполнение

Для каталогов:
r-получить список файлов
w-создавать (добавлять), удалять, переименовывать файлы
x-входить в каталог и использовать его файлы (но не получать список файлов каталога)

структура дескриптора:
d rwx rwx rwx - [dirflag][user][group][others]
User - подразумевается владелец файла, обычно создатель.
Group - группа, подразумевается к которой принадлежит владелец файла.
Others - все остальные пользователи.

Группа может содержать пользователей и другие группы.
Для каждого специального набора прав можно создать отдельную группу и включить в нее одного или нескольких пользователей.
В общем, на файл таким образом нельзя дать одному пользователю не владельцу одни ПраваДоступа, другому - другие, а всем остальным - третьи. 
Это годится для подразделения организации, но не годится для широкого доступа. Так как широкая публика не будет соблюдать необходимые правила.


++++Приложение. Пользователи и группы пользователей в WEB.
Группы пользователей определяют ПраваДоступа пользователей на доступ к ячейкам и связям. Для элементов регистрируется владелец объекта  и минимальная группа, которой позволяется доступ к объекту.
---уточнить концепцию
* Пользователи разделены на группы. 
* Каждая группа имеет свои ПраваДоступа к общему набору элементов.
Владелец элемента имеет полный доступ к своим элементам и ограниченный доступ к чужим. Однако в web часто создатель элемента не имеет полных прав доступа к нему. Например, создатель сообщения на форуме, как правило, не имеет прав им управлять, не становится его владельцем, к этому топику применяются общие правила доступа.

Упрощенное представление прав доступа для групп пользователей
----------------------------------------------------------------------------------------------------
группа	| роль юзера |изм. сис объекты |изм. чужие польз объекты |изм. собств польз объекты |просмотр |
----------------------------------------------------------------------------------------------------
  0     ошибка
  1	    админ	        да  		        да         			    да             			да
  2	    модер			                    да			            да			            да
  3	    пользов						                                да			            да
  4	    гость									                                            да
----------------------------------------------------------------------------------------------------
  5	   чужой            
----------------------------------------------------------------------------------------------------
* Группа 0 предназначена для выявления ошибок.
* ПраваДоступа на изменение связей, вероятно, считаются по наименее важному их концу, то есть, если связываются объект системный и объект пользователя, то создатель связи может также удалить эту связь. В противном случае, пользователь не сможет использовать системные сущности.
* Юзер может создавать объекты более защищенных классов и управлять ими. Режим защиты определяется 
для каждого объекта индивидуально. – копируется группа  и ИД пользователя.





