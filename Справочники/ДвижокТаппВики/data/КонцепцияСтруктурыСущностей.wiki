++ Концепция Структуры Сущностей
[//ДОПОЛНИТЬ] - добавлять полезные замечания

++++Описание концепции
Описывает назначение, строение и свойства структуры сущностей

+++Наработки
* См. КонцепцияОтношенияИСущности - складывать тут такие абстрактные тексты
* ЗамечанияККонцепцииДвижка - складывать тут замечания, возникшие в процессе переработки концепций.


+++Сборка версий 
++++Доделать
* СтруктураСущностей -  12.12.2016 06:33 оставить только материал по собственно структуре сущностей, остальное вынести сюда. А то на странице концепции нет материалов о концепции. Но в общем  - можно считать работу здесь завершенной, на требуемом сейчас уровне качества и детализации. 


++++Сделаны 
* КонцепцияТапп1 13.12.2016 09:31
* [Контейнер] 06.12.2016 05:09
* КоллекцияЯчеекКонтейнера 11.12.2016 09:58
* СлужебнаяЧастьСтруктурыСущностей 09.12.2016 01:40 
* СолюшенБезБД 08.12.2016 05:52 
* НачальноеСостояниеСтруктурыСущностей 08.12.2016 03:15 
* КоллекцияСвязейКонтейнера 09.12.2016 02:34 
* ТипПоУмолчанию 06.12.2016 05:16 
* КоллекцияСвязейЯчейки 09.12.2016 09:23 
* [Ячейка] 11.12.2016 04:20 
* ИдентификаторЭлементаСтруктуры, ИдентификаторСвязи, ИдентификаторЯчейки 08.12.2016 05:30 
* [Связь] 10.12.2016 08:03 

+++Материалы
См. wiki:///V:/МоиПроекты/SIM/Работать%20здесь/Concept1/Concept1.wiki?page=ОперацииСЭлементами
* wiki:///V:/МоиПроекты/SIM/SimWiki/SimWiki.wiki?page=РаботаСОтношениями
* [file:///V:/МоиПроекты/SIM/OldVersions/SimOldDocs/Plan.txt]
++++Структура сущностей Тапп1 в Тапп2
+++++переработка теории
Нужен будет начальный класс аналогично МИР.
Надо описать структуру текстом.	  
- одиночные или множественные связи в каждой из иерархий? Определиться, чтобы не попасть как 	в прошлый раз.
- рассмотреть типовой вариант: объект - класс - класс. Это общий случай.
- рассмотреть типовой вариант: композиция классов - класс. Классы связаны по горизонтали, образуя некоторую конструкцию. Эта конструкция представляет собой класс. Например класс коллекции включает в себя классы - элементы коллекции. Класс файл включает в себя данные и атрибуты. Нужно определить представление связи класса с его композитами - подклассами, работу с этими связями, вообще работу этой конструкции. Интересная задача.
- составить текстовое описание теории - общее представление, терминологию, основные положения, описание сущностей, описание их действий, описание взаимодействий, исключительные ситуации и их обработку, направления изучения. В общем, сделать хорошую теоретическую модель.
+++++ Как создавать новые ячейки?
Как создавать объекты классов? Сейчас они создаются на основе шаблона класса, т е на Х-плоскости связей класса. Можно так же, но тогда нужны местодержатели для неизвестных свойств. Сейчас это предопределенные объекты класса, которые создаются вместе с классом. Нужно как-то поддерживать эту фичу. Можно создавать специальный объект класса, и скидывать все связи на него. А можно создавать объект и присваивать ему соответствующее специальное значение. Тогда оно будет обнаружено при просмотре объекта.
++++Концепт системы ячеек как переход от Тапп1
Из ПрототипА

Идентификатор ячейки - просто обычное число. Системного пространства идентификаторов нет. 
? Идентификаторы специальных сущностей - как обычные сущности, ищутся в таблице.
Можно ввести подтипы или детализировать типы ячеек для специальных сущностей.
Ячейка создается конструктором контейнера без специализации класс/объект/метод. 
При создании ячейки-объекта можно указать класс, тогда используется конструктор от этого класса.
Можно сначала построить граф сущностей-ячеек, потом классифицировать.

Хотя все равно придется в результате перестраивать структуру, поэтому можно сразу строить из классов, после анализа создать новую структуру. Это будет локальное во времени преобразование, при медленном, постепенном преобразовании такая система может оказаться неподходящей. 

Каждой ячейке могут быть сопоставлены методы. Объекты могут иметь методы, отличные от методов других объектов этого же класса.
В классе по оси абстракции вниз будут обозначены объекты. В объекте эта ось пустая. Объект может быть сопоставлен нескольким классам, хотя это, разумеется, неправильно. Контролировать это будет либо [Оптимизатор] либо пользователь, но не движок.

Поскольку типы ячеек определяются по самой ячейке, то связи между классами и методами, например, могут быть реализованы на основе общих механизмов. (То есть, один и тот же механизм используется и для данных, и для методов, 
то есть они имеют одинаковую реализацию в коде). Различение типов таким образом возлагается на оперирующий код.

Dec 17, 2011
Попробуем систему ячеек.
* все ячейки имеют одинаковую структуру вне зависимости от их типа.
* идентификаторы ячеек представляют собой 32-битное число и не имеют разделения на пространства.
* новый идентификатор получается как max+1. Идентификаторы введены поскольку структура состоит из элементов, хранящихся независимо.
* можно предположить типы и подтипы ячеек. 
* Типы и подтипы могут быть удалены или добавлены. 
* основные типы ячеек:
    * класс
    * объект
    * метод
* существующие в базе сущности:
    * служебный класс, имеющий специальное назначение
    * класс
    * служебный объект класса, имеющий специальное назначение
    * объект класса
    * метод
    * экземпляр метода
    * связь между ячейками
    * тип связи

-Ячейка может быть найдена по идентификатору или по имени (и типу).
-Имя ячейки может быть не уникальным. Поиск в таком случае возвращает список ячеек.
-Каждой ячейке могут быть сопоставлены методы. Объект может пользоваться методами класса. 
Объект может иметь собственный вариант метода, отличный от метода класса.
-Метод представляет собой ячейку-класс, описывающую алгоритм и связанную с этим алгоритмом. Объекты этого класса являются реализациями алгоритма, связанными с конкретными объектами-данными.
-алгоритм представляет собой граф классов-элементов алгоритма, каждый из которых связан с ячейкой-методом.
-каждая реализация метода состоит из объектов-элементов алгоритма. 
Реализация создается классом метода, и может накапливать данные о своих исполнениях.
-Назначение ячейки определяется ее типом, который в основном нужен для представления пользователю, и характером связей.
-в движке нужны функции для получения объектов класса по идентификатору класса, служебных объектов класса по имени, служебных классов по имени, методов/классов/объектов/..., связанных с ячейкой, общего списка классов, общего списка методов.
-все ячейки могут связываться друг с другом без ограничений. Проверка правильности структуры осуществляется [Оптимизатор]ом и оболочкой пользователя. 
-Ячейка, представленная в памяти приложения, является clr-классом, осуществляющим операции. Однако, код выполняет только базовые низкоуровневые операции, а для операций ячейки вызываются сопоставленные ей методы. Вероятно, потребуется ввести некоторый шаблонный набор методов для каждого типа ячеек, который хранится где-то, и при отсутствии сопоставленного непосредственно с ячейкой метода, подставляется метод из шаблона. Возможно, потребуется ввести классы типов ячеек и в них прописывать этот набор. Каждую ячейку тогда можно связать с одним из этих классов и таким образом иметь доступ и идентификацию типа. Можно создать тип связи "Тип ячейки" для этого. Такой элемент может хранить типичный для 
типа ячейки набор методов, который потом проецируется на ячейку, когда перечисляются ее методы. Ячейка переопределяет этот шаблон своими связями.
-таким образом, для построения произвольной системы нужно иметь ячейки, связи, изменяемые методы, движок для исполнения операций и хранилище данных. Ячейки, связи, методы могут иметь типы, что облегчает их интерпретацию и восприятие структуры. Однако могут и не иметь, это зависит от организации системы.
-В представление связи в памяти входят идентификаторы связанных объектов, состояние связи, тип связи, флаг удаления, адрес конечного объекта в памяти. Поскольку исходный объект и так известен, можно удалить его идентификатор, но пока оставим, пригодится если использовать этот класс отдельно от ячеек.
-тип связи - это ось связи, выделен в отдельный элемент, можно добавлять и удалять типы связей
-состояние связи дополняет тип связи, оно сейчас имеет два значения: Разрешено, запрещено. Выделить в отдельный элемент с возможностью удалять и добавлять. Состояние связи можно использовать для выключения дефолтовых методов, соответствующих типу ячейки для конкретной ячейки или методов класса для объекта. 
!Нужно придумать механизм, при помощи которого подключаемые ячейки-свойства будут участвовать в операциях. Импорта МетодОбработчикЯчейки обработчиков недостаточно. Можно попробовать аналогию с нейронными сетями или с осциллографической трубкой - каждое свойство влияет в своем направлении, потом выбирается подходящий метод.
-Всю систему нужно спроектировать для самостоятельного применения, включая самостоятельное создание и обслуживание таблиц и индексов. (Создание, перестройку индексов, оптимизацию таблиц, итд.)
- нужно реализовать вывод базы данных в один ФайлСнимка - ПолныйСнимокСтруктуры.
- в сущности, связь сама по себе можно представить в виде ячейки, с входящими и выходящими связями. Эта концепция редуцирует всю систему до подобия нейронной сети. Однако пока еще нельзя определить, как это должно выглядеть и какую функцию должна выполнять каждая ячейка. Нужен опыт работы с создаваемой ВерсияАрхитектурыСтруктурыСущностей. 



Dec 20, 2011
Дополнения в структуру:
1)для указания типа ячейки, связи и так далее (А), используются числовые идентификаторы, набор которых предполагается пополнять. Эти идентификаторы сопоставлены некоторому смыслу и специализированному поведению некоторых операций. То есть, представляют собой сущности некоторого типа.
Предлагается вместо этих идентификаторов использовать идентификаторы ячеек (Б), которые олицетворяют эти сущности. Ячейки (Б) могут иметь операции, и эти операции можно проецировать на элементы (А). Таким образом, ячейки (Б) представляют собой классы для ячеек(А). Лучше было бы использовать связи между ячейками вместо полей в ячейке. Это позволяет назначать любое количество свойств для ячейки, не изменяя структуру движка системы. Однако это усложняет поиск ячеек с заданными свойствами и размер 
базы данных. 
-Это позволит единообразить строение системы, заменить специализированные принципы на общие принципы. Удалить таблицы этих специализированных значений из базы. Обозначать значения уникальными именами ячеек. Можно создавать классы сущностей (Б), использовать любую существующую ячейку для создания и обслуживания соответствующего ей типа связи. Повышает универсальность базы.
-Нужно разобрать примеры доступа, чтобы выявить узкие места.
-Все необходимые ячейки должны быть включены в стартовый набор.

2) В существующей архитектуре связь представляет собой сущность. У нее есть тип, состояние итд. Можно предложить выделить ее в отдельную ячейку в середине связи, а связи тогда будут представлять собой только пары идентификаторов. Это уже несколько другая система получается, поскольку ячейка-связь может содержать несколько связей в каждом из направлений и иметь МетодОбработчикЯчейки обработчики для выполнения собственных операций. Это что-то похожее на нейронную сеть.
-Пока неясно, как это вписывается в общую картину системы. Пока отложим до выработки общей концепции. 

Примеры доступа для 1)
-получение Б по ид - ищем в таблице ячеек по ид.
-получение Б по имени - ищем ячейку (Б) в таблице ячеек по имени. Имя ячейки(Б) должно быть уникальным, чтобы его можно было использовать в коде пользователем.
-определение типа ячейки (А)
вариант с полем типа: получаем значение поля, при необходимости получаем ячейку с таким идентификатором из списка ячеек.
вариант со связью: Связь "Тип ячейки" ищем в списке связей ячейки. 

Получаем идентификатор ячейки(Б), т.е. идентификатор типа. 
-выполнение операции создания связи в соответствии с типом связи
вариант с полем типа: получаем значение поля, ищем ячейку(Б), получаем список операций, выбираем и исполняем операцию.
-получить все связанные с ячейкой (А) объекты класса Е:
-по идентификатору установить класс невозможно. Для каждой связанной ячейки нужно проверить, что она является объектом, И сопоставлена с требуемым классом. 
вариант с полем типа: 
Получаем связанные ячейки(С) в список. Для каждой ячейки (С) проверяем поле типа. Если не объект, удаляем из списка. Вариант: если поля типа не нужны, и ячейка определяется по структуре, то пропускаем этот 
шаг, поскольку тогда надо проверять связь с классом, а это следующий шаг.
Для каждой С-ячейки из списка проверяем, является ли она объектом класса Е. (Наличие восходящей связи соответствующего типа) Как можно заметить, все это работает медленно, если лежит в таблицах, но довольно быстро, если с прямыми ссылками размещено в памяти.
-...

3) Поскольку структура системы универсальна, а ее представление в коде нет, придется повозиться, чтобы реализовать эту гибкость и удобство в структуры данных для использования в пользовательском коде.
4) надо составить дерево вариантов архитектуры, и каждый вариант пометить кодом, чтобы обозначать сответствующее поведение в системе.
Дерево вариантов:
- Поле Типа ячейки:
а)Тип ячейки Класс-Объект-Метод-... хранится в специальном поле ячейки.
б)Тип ячейки не назначается, а определяется по характеру связей ячейки для каждого конкретного случая.
-Поля типов, состояний, ...:
а)представлены Б-ячейками, идентификаторы которых хранятся в специальном поле ячейки.
б)представлены связью соответствующего типа с соответствующей Б-ячейкой. 
5)поскольку везде в структуре вместо типов, состояний итд должны применяться идентификаторы ячеек, то для старта базы нужно создать эти ячейки, увязать в структуру, и снабдить их МетодОбработчикЯчейки обработчиками, чтобы можно было их использовать. То есть, нужна еще концепция использования этого механизма.

? Вопрос: Ячейка должна наследовать МетодОбработчикЯчейки обработчики над-ячейки. Во всех ли случаях, во всех осях связей, или надо специально обозначать, откуда нужно импортировать методы, а откуда нельзя? И как это обозначить (разрешить/запретить импорт методов) Или, наоборот, экспорт. 

? Свойства, типы и другие характеристики элементов являются самостоятельными сущностями, и также представлены в виде ячеек. Чтобы 
ввести новый тип, нужно как-то вписать его в существующую систему. Поскольку первоначально никаких сущностей в базе нет, ячейкам назначается тип по умолчанию. 
а)Просто игнорировать тип по умолчанию при выполнении операций - потребуется реализовать это в каждом коде.
б)Реализовать его поддержку в коде движка.
в)Предусмотреть в теории ТипПоУмолчанию, его МетодОбработчикЯчейки обработчики, как пустые. Если нельзя обойтись, создать такой тип вместе с базой.
г)Поставлять вместе с базой минимально необходимый набор сущностей, в случае если они окажутся взаимозависимы.

++++Описание версии Астра
Из wiki:///V:/МоиПроекты/SIM/SimWiki/SimWiki.wiki?page=ОписаниеВерсииAstra
27.06.2012
Проект Tapp v2.3 "Astra"
Новая ВерсияАрхитектурыДвижка Tapp, использует SQL Server для хранения данных.
Элементы предметной области хранятся в таблицах, для работы требуемый элемент загружается в память. 
Представление элементов в памяти - как в tapp2.2.
Предполагается реализовать два варианта выполнения операций: 
а) все операции выполняются непосредственно с таблицами, база всегда в согласованном состоянии.
б) все операции выполняются с представлениями в памяти, в таблицы данные записываются специальным вызовом по окончании операции.
	Создание новых элементов при а) приводит к созданию записей в таблицах. 
	При б) есть возможность записи не создавать, используя элемент только в памяти, как временный, или сохранить его при необходимости.
Переключение между вариантами для каждого элемента индивидуальное.
Методы все еще в стадии предположений, поэтому пока проектируются только структуры данных.

Предполагается разделить все операции с элементами на базовые(неизменяемые) и модифицируемые. 
Базовые реализуют низкоуровневые операции, изменяемые состоят из базовых и позволяют индивидуальное поведение для каждого элемента.
Например, каждый тип связи может проводить собственные проверки и обработку операций создания/удаления/...
Типы связей можно добавлять, удалять, изменять, модифицировать операции со связями.

++++Механизм запросов на разрешение коллизий и удаление сущностей
Из ПользовательскийИнтерфейс
+++++Обсуждение механизма запросов на разрешение коллизий
Чтобы работать, этот механизм должен быть изначально заложен в архитектуру системы.
Например, в некоторой структуре мы создаем некоторый объект, и этот объект не заполнен данными и имеет состояние, обозначающее необходимость его заполнить данными и связями. 
Система, обнаружив этот объект, для каждого свойства объекта запрашивает пользователя, требуя определить это некоторое свойство объекта. Пользователь, получив такой запрос, должен изучить контекст проблемы, и принять решение о значении свойства объекта.
Это обещает поддержание целостности всей структуры системы, но пользователь будет разгребать завалы требований.
Например, пользователь желает добавить новую книгу в коллекцию книг. Тогда он должен просто создать основную ячейку в коллекции книг. Затем система, обнаружив эту ячейку, запросит у пользователя ее свойства, по одному за раз. Пользователь может сразу установить все нужные свойства, чем избежит новых запросов. Далее, каждый элемент коллекции должен иметь структуру ячеек, и система последовательно запросит у пользователя создание этой структуры ячеек и установку всех свойств. Таким образом, пользователь будет вынужден создать требуемую структуру с требуемым набором свойств. Недостаток в том, что пользователь не контролирует правильность структуры, а система не знает, что именно хотел пользователь.
Кроме того, при некоторых ошибках могут образовываться бесконечные циклы запросов, хотя это можно контролировать, проверяя структуру на соответствие определенным правилам. Которые еще надо выработать для такой архитектуры.

Гибкая структура системы позволяет создавать методы подобно языкам программирования, но с большим разнообразием операторов. Создание, отладка и исполнение методов должно быть не сложнее, чем собственно придумывание метода пользователем. В этой концепции система является одновременно памятью, средой разработки, отладчиком, тестовой средой, справочной информацией разработчика, [Лог]ом и трекером проекта. Это разнообразие функций требует определенных соглашений, архитектурных решений и технических средств.

Метод на практически применимом уровне описывается ячейками и связями, состоит из последовательности абстракций методов, которые транслируются в реальные уже применительно к реальным данным. Тут лучше обратиться к концепции методов.

* Таким образом, запросы на разрешение должны генерироваться для ячеек и связей, для каждого свойства. И не только на наличие, но и на соответствие ранее установленным правилам.
* Эти запросы требуют проработки архитектуры и концепции для своей работоспособности. Они требуют написания специфического кода для работы движка, это нарушает права пользовательских концепций на свободу. Тут надо думать - или пользователь будет сам создавать исполняемый код для концепции, или предоставить ему возможность собирать требуемый функционал из методов.
* Получается вроде Tapp1 - в системе должны быть сущности, специально предназначенные для пометки состояния данных, и группирующие на себя ссылки, требующие разрешения. Это не самый лучший вариант, надо обдумать.
* Запросы на разрешение непонятны без контекста и будут приводить к ошибкам из-за того, что пользователь неверно понял контекст. Контекст хранится в [Лог]е. Особенно как следствие выполнения методов или после перерыва в работе. Значит пользователю надо предоставлять [Лог] для просмотра  и анализа записей о сущности запроса до момента запроса. Запросы надо иметь возможность игнорировать, иначе вся работа встанет при первой же кольцевой зависимости.
У [Лог]а должна быть хорошая информативность, навигация и структурирование. В [Лог]е и в методах нужно применять комментарии, описывающие суть или этап выполнения операции, особенно для сложных операций. Однако для частых операций это приведет к тому, что [Лог] будет быстро расти, и станет отдельной серьезной темой.
Еще для [Лог]а хорошо бы пользователю иметь возможность виртуально повторить некоторую часть процесса работы системы, или отдельный метод, по данным [Лог]а, чтобы что-то нужное выяснить.

+++++Соображения о удалении сущностей из структуры
* Если сущность используется только в одном месте, то ее можно без проблем удалить.
* Если сущность используется еще где-то, то удалять ее нельзя
* Если сущность не используется нигде, но где-то используется какое-то ее свойство, то это вопрос сложный. И решать его должен пользователь.
    * Если свойство вполне обойдется без сущности, то можно оставить только свойство, но тогда оно скорее всего изменит свою семантику. То есть, его надо было заменить изначально, но придется сделать это сейчас.
    * Если свойство нельзя отделить от сущности, придется как-то организовывать семантику сущности чтобы избежать удаления [Оптимизатор]ом.
* Поскольку [Оптимизатор] реализует удаление невостребованных ячеек, концепция должна определить, каким образом [Оптимизатор] это делает, чтобы удаление не приводило к нарушению структуры данных.

++++Философия
Из [file:///V:/МоиПроекты/SIM/OldVersions/SimOldDocs/Methododlogy.txt]
- с какого бы угла зайти на эту систему, чтобы классы и объекты выглядели одинаково и имели одинаковую трактовку и функциональность?
  Тогда можно было бы реализовать их одним типом. Но при этом, чтобы вся система имела смысл.
	- Если классы ничем не будут отличаться от объектов, кроме того, что объекты не имеют Y связей вниз, то получается вроде ничего:
	классы будут так же участвовать в операциях, как и объекты. Правда, только если существуют эти операции или правила позволяющие их синтезировать. То есть, если были прецеденты (обучение) или существует операция параллельного переноса с других,похожих классов.
	То есть, тогда вся разница заключается в методах. Или правилах? Как это называется? Похоже, что это является причиной для возникновения связей в X, Y плоскостях. Если предположить, что одно такое нечто является причиной создания объекта, другое - определения его свойств, третье - Y-связей между двумя объектами, четвертое - X связей, то получается, что вся эта комбинация из трех пальцев имеет возможность, сложившись определенным образом в нужной последовательности, создать некоторую небольшую и довольно примитивную логическую системку. (Надо учесть, что все создаваемое человеком базируется на его понимании мира, включающем объемное цветное зрение, слух, осязание, обоняние, и кучу всего остального. В компьютерной модели этого всего нет, поэтому трудно оценить правильно, что получилось, и как это можно улучшить.) По мере развития это нечто обрастает вариантами, варианты-свойствами, все это периодически переупорядочивается по эффективности,  и вместе со структурой понятий превращается в большой запутанный клубок. Так что же это за хрень, и как ее обозвать? 
Как организовать соотношение между созданием объектов/связей и этим нечто? Надо соединить все наработки по классификации и самоорганизации с этой хренью. Полученный комплекс можно использовать для прототипа 3 версии.   


- в типовой семантике это реализовано при помощи сущностей и правил. Сущности извлекаются из предметной области, а правила назначает разработчик. А у меня так не очень. Сущности размазаны по структуре, а правила должны создаваться автоматически и вообще непонятно как выглядят и работают. Или это не правила даже... Надо пособирать мысли на эту тему, может чего и оформится.

---------------------------------------------------------

Начнем сначала:
1) Есть некая штука.	*Можно создать объект Штука* 
2) Характеризуем свойства: Тяжелая, твердая, фиолетово-бурая. Это свойства. Их можно выразить в некоторых величинах, каждая в своей шкале, но эти величины и шкалы - отдельная тема.  *Появились отношения свойств - вес, состояние поверхности, цвет. (Число свойств зависит от возможностей по их выделению. Для начала свойства можно пропустить, но возможно, это одна из осей, поскольку свойства есть у всех сущностей, в том числе абстрактных*   
3) Появилась вторая штука. *Создаем объект Штука*
4) Теперь есть две штуки. *Две Штуки - это не одна Штука, это две отдельных независимых Штуки. Значит, получается два объекта Штука, никак не связанных пока* 
5) Характеризуем свойства новой штуки: Новая штука тяжелая, твердая, серая.
Сейчас есть две штуки. Можно рассмотреть варианты.
- абстракция/обобщение: Это Штука и это Штука. *Обобщение Штук - создается класс Штуки*. 
Эта тяжелая, и эта тяжелая. *Обобщение свойств Штук. Создается класс "Свойство Штуки: Вес".* 
Эта твердая, и эта тоже твердая. *Создается класс "Свойство Штуки: состояние поверхности"*
Эта серая, а эта бурая. Это разные штуки. *??*
реклассификация: Эта Штука относится к классу Штук. И эта Штука относится к классу Штук. *Вероятно, класс Штука должен получить свойства-классы Вес, Состояние поверхности. Однако это не обязательно произойдет сейчас*.
- агрегация: Если эти две штуки сложить вместе, то получится... новая штука. Так - две штуки. Так - одна. Вау, круто. *Две штуки превращаются в одну. Можно создать надобъект Штука в плоскости Х (агрегации). Можно обнаружить здесь методы для преобразований assembling disassembling. Пока непонятно, как эти методы сюда прицепить, но сами связи типа Х уже очевидны*
- кстати, вопрос: агрегация будет выявлена успешно только после выявления абстракции? 
- что еще с этими двумя штуками?

 

------------------------------------------------------
Свойства объектов.
У каждого объекта есть свойства. Свойства можно выразить числовыми значениями. Свойства бывают выражены непрерывной функцией, бывают дискретными значениями.
- Есть ли у класса свойства? Свойства класса определяются свойствами его объектов. Свойства определяют класс объекта
 (сочетание и величины свойств можно использовать для классификации объектов (и классов?))
Для целей классификации можно выделить границы значений свойств. Так что класс вероятно может хранить эти границы.


Пока трудно определить это. Можно попробовать сделать движок, смоделировать на нем какую-то системку, возможно, это даст лучшее понимание, что и как действует. Свойства к объектам и классам можно прицеплять в Z-оси. Все выглядит неплохо пока не потребуется четвертая ось, впрочем, ее нетрудно будет добавить.

Так что начинаем сразу Tapp2! Методологию, проектирование, и т д.



++++Создание ячейки в приложении
Из wiki:///V:/МоиПроекты/SIM/Работать%20здесь/Concept1/Concept1.wiki?page=СозданиеЯчейкиВПриложении
В приложении пользователь должен иметь возможность создать ячейку.
Надо указать 
НазваниеЯчейки - оригинальное имя сущности, которую представляет ячейка.
ОписаниеЯчейки - однозначное описание сущности ячейки, ее назначение, применение.
ТипЯчейки- идентификатор существующей ячейки ЯчейкаТипаЯчейки, описывающей тип ячейки.
АктивностьЯчейки - ячейка создается активной, а если она более не нужна, ее можно пометить неактивной, и она более не будет участвовать в работе СтруктураСущностей.
ТипДанныхЯчейки - идентификатор существующей ячейки ЯчейкаТипаДанных, описывающей тип данных, примененный в создаваемой ячейке.
БлокДанныхЯчейки - байты данных ячейки. Ячейка может не содержать данных, являясь организационной единицей структуры.
СостояниеЯчейки - Идентификатор существующей ячейки, описывающей состояние ячейки или их комбинацию.

Идентификаторы для полей ТипЯчейки, ТипДанныхЯчейки, СостояниеЯчейки уже должны быть на этот момент определены в СлужебнаяЧастьСтруктурыСущностей, либо для них должен использоваться ТипПоУмолчанию.

Создание ячейки в приложении можно проводить диалоговым окном. Это диалоговое окно можно импортировать из [Навигатор]а, так как оно требует много знаний об устройстве [Движок].  ТипЯчейки, СостояниеЯчейки, ТипДанныхЯчейки можно выбрать из списка, где перечислены все варианты с описаниями. Однако такой список предполагает существование СлужебнаяЧастьСтруктурыСущностей, в которой существуют ячейки ЯчейкаКоллекцияЯчеекОписателей, имена которых можно использовать для доступа к таким спискам. Организация СлужебнаяЧастьСтруктурыСущностей очевидно должна проводиться другими средствами.

ЯчейкаКоллекцияЯчеекОписателей представляет структуру - коллекцию, которая содержит ячейки ЯчейкаОписатель определенного вида. Например, Коллекция описателей типа ячейки содержит связи с множеством разных ЯчейкаТипаЯчейки, каждая из которых представляет некоторый ТипЯчейки.   

Можно предложить некоторый вариант [Навигатор]а по структуре СтруктураСущностей, который можно вызвать в ходе операции, передвигаться по структуре ячеек, выбрать одну или несколько ячеек и вернуться обратно в операцию. И так использовать, возможно, рекурсивно, хотя это неудобно. 
При создании ячейки этот [Навигатор] позволит выбрать необходимые ЯчейкаОписатель из КоллекцияЯчеекОписателей , или тут же создать их, только не увлекаться и не забыть вернуться в начало рекурсии, и не попасть в ЛовушкаРекурсии.

Можно предложить КонсольКоманд - вариант навигатора, подобно консоли ос, где надо все знать заранее. Это будет удобно только для построения СлужебнаяЧастьСтруктурыСущностей. Для указания ячеек можно использовать названия ячеек, если они уникальны; пути из имен ячеек от некоторого якоря-корня; идентификаторы ячеек, если они заранее известны. Надо только разработать протокол операций для консоли, а саму консоль можно быстро реализовать.
Такую консоль можно реализовать по рекурсивной концепции. Например, при создании ячейки надо указать ТипЯчейки. Вместо ввода значения ТипЯчейки (Кстати, а как его вводить?) в консоли вводим вызов консоли, и новый экземпляр консоли КонсольКоманд появлется на экране. В нем выбираем нужную ячейку, выделяем ее, консоль закрывается, а ИдентификаторЯчейки возвращается в предыдущую консоль. Так можно получить необходимую рекурсию и не запутаться в ее уровнях. Надо, чтобы потомок не позволял активизировать родителя, и все окна одновременно отображались на экране.
Все экземпляры консоли КонсольКоманд одновременно имеют доступ к контейнеру, ловушки ЛовушкаРекурсии обнаруживает и устраняет пользователь.
Параметры создаваемого элемента можно запрашивать построчно или последовательно, построчный вариант позволяет использовать значения по умолчанию, последовательный более короткий.
Вызывать новое окно консоли КонсольКоманд можно по специальной клавише ГорячаяКлавишаВызоваКонсолиКоманд, возвращенное значение подставляется в позицию курсора.
Для нового окна консоли КонсольКоманд можно задать *начальный путь* или ячейку в СтруктураСущностей. 
Все окна используют один экземпляр [Контейнер]а, все окна в одном процессе, в одном приложении. Проект открывается и закрывается первым окном консоли КонсольКоманд, остальные окна только работают со структурой. 
Таким образом, приложение консоли КонсольКоманд это обычное приложение, в котором открываются диалоговые окна-консоли. Ввод и представление осуществляется текстом.
Команды можно вводить в виде скриптов. 
Операции можно запускать из консоли, вводя аргументы. В целом, получается такая же оболочка, как и графическая, но без ограничений и дополнительных проверок.

Надо бы попробовать сделать диалог-консоль. Видимо, это должен быть конечный автомат по нажатиям клавиш.

++++Виды и функционирование ячеек и связей
Из wiki:///V:/МоиПроекты/SIM/Работать%20здесь/Concept1/Concept1.wiki?page=ОЯчейках

+++++Обшие сведения
Ячейки и связи представлены в таблице записью, а в памяти - объектом класса. Ячейки разделяются на виды согласно назначению, чтобы охватить весь необходимый интервал возможностей. Связи функционируют в зависимости от ячеек, к которым они относятся.
Связь имеет идентификатор linkid, который начально = 0, а после записи связи в таблицу является идентификатором связи. Таким образом, связь с linkid = 0 не записана - не существует в таблице.
При слиянии списков связей из памяти и из таблицы, связи из памяти предпочтительнее связей из таблицы, так как версии более свежие.
Ячейка MCellB может сменить тип на MCellBds, и наоборот, при некоторых условиях. Ячейка MCellBt типа создается сразу как MCellBt, и может сменить тип на MCellB только после сохранения. 

+++++Поведение ячеек и связей
* Создание ячейки - создание новой ячейки.
* Загрузка ячейки в память - загрузка ячейки в память из таблицы или файла снимка.
* Получение данных ячейки - получение значения одного или нескольких полей ячейки
* Изменение данных ячейки - изменение значения одного или нескольких полей ячейки
* Получение связей ячейки - получение списка связей ячейки для последующего чтения. Запись в список связей ячейки не поддерживается.
* Получение связи - получение связи текущей ячейки с указанной.
* Создание связи - создание связи между текущей ячейкой и указанной.
Возлагается на код, обслуживающий ячейку
* Изменение связи - изменение связи между текущей ячейкой и указанной.
* Удаление связи - удаление связи между текущей ячейкой и указанной.
* Сохранение ячейки - запись в таблицу ячейки и ее связей
* Удаление ячейки - ячейка помечается удаленной, удаление откладывается на потом.
* Выгрузка ячейки - выгрузка ячейки из памяти. Следует удалить связи ячейки из памяти, если конечная ячейка связи не загружена в память, затем выгрузить саму ячейку.

+++++Обозначения
selectT(A) - получение связей ячейки А из таблицы
selectM(A) - получение связей ячейки А из памяти (списка связей контейнера)
selectM(AB)- получение связей между ячейками А и В из памяти
insertM(AB)- добавление связи ячеек в память
deleteT(AB)- удаление связей ячеек из таблицы

+++++MCellA
MCellA ячейки занимают минимальный объем памяти, представляют собой интерфейс к таблице БД. Работают очень медленно. Удобны для представления больших массивов данных.
Связи ячейки получаются слиянием выборки из таблицы связей с выборкой из списка связей контейнера, поэтому многие из этих связей не присутствуют в списке связей контейнера. Сохранение связей из контейнера в данном случае выполняют связанные с ними ячейки. 

Создание ячейки - создание новой ячейки. Ячейке присваивается уникальный идентификатор, она записывается в таблицу, добавляется в список ячеек контейнера.
Загрузка ячейки в память - Создается объект ячейки в памяти, из таблицы в память загружаются данные ячейки.
Получение данных ячейки - данные читаются из таблицы
Изменение данных ячейки - данные пишутся в таблицу
Получение связей ячейки :
selectT(A) + 
selectM(A) - поскольку в структуре могут существовать связи, не записанные в таблицу, например, ячейка А связяна с временной ячейкой В.
Получение связи - selectT(AB) + selectM(AB)
Создание связи - зависит от типа конечной ячейки.
insertM(AB) для MCellBds или MCellBt;
insertT(AB) для MCellA
insertT+insertM для MCellB
Изменение связи - зависит от типа конечной ячейки. 
updateM(AB) - MCellBds и MCellBt;
updateT(AB) - MCellA;
updateM + updateT - MCellB;
Удаление связи:
deleteM(AB) - MCellBds и MCellBt;
deleteT(AB) - MCellA;
deleteM + deleteT - MCellB;
Сохранение ячейки - Поскольку изменения ячейки и связей немедленно записываются в таблицу, ничего сохранять не нужно.Изменения связей, существующих только в памяти, сохраняются соответствующей ячейкой.
Удаление ячейки - ячейка помечается удаленной, удаление откладывается на потом.
Выгрузка ячейки - Поскольку связи ячейки не хранятся в памяти, то удалять нечего. Только выгрузить ячейку.

+++++MCellB
MCellB ячейки (с MCellB_CellSaveMode=MCellSaveMode_Default)
хранят данные и связи в памяти, кешируют запросы чтения, записывают в таблицу изменения ячейки и связей. 
Ячейка может сменить тип на MCellBds в любое время.


Создание ячейки - создание новой ячейки. Ячейке присваивается уникальный идентификатор, создается пустой список связей ячейки, она добавляется в список ячеек контейнера.
Загрузка ячейки - Создается объект ячейки в памяти, из таблицы в память загружаются данные и связи ячейки.
Получение данных ячейки - данные читаются из памяти
Изменение данных ячейки - данные записываются в память и в таблицу
Получение связей ячейки - selectM(A). Все связи из таблицы загружаются в память при загрузке ячейки, поэтому память содержит все связи ячейки.
Получение связи - selectM(AB)
Создание связи - зависит от конечной ячейки
insertM(AB) для MCellBds или MCellBt;
insertT+insertM для MCellB и MCellA
Изменение связи - зависит от конечной ячейки
updateM(AB) для MCellBds или MCellBt;
updateT+updateM для MCellB и MCellA 
Удаление связи - 
deleteM(AB) для MCellBds или MCellBt;
deleteT+deleteM для MCellB и MCellA 
Сохранение ячейки - Поскольку изменения ячейки и связей немедленно записываются в таблицу, ничего сохранять не нужно.
Изменения связей, существующих только в памяти, сохраняются соответствующей ячейкой.
Удаление ячейки - ячейка помечается удаленной, удаление откладывается на потом.
Выгрузка ячейки - Удалить связи ячейки из памяти, если конечная ячейка связи не загружена в память, затем выгрузить саму ячейку.

+++++MCellBds
MCellBds ячейки (с MCellB_CellSaveMode=MCellSaveMode_DelaySave) хранят данные и связи в памяти, кешируют запросы чтения и изменения данных и связей, записывают в таблицу состояния ячейки и связей специальной операцией. Автоматически сохраняются при выгрузке ячейки из памяти, при завершении работы. Работают максимально быстро, предназначены для работы на участках интенсивного изменения структуры.
Ячейка может сменить тип на MCellB только после сохранения.
Могут быть произведены из ячейки MCellB путем смены статуса или загружены сразу с таким статусом. Ввиду возможности наличия несохраненных связей перевод из MCellBds в MCellB следует выполнять только после Save(). Ограничить смену статуса в коде неудобно, так как он используется при загрузке ячейки из таблицы.

Создание ячейки - создание новой ячейки. Ячейке присваивается уникальный идентификатор, создается пустой список связей ячейки, она добавляется в список ячеек контейнера.
Загрузка ячейки - Создается объект ячейки в памяти, из таблицы в память загружаются данные и связи ячейки.
Получение данных ячейки - данные читаются из памяти
Изменение данных ячейки - данные записываются в память.
Получение связей ячейки - selectM(A). Все связи из таблицы загружаются в память при загрузке ячейки, поэтому память содержит все связи ячейки.
Получение связи - selectM(AB)
Создание связи - insertM(AB) Записываются в таблицу при сохранении ячейки.
Изменение связи - updateM(AB). Изменения связей, существующих в таблице, записываются при сохранении ячейки. Таким образом, связи в памяти более свежие, чем в таблице.
Удаление связи - зависит от конечной ячейки
deleteM(AB) для MCellBt;
deleteT+deleteM для MCellBds, MCellB и MCellA 
Сохранение ячейки - Сохраняются (update) связи, существующие в таблице, записываются (insert) связи, существующие только в памяти (linkid == 0), сохраняется ячейка.
Удаление ячейки - ячейка помечается удаленной, удаление откладывается на потом.
Выгрузка ячейки - Выполняется сохранение ячейки, затем выгружаются связи и сама ячейка.

+++++MCellBt
MCellBt ячейки (с MCellB_CellSaveMode=MCellSaveMode_Temporary) предназначены для создания временного участка в общей структуре ячеек.
хранят данные и связи в памяти, кешируют запросы чтения и изменения данных и связей, записывают в таблицу состояния ячейки и связей специальной операцией. Не сохраняются при выгрузке ячейки из памяти или завершении работы. Работают максимально быстро, предназначены для экспериментов, временных структур данных.
Ячейка может сменить тип на MCellB только после сохранения.

Создание ячейки - создание новой ячейки. Ячейке присваивается уникальный идентификатор временной ячейки, она добавляется в список ячеек контейнера. Ячейка НЕ записывается в таблицу.
Идентификатор временной ячейки располагается в специально выделенном диапазоне идентификаторов. Новый идентификатор получается подобно идентификаторам обычных ячеек.
Загрузка ячейки - Неприменимо для временных ячеек.
Получение данных ячейки - данные читаются из памяти
Изменение данных ячейки - данные записываются в память.
Получение связей ячейки - selectM(A). Память содержит все связи ячейки.
Получение связи - selectM(AB)
Создание связи - insertM(AB) Записываются в таблицу при сохранении ячейки.
Изменение связи - updateM(AB)
Удаление связи - deleteM(AB) 
Сохранение ячейки - записываются (insert) связи, существующие только в памяти (linkid == 0), сохраняется ячейка.
Удаление ячейки - ячейка помечается удаленной, удаление откладывается на потом.
Выгрузка ячейки - выгружаются связи и сама ячейка.


++++старые решения реализации кода движка - 
Из wiki:///V:/МоиПроекты/SIM/Работать%20здесь/Concept1/Concept1.wiki?page=ЗаметкаА
ЗАВЕРШЕНО
25.12.2011 12:21 

ЗАВЕРШЕНО
Представление базы в памяти
Можно временно создавать в памяти структуры ячеек, работать с ними, потом сохранять их в базу.
Каждой ячейке добавим поле - флаг, что ячейка временная.
При создании временной ячейки указать флаг, что ячейка не должна записываться в БД.
При создании связей проверять, если хотя бы одна из ячеек временная, связь не записывать в таблицу.
При модификации ячейки если флаг установлен, не обновлять данные в таблице.

Дальше. При сохранении структуры ячеек в БД сначала сохраняем ячейки, затем связи.
При записи ячеек проверяем, что ячейка существует в таблице. Если нет, создаем ячейку, иначе - обновляем данные.
При записи связей аналогично.
Для получения правильных идентификаторов ячеек в getFreeCellID нужно учитывать временные ячейки в списке контейнера - получать максимум из таблицы ячеек, и получать максимум из списка ячеек контейнера. Выбирать наибольшее и из него делать новый идентификатор.

Как быть в этом случае с методами, экспортом методов в ячейки и всем остальным? 
Надо определить, когда ячейку можно удалить, а когда она должна существовать в базе. Во всяком случае, это определяет пользователь.

ЗАВЕРШЕНО создание ячейки в контейнере
При создании ячейки перед добавлением в список ячеек контейнера нужно добавить в ячейку ссылку на контейнер. - контейнер делаем статическим членом, для ВАР6_МультиКонтейнера только. 








      

