++ Итератор Лога
[template: ШаблонКарточкиГлоссария]
Состояние: [В РАЗРАБОТКЕ] - переработать в связное описание сущности
Входит в: [//ПодсистемаЛога]

Механизм навигации по записям ЗаписьЛога между СеансЛога и ФайлЛогаСолюшена. 
Только для чтения лога. Запись в лог выполняют другие механизмы.

+++Используется в
* todo.глоссарий.форма: Перечислите здесь страницы концепций, в которых используется сущность, и роль сущности в этой концепции. Например: Концепция Х - помывка слона.
 
+++Версии
* todo.глоссарий.форма: Создайте новую страницу для версии описания сущности, добавив к имени "Версия0". Так осуществляется поддержка версий страниц глоссария. 

+++Обязанности
* todo.глоссарий.форма: Перечислите обязанности сущности здесь.
* 

+++Сущности предметной области
* todo.глоссарий.форма: Перечислите выявленные сущности предметной области здесь.
* 

+++Соответствующий класс кода
 todo.глоссарий.форма: Укажите здесь соответствующий класс кода проекта, если известен.
++++Свойства - данные
++++Методы

+++Дополнительная информация 
* Чтение лога Солюшена. 
    * todo.концепция.лог: Какие функции входят в Чтение лога?
    * Это такие же функции, какие выполняет база данных при работе с таблицей: выборка по условиям на значения полей, сортировка, упаковка данных в объекты записей лога. INSERT, UPDATE, DELETE тут не нужны, только SELECT.
    * очевидно, сортировка записей по хронологии  и по ИдентификаторСеансаПользователя. Хотя я не уверен.
    * возможно, не все данные записи лога востребованы при анализе. Тогда можно загружать только нужные данные, чтобы не занимать память.
    * При чтении лога нужно найти начало полезных записей. Оно может располагаться в текущем ФайлЛогаСолюшена или в одном из предыдущих ФайлЛогаСолюшена. Значит, надо их открыть и прочитать. Не занимая существенно оперативную память.
Значит, нужно получать имена этих предыдущих файлов как последовательный список.  

+++Итератор лога
* Поскольку лог одной ТранзакцияСолюшена может занять очень много места, он может не поместиться в один ФайлЛогаСолюшена. Поэтому для работы с транзакциями нужен итератор записей лога в пределах всего СеансЛога. 
* Все ШапкаФайлаЛога включить в СеансЛога в ИтераторЛога. По ним и искать нужный ФайлЛогаСолюшена для ИдентификаторЗаписиЛога.
* * В ИтераторЛога сделать функцию Найти Файл лога по ИдентификаторЗаписиЛога.
* Итератор должен иметь функцию получения ЗаписьЛога по ее ИдентификаторЗаписиЛога без перевода позиции записи лога на нее. Так как это позиция чтения лога. Это не так просто - это может быть тот же файл или другой.
* Не сделать ли ИтераторЛога отдельным классом в составе МенеджерЛога?
    * Пока сделаем просто группой функциональности в МенеджерЛога. Потом если все будет гладко, перенесем в отдельный класс/объект и сделаем доступ к нему через проперти.
* Как ИтераторЛога в СеансЛога будет собирать список Файлов Сеанса лога, когда создаются новые ФайлЛогаСолюшена?
    * При создании нового ФайлЛогаСолюшена его надо включить в объект СеансЛога ИтераторЛога. Или перечитать заново весь СеансЛога, если так будет проще. 
* Есть идея реализовать чтение Записей файла лога через паттерн Итератор. Это для foreach, только можно вверх или вниз перемещаться. Такой итератор будет навешиваться поверх потока файла лога, как StreamReader это делает.
И просто переходить от одной записи лога к другой. Правда, классов дополнительных для этого надо много создавать.
А сама Запись лога должна предоставлять поток для чтения или записи данных ассоциированных объектов. Возможно, таких объектов будет несколько. Тогда писать в эти потоки придется строго по очереди. Это сложно контролировать, лучше избегать такого.
    * См. Итератор: [file:///V:/МоиПроекты/ДвижокТапп/Материалы/Построение итератора.zip]

++++Ограничение общего размера лога - выявить функции Итератора тут
* Если общий размер КаталогЛоговСолюшена превышает установленный предел, или место на диске закончилось, то надо удалить файлы старых сеансов лога. Начиная с самых старых сеансов, постепенно, по мере потребности.
* Удалять допускается только сразу все файлы сеанса - весь сеанс целиком, вместе с ПапкаСеансаЛога.
    * После удаления сеанса лога надо скорректировать содержимое Итератора в части СеансЛога - либо пересчитать сеансы, либо просто удалить сеанс из этого списка Итератора. 
* А если файлы лога внутри текущего сеанса Движка не помещаются на диск, а других сеансов нет, удалять нечего, то как тогда быть? done.концепция.лог: Тут надо перечислить варианты и выбрать лучший.
    а) *Выбрано:* Вывести сообщение об ошибке и Завершить работу Движка.
    б) Удалить самый старый файл лога в текущем сеансе и продолжить работу - Неприемлемо, так как нельзя будет откатить транзакции ТранзакцияСолюшена, начатые в этом файле. И еще много чего нельзя будет, поскольку СеансЛога это множество взаимосвязанных ФайлЛогаСолюшена.
    
++++Итератор по логам - С2
Для перехода по логам туда и обратно нужен такой специальный ИтераторЛога.
Нужен переход от СеансЛога к сеансу, от ФайлЛогаСолюшена к файлу, от ЗаписьЛога к записи.
И хорошо бы одним объектом итератора.
То есть, лог надо представить в виде хронологической последовательности записей ЗаписьЛога, группированных в файлы ФайлЛогаСолюшена, которые группированы в сеансы СеансЛога.
И вот по такой ленте надо иметь возможность перемещаться определенным образом.
todo.концепция.лог: Как именно - пока неясно, надо выяснить и описать.
И делать это с помощью одного объекта - итератора.
И еще переходить к неким именованным позициям -  ТочкаСохранения - они пока не придуманы.

Хотя предполагается, что эта лента не должна иметь разрывов внутри себя, а обрезаться должна только по краям и строго по границам сеансов, но это может в реальности не соблюдаться ввиду порчи или утери файлов лога.
Тогда правильность общей структуры этих контейнеров нужно контролировать, по мере прохода по ним. Но не заранее.

СообщениеЛога должно быть реализовано как объект ЗаписьЛога с потоком данных.
ФайлЛогаСолюшена можно представить как поток объектов сообщений лога.
Можно создать класс файла лога и в нем реализовать такой итератор по файлу.
Или соединить все файлы сеанса лога в один общий итератор? Это было бы более удобно, так как файлы внутри сеанса представляют один поток сообщений лога, который разбивается на отдельные файлы ограниченного размера. По размеру, а не по любым другим свойствам.
Но вообще-то это зависит от операций с логом. Например, Откатить изменения к  ТочкаСохранения N - это код вроде while(N!=X) { X = getPrevRecord(..); ...} И соответственно потом уже все функции делать под эти требования. Хотя сам базовый набор функций конечно, пригодится. Но не весь.

Записи лога в файле лога надо организовать в двусвязный список, чтобы можно было переходить по этому файлу и вперед и назад. Для этого надо в каждой записи иметь ссылку на предыдущую и следующую?
    * Можно использовать смещения относительно начала файла подобно адресам в памяти.
    * Можно каждую секцию ЗаписьЛога оформлять заголовком, и относительно него считать смещения в файле для передвижения вперед и назад.
    * Для перемещения вперед надо в заголовке секции хранить размер секции для перехода на заголовок следующей секции.
    * Для перемещения назад надо либо в заголовке текущей секции хранить смещение для перехода к заголовку предыдущей секции. Либо в формат секции добавить еще и признак окончания секции - хвостовик секции, и перед ним хранить смещение для перехода на заголовок секции. То есть, это получится действие подобно переходу вперед, симметричное - тоже маркер, но конца, а после него - смещение для перехода на заголовок секции. 
    * Тут проблема в том, что сообщение лога тоже надо читать. Хотя, возможно, не полностью, но чтобы определить что оно содержит. И вот исходя из этого, надо решить, как добыть из сообщения ссылку на предыдущее сообщение лога.
    * todo.концепция.лог: Надо составить диаграмму - строение файла лога. И на ней показать, как реализовать эту навигацию по файлу лога. 

++++Построение классов итераторов - С2
Рассматривается построение классов в части итераторов
* (Объект) Менеджер лога
    * (Набор функций) Итератор сеансов лога - перебирает сеансы лога солюшена
    * (Список <Сеанс лога>) Список сеансов лога  - сортированный список путей папок сеансов лога, заполняется при открытии Солюшена.
    * (Сеанс лога) Текущий сеанс лога - экземпляр сеанса лога, в который сейчас ведется запись лога. Работает только на запись.
    * (Сеанс лога) Сеанс лога итератора - экземпляр сеанса лога, в котором сейчас идет чтение или поиск лога итератором. Работает только на чтение. Сейчас это должен быть тот же сеанс, что и текущий сеанс лога? 
    
* (Объект) Сеанс лога
    * (Набор функций) Итератор сеанса лога - перебирает файлы лога внутри сеанса
    * (Список <Файл лога>) Список файлов лога - список путей к файлам лога сеанса, заполняется при инициализации объекта.
    * (Файл лога) Текущий файл лога - экземпляр файла лога, в котором сейчас ведется чтение или запись.
        * todo.концепция.лог: Надо отслеживать, чтобы корректно обрабатывать ситуацию, когда один и тот же файл лога является и читаемым и записываемым - когда он и читается для отката транзакции ТранзакцияСолюшена, и является логом, в который выводится ход работы Движка в этот момент.
        * todo.концепция.лог: Если сеансы лога по работе делятся на только запись и только чтение, не следует ли добавить поле Read Only режима, чтобы контролировать такое чтение и запись? Это должно предохранить лог от ошибочной записи.
        
* (Объект) Файл лога
    * (Объект) ШапкаФайлаЛога
    * прочее
    * (Набор функций) Итератор записей в файле лога
    * (Список <Запись лога>) Список записей лога
    * Возможно (Stream) Поток файла лога - чтобы иметь раздельные позиции чтения и записи файла    
    
* Итератор сеансов лога перебирает сеансы лога. Записи лога пока перебираются только в пределах текущего сеанса лога. Использует функции итератора сеанса лога.
    *  todo.концепция.лог: Надо решить, следует ли перебирать записи в соседних с текущим сеансах лога, или нет.
* Итератор сеанса лога перебирает файлы сеанса лога, и перебирает записи всех файлов лога этого сеанса. Использует функции итератора файла лога.
* Итератор записей в файле лога перебирает записи внутри файла лога. Если достигнут конец или начало списка записей, функция возвращает null.


