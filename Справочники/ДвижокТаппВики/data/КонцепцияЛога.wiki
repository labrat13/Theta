++ Концепция Лога
Входит в: ПодсистемаЛога
[//ДОПОЛНИТЬ] - добавить новые тексты
[//ПЕРЕДЕЛАТЬ] - вроде бы сложилась концепция, хотя еще не все готово. Надо собрать весь механизм и оценить где еще нужно доделывать. А то сейчас в этой куче непонятно что уже готово, а что надо изобрести.  
    * Свести все наброски в одну концепцию.
    * Ответить на вопросы.
    * разметить сущности глоссария, собрать все в связный текст. ВременныйГлоссарийПодсистемыЛога.

    
++++Описание концепции
Описывает подсистему лога

++++Состояние
* 05.11.2017 08:59 
    * Сколько страниц вики входит в КонцепцияЛога? Мне просто интересно оценить таким образом объем концепции.
        * 52 страницы сейчас. 
    * ТранзакцияПользователя это подкласс ТранзакцияСолюшена. ТранзакцияСолюшена это внешний термин, имеющий хождение за пределами [Движок]а. Пользователь работает именно с ним, а не с чем-либо иным. Здесь же используется название ТранзакцияПользователя, обозначая, что транзакцию делает конкретный пользователь.
        * Предлагается использовать термин  ТранзакцияСолюшена, чтобы сгруппировать тексты о транзакции, и отделить их от транзакций БД. Это позволит немного свести воедино КонцепцияЛога. Я уже просмотрел и исправил большую часть текстов о транзакциях, но могли  еще остаться недосмотренные.
    * ТемаНеожиданноеПрекращениеРаботыДвижка - дополнить и проработать. Есть еще материалы, я натыкался на них сегодня.
    * ТранзакцияПользователя и вообще Транзакция - и Транзакция БД - образовали в концепции плотный клубок, так, что не поймешь, где что лежит и что из чего следует. 
        * Надо разделить эти понятия. Сейчас это вручную делается, и надо читать контекст.
        * Мне очень хочется распечатать все страницы КонцепцияЛога на бумагу и вручную их править, собрать из них СводноеОписаниеДляТранзакцияСолюшена. Потому что все страницы вики одинаковые, и я не могу их раздельно запомнить. 
            * А это сводное описание позволило бы собрать все идеи вместе, заменив их в текстах на ссылки на эту сборку? И потом в этой сборке их искать? Но там они потеряют свой контекст источника, и нельзя будет определить, чем вызваны эти предложения. Так что это неудачное решение.
            * И по ссылкам в текстах придется опять лезть в вики. Хотя, это способ определить границы подсистемы и ее взаимосвязи с другими частями [Движок]а.
            * А потом вручную все перепечатывать обратно в вики? Хотя там немного перепечатывать будет - если все проработать и распределить по сущностям глоссария - то менее половины сегодняшнего объема текстов.
            * Разве что как эксперимент это провести, чтобы узнать, будет ли это полезным способом?
            * А какой объем вообще у ПодсистемаЛога? 
* 29.10.2017 12:30 Есть идея сделать прототип подсистемы лога в отдельном проекте. Так я смогу быстро пробежать вперед, получить результат как материал для дальнейшего анализа. И код уже будет написан, и можно будет просто копировать его в проект движка потом. И можно будет освободиться от непоняток по поводу конкретной реализаци подсистемы лога. И уже заняться реальными проблемами в этой теме.
    * То есть, вот эту подсистему я реализую в коде, только ее. И кусок инфраструктуры контейнера или солюшена, как необходимую часть работы.
    * А что я должен получить в итоге этой работы?
        * подсистему лога, которая работает с несколькими пользователями одновременно или по очереди.
        * Можно ли ее использовать отдельно от движка, как самостоятельную функциональную единицу?
            * если только дополнить ее конкретными сущностями, которые надо хранить в логе.
            * Пожалуй, можно, но как комплект классов. От которых можно наследовать более пригодные для приложения классы.
        * А у меня в приложениях где могут быть несколько пользователей внутри одного процесса? А с несколькими процессами эта штука не работает - нужен монопольный доступ к солюшену.
            * Для СервернаяВерсияДвижка это подойдет, но у меня сейчас не серверный вариант разрабатывается. 
        * *Решение:* Тогда надо попробовать, если эту работу можно повторно использовать. В любом случае, это даст некоторый материал для продвижения вперед.
    * Следствия: 
        * Нельзя полноценно собрать модель, поскольку нет остального Движка - классов идентификаторов, ячеек, версий, итд. Поэтому часть проблем останется невыявленной, и придется напрягать фантазию, чтобы проводить тесты на этой модели.
        * Модель останется недостаточно детальной и полной, но будет полезна для выявления общих решений и проблем с ними. Поэтому непосредственно повторно использовать ее нигде нельзя - только как пример архитектурных решений. И очень специфичных, для БД и Тапп.   
* 27.02.2017 11:53:04 - Перенес материалы в карточки сущностей временного глоссария. А то эту страницу невозможно читать - слишком длинная. Теперь надо все эти страницы сущностей переработать - дополнить и разнести факты оттуда в другие страницы сущностей. А то там полусырой материал сейчас.
* 25.02.2017 21:55:26 - Очень большая концепция, всю не охватить, попробую один кусок сделать.
    * Возьму самый простой понятный кусок - файлы лога.
    * Надо собрать сущности по нему из текста концепции в карточку глоссария.
        * МенеджерЛога
        * [//КлассФайлЛога] - натаскал, переработать материалы, разрулить тодо и убрать их оттуда и из концепции.
        * [//ИтераторЛога] - натаскал, переработать материалы, разрулить тодо и убрать их оттуда и из концепции.
        * [//КлассСеансЛога] представляет [//СеансЛога] и [//ПапкаСеансаЛога]  - переработать материалы, разрулить тодо и убрать их оттуда и из концепции. 
    * Потом надо сделать классы и наметить свойства и операции для них.
    * ИтераторЛога должен только читать записи ЗаписьЛога. А если добавить в него ведение файлов и сеансов, то надо и остальные операции тоже в нем реализовывать. Все же надо разобраться, где будет храниться КоллекцияСеансовЛога из КлассСеансЛога: в МенеджерЛога или в ИтераторЛога? Пока это не решено, ИтераторЛога нельзя проектировать и представлять себе полноценно - тут слишком много неувязок.
        * *Решено*: В МенеджерЛога. ИтераторЛога будет просто группой функций сейчас.  

* 14.02.2017 14:08:37 - Надо свести материалы в единую концепцию.
* Нужно разработать прототипную версию концепции подсистемы лога, не дожидаясь окончания проработки всех материалов по этой теме. Поскольку всю ту кучу сразу не провернуть, я дистанцируюсь от нее и проектирую прототип на меньшем материале.
    * 14.02.2017 13:40:44 Это было успешной идеей. Отрыв от общего контекста позволил создать маленькую модель-прототип. Ее скелет затем был использован для постройки следующей версии концепции.
    * 17.02.2017 16:07:36 question: Как бы сделать ПодсказкаМетодическая из этой штуки? Чтобы она подсказывала мне решение проблемы Что делать, чтобы ...
        * Для начала надо записывать эти подсказки в отдельный документ. Потом можно собрать их в БД и прицепить запросы на подсказки.   
* Тут в основном материалы для принятия решений, а сами решения еще не приняты и только намечаются. Эту подсистему предлагается доделывать последней, она зависит от конструкции всех остальных подсистем. Хотя это потому, что она концептуально не спроектирована. Ведь это всего лишь модуль с входами и выходами; надо вынести все проблемы наружу и тогда можно реализовать саму подсистему, а проблемы разруливать обвязкой модуля, всякими енумами. Ну, это такое мнение, поверхностное.
    * И, как следствие, возникла идея реализовать ПодсистемаЛога сменным модулем с собственной системой версий. А заодно и остальные подобные подсистемы.
    * Когда я инкапсулировал содержание записей лога в абстрактный объект, чтобы избавиться от них и их зависимостей, я смог перейти к разработке остальных частей ПодсистемаЛога. И в них обнаружилась собственная куча проблем, с собственными зависимостями. И вот теперь я эту кучу разгребаю.
        * Надо бы этот способ инкапсуляции проблем тоже внести в методику автоматизации решения задач.
* И что-то не получается никак разнести материал по сущностям. Тут надо какой-то другой подход применить.
    * Можно для начала определить темы, которым соответствуют эти тексты, а потом уже их группировать и разносить
    * Возможно, незачем разносить. Это ведь общая концепция, она должна описывать процесс, а не отдельные его элементы. Потом переработаем и разнесем тексты в сущности в соответствии с их ролью в процессе.
        * Не разносить, только копировать, и оставить все в концепции. Эти концепции еще будут меняться, и вытаскивать из них информацию в общую кучу при каждой переделке движка - много путаницы получится.
        * Но ведь все равно придется переделывать всю концепцию для новой версии Движка? Тогда и вики дублируем, как версию основной нынешней вики, специально для новой версии движка.  
* Вроде бы накидал, развил. Теперь надо моделировать, чтобы выявить пробелы в модели. Надо отдельную вики, что-ли? Или УМЛ-диаграммы рисовать? Как дальше модель эту обрабатывать?
    * Вроде бы надо теперь ее представить как цельный объект, и пробовать запускать ее функции как бы в работе движка. Правильно дергать за функции, как при настоящей работе. И смотреть, что и как происходит и почему не получается.
    * Для этого надо собственно собрать модель. И выписать в список все эти воздействия на нее. И последовательности воздействий. Это диаграмма УМЛ такая есть, вот на нее надо это все нарисовать и проработать. Большая получится диаграмма. 
* 06.09.2016 10:36  Поставил на винХР диаграммер тогетерсс, попробую на нем диаграммы представить. Но лучше все же текстом пока их описать. 

+++Задачи - распарсить на факты и задачи и разнести по темам
* todo.концепция.лог: Упорядочить понятия СеансЛога СеансДвижка СеансПользователя. Внести изменения в тексты здесь и по всей вики.
* todo.концепция.лог: Полностью переработать концепцию транзакций в логе. Отделить ее от транзакций БазаДанныхСолюшена (ТранзакцияБД). ТранзакцияСолюшена должны полностью покрывать весь Солюшен, а не только СтруктураСущностей.
* todo.концепция.лог: После завершения переделки концепции лога переделать алгоритмы операций менеджера лога, приведенные здесь, поскольку они устарели.
* todo.концепция.лог: Составить список типов сообщений лога - как страницу, для дальнейшего наполнения. Привести ссылку здесь. Это должен быть и енум типов сообщений одновременно.
* todo.концепция.лог: придумать как описывать каждую функцию движка для лога - как описывать изменяемые сущности и их значения.
    * Это надо создать отдельную главу или страницу для описания этой технологии. 
    * для каждой операции движка надо продумать, что будет изменяться и что надо вывести в лог чтобы эту операцию можно было повторить или откатить по логу. 
    * Как назначать функциям сообщения лога.
* todo.концепция.лог: Придумать общий формат лога. Он в целом есть, но надо его собрать воедино.
* done.концепция.лог: Придумать управление файлами лога, оптимальную длину ФайлЛогаСолюшена.
* todo.концепция.лог: Придумать как выполнять парсинг лога, откат по логу. Для ИнтерпретаторЛога.
* todo.концепция.лог: Придумать, как назвать вместе файлы лога и снимки. Как собрать все вместе, как использовать такой бекап-копию солюшена.
* todo.концепция.лог: Собрать тексты из сборок в единый документ-концепцию, удалить дубликаты текстов, затем снова разнести по сборкам и уже после этого поместить в страницы описания сущностей глоссария.
* todo.концепция.лог: Осмотреть существующий КодДвижка и описать, что там и как сделано, в отдельном отчете. Потом разнести по сборкам концепции и обработать.
* todo.концепция.лог: Надо продумать использование Лога для анализа и отката ТранзакцияСолюшена. Это большая и важная тема в этой концепции. И формат лога надо доделать - он должен обеспечивать ведение транзакций.
    * Это значит, нужно иметь возможность переходить вперед и назад по сеансам лога, файлам лога, записям сообщений лога. И между точками ТочкаСохранения в логе, если они будут там реализованы.
    * А как эти ТочкаСохранения выглядят, как с ними работать? Зачем они нужны, что делать с их помощью? Это все надо описать сейчас, а этого нет пока.
    * Пока формат сообщения лога не разработан, эту навигацию надо в сообщении лога поддерживать.
    * А ТранзакцияСолюшена пока не откатываем через лог - не придумано как это сделать. 
* todo.концепция.лог: Надо представить эту подсистему как некий объект в общей схеме подсистем. Диаграммой или схемой со связями.
* todo.концепция.лог: Было предложение взвалить на лог ведение транзакций ТранзакцияСолюшена, и сделать лог прослойкой между АдаптерБД и [Контейнер]ом. Надо подумать об этом.
    * При этом собственно работа контейнера с БД никак не меняется, лог прозрачно встраивается между ними.
    * Но Лог также обрабатывает и откатывает сложные ТранзакцияСолюшена. Фактически он дополняет возможности используемого СерверSQLБД по обслуживанию транзакций Солюшена. Так как существующие СерверSQLБД не могут работать с вложенными транзакциями в такой степени, как это нужно для выполнения методов Тапп.  
* todo.концепция.лог: Надо обсудить структурный расклад ПодсистемаЛога - что есть, и как оно взаимодействует. Без этого вся концепция не складывается. 
* todo.концепция.лог: Надо принять решения по выбору вариантов общей структуры ПодсистемаЛога, а то вся концепция этими вариантами и их обсуждением полна, а толку нет.
* todo.концепция.лог: Материалы про сеансы надо перенести в работу с Солюшеном. Именно там они должны создаваться и существовать. А применительно к логу свойства сеанса описывать в КонцепцияЛога, а в работу с Солюшеном положить ссылку на этот текст свойств сеанса в ПодсистемаЛога.
* todo.концепция.лог: Нужно описать, как будет работать ПодсистемаЛога. От запуска движка до завершения работы движка. 
    * Надо описать такие процессы для каждой подсистемы и взаимоувязать их потом.    
    * Этапы работы подсистемы:
        1. Загрузка Солюшена
        2. Работа Солюшена
        3а. Нормальное завершение работы Солюшена
        3б. Аварийное завершение работы Солюшена
        
19.02.2017 14:49:34 Задачи и идеи
* СеансПользователя можно представить некоторым объектом, который содержит список (или словарь) транзакций КоллекцияТранзакцийПользователя.
* СеансПользователя помещается в КоллекцияСеансовПользователей для единообразного обслуживания всех пользователей Движка.
* Объект ТранзакцияПользователя содержит поле ИдентификаторЗаписиОНачалеТранзакции типа ИдентификаторЗаписиЛога. В этом поле хранится идентификатор ЗаписьЛога о начале транзакции. Хотя этот объект ТранзакцияПользователя хранится не в логе, он передается в лог для доступа к информации о транзакции. 
    * todo.концепция.лог: К какой подсистеме относится и где располагается КоллекцияТранзакцийПользователя?
        * МенеджерСолюшена.КоллекцияСеансовПользователей.СеансПользователя.КоллекцияТранзакцийПользователя.ТранзакцияПользователя - так это логично выглядит.
        * Какая подсистема вообще обрабатывает ТранзакцияСолюшена пользователя?
            * ТранзакцияСолюшена начинаются отдельной командой пользователя. 
            * Потом они либо подтверждаются, чтобы уже от них избавиться. Либо отменяются - и тут в дело вступает МенеджерЛога.ИнтерпретаторЛога, который собственно и откатывает действия ТранзакцияСолюшена.
            * Но транзакции затрагивают весь Солюшен. И откат также затрагивает весь Солюшен.
            * todo.концепция.лог: Надо понять взаимосвязи между подсистемами при работе ТранзакцияПользователя. Тогда будет проще понять, какая подсистема для них больше подходит.
            * Возможно, подсистема Методов была бы подходящей? Но ее в Тапп версии Бар нет, Поэтому этот набор функциональности нужно просто отделить в какой-то подсистеме.   
* todo.концепция.лог: Назвать объект транзакции ТранзакцияПользователя и указать остальные поля объекта ТранзакцияПользователя.
* todo.концепция.лог: Спроектировать строение класса СеансПользователя.
* КоллекцияСеансовПользователей - Словарь объектов СеансПользователя хранится где-то в МенеджерСолюшена?
    * todo.концепция.лог: Где именно хранится КоллекцияСеансовПользователей? К какой подсистеме относится?
        * Эта же подсистема выдает КонсольПользователя вызывающему коду?  
* Нужна КонстантаМаксимальноеЧислоВложенныхТранзакций в НастройкиСолюшена. Если число вложенных ТранзакцияСолюшена - число элементов КоллекцияТранзакцийПользователя в СеансПользователя превышает этот предел, выдается сообщение о Достижении предела вложенности транзакций. Это предотвратит бесконечную рекурсию.
    * todo.концепция.лог: Но как потом такая ошибочная рекурсия должна откатываться в ИнтерпретаторЛога?
* todo.концепция.лог: придумать, что из этого следует: ОбсуждениеСхемаМногопользователейТаппБар
* НомерФайлаЛога не включать в ИдентификаторЗаписиЛога.
* В ШапкаФайлаЛога хранить ИдентификаторЗаписиЛога первой ЗаписьЛога этого ФайлЛогаСолюшена.
* Все ШапкаФайлаЛога включить в КлассФайлЛога в СеансЛога в ИтераторЛога. По ним и искать нужный ФайлЛогаСолюшена для ИдентификаторЗаписиЛога.
* В ИтераторЛога сделать функцию Найти Файл лога по ИдентификаторЗаписиЛога.
* Итератор должен иметь функцию получения ЗаписьЛога по ее ИдентификаторЗаписиЛога без перевода позиции записи лога на нее. Так как это позиция чтения лога. Это не так просто - это может быть тот же файл или другой.
* todo: Вероятно, ЗаписьЛога будет разных форматов, чтобы хранить разные классы СообщениеЛога. Например, для ТранзакцияПользователя.      
    * Вот как парсить ЗаписьЛога о начале транзакции?
    * Об этом будем думать потом. Сейчас важно сформировать требования к этому всему.
* ИдентификаторЗаписиЛога типа Int64.
* В МенеджерЛога добавить поля:
    * Int64 СчетчикИдентификатораЗаписиЛога
    * Int16 СчетчикФайловЛога - хватит и такого, так как файлов лога не ожидается быть более 999
* ПодсистемаЛога в КодДвижка вынести в собственное подпространство имен, вместе с МенеджерЛога. Так как она модульная, то и помещаться будет в собственном пространстве имен.
    * Можно в имя пространства имен включить номер версии? Чтобы различать версии в коде проекта.
        * Вроде бы незачем? Разве только для того чтобы не забыть, какая версия подсистемы используется? 
* Не сделать ли ИтераторЛога отдельным классом в составе МенеджерЛога?
    * Пока сделаем просто группой функциональности в МенеджерЛога. Потом если все будет гладко, перенесем в отдельный класс/объект и сделаем доступ к нему через проперти.
* Хорошо бы всю концепцияЛога переписать в отдельную чистовую версию, а все увязки и обсуждения оставить в этой грязной версии. Чтобы и читать легко было, и исходные материалы посмотреть можно было, если понадобятся.
* Как ИтераторЛога в СеансЛога будет собирать список Файлов Сеанса лога, когда создаются новые ФайлЛогаСолюшена?
    * При создании нового ФайлЛогаСолюшена его надо включить в объект СеансЛога ИтераторЛога. Или перечитать заново весь СеансЛога, если так будет проще.          



+ План документа
Сюда записывать более-менее сложившееся, переработанное представление о теме. Чтобы получалось намного меньше текста в итоге. Наброски размещать пока во временных страницах, которые удалять сразу после завершения переработки.
* ОбщиеСведенияОЛоге - описывает общие сведения об архитектуре подсистемы
    * Общее Представление О Логе
    * Обязанности Подсистемы Лога 
* СеансыИТранзакцииВЛоге - описывает пользователей, сеансы и транзакции в логе.
    * Сеансы В Логе - описывает организацию сеансов всех типов
    * Транзакции В Логе - описывает реализацию транзакций с помощью лога.
* ОрганизацияЛогаДвижка
    * Файловая Система Подсистемы Лога - описывает файловую структуру подсистемы лога Солюшена.
    * Структура Лога Солюшена - описывает организацию хранения сообщений лога.
* РеализацияПодсистемыЛога - содержит сведения о реализации подсистемы в коде проекта.
* ГлоссарийПодсистемыЛога - каталог сущностей ПодсистемаЛога.
 
+Переработка концепции лога - работать здесь!
Материалы из страниц-набросков уже натасканы сюда и распределены по разделам.
Разделы помечены маркерами: С1 - вторая версия, С2 - третья версия прототипа концепции.
Теперь надо их свести в единое представление, увязать и снабдить ссылками на сущности.

++Тема Общие сведения о логе
+++Классификация операций ApiSystemLayer - в какой раздел поместить
Операции бывают:
1 не изменяющие состояния объектов
  - поиск элементов
  - чтение свойств
  - добавить...
2 изменяющие состояние единственного объекта
3 изменяющие состояние нескольких объектов 


++Тема Организация лога
+++Файловая система лога и хранение лога - дополнить
++++Каталог лога КаталогЛоговСолюшена - дополнить
См. КаталогЛоговСолюшена.

++++Папка сеанса лога
См ПапкаСеансаЛога.

++++Файл лога
См ФайлЛогаСолюшена.

++++Кусок файловой системы Солюшена - наброски
done: После завершения работы над концепцией добавить это в соответствующее место в глоссарии.
* КаталогЛоговСолюшена
    * ПапкаСеансаЛога
        * ФайлЛогаСолюшена  

+++Устройство лога - переработать
++++Концепция сериализации - памятка
Концепция сериализации предполагает, что каждая сериализуемая сущность есть некий контейнер, реализуемый сериализуемой сущностью.
Таким образом, лог хранит состояние ячейки или связи как стандартный сериализованный дамп объекта в памяти. Такой дамп может быть десериализован обратно в объект ячейки.

+++++сериализация в двоичный файл - памятка
Сериализация неких объектов в двоичный файл довольно простая: 
Выводятся все объекты поочередно, в виде записи, состоящей из набора полей фиксированной или переменной длины. 
* Каждой записи предшествует байт-описатель типа записи, он же контрольный байт, 
* слово размера записи, 
* в записи поля фиксированного размера расположены перед полями переменного размера, 
* из каждой записи можно восстановить объект. 
Такая сериализация позволяет Выгрузитьи загрузить объекты. Разумеется, если версии подсистем и движка в целом совпадают, поэтому ДвоичныйФайлЛога должен хранить номер версии движка, обычно в ШапкаФайлаЛога.

++++Структура лога - устарело, переработать, перенести?
Логически лог состоит из последовательности сеансов СеансЛога, упорядоченных по хронологии. СеансЛога описывает работу [Движок]а от включения до выключения.
СеансЛога содержит в хронологическом порядке сообщения СообщениеЛога о событиях СобытиеЛога.
СообщениеЛога могут быть сгруппированы в ТранзакцияСолюшена. ТранзакцияСолюшена могут быть вложены друг в друга.
Лог реализован как последовательность записей ЗаписьЛога о событиях СобытиеЛога.
Каждая ЗаписьЛога содержит таймштамп, код события, текстовое описание события, состояние элементов, участвующих в событии.
События СобытиеЛога разделены на КатегорияСообщенияЛога, можно записывать только выбранные категории КатегорияСообщенияЛога, регулируя таким образом *детализацию лога*.


+++++Формат лога - устарело
Лог семантически можно представить как упорядоченный по хронологии список сессий СеансЛога, содержащих вложенные сообщения СообщениеЛога и ТранзакцияСолюшена.

Неправильный упрощенный пример лога:
- начало сеанса лога
 - сообщение
 - сообщение
 - начало сеанса пользователя ПА
 - начало транзакции ПАТ1
  - начало транзакции ПАТ2
  - сообщение начала функции ПАФА
   - сообщение начала функции ПАФБ
   - сообщение завершения функции ПАФБ
  - сообщение завершения функции ПАФА
  - конец транзакции ПАТ2(commit  или rollback)
  - сообщение некоторой операции
 - конец транзакции ПАТ1(commit  или rollback)
- начало сеанса пользователя ПБ
- 
- конец сеанса пользователя ПА
- конец сеанса пользователя ПБ
- конец сеанса лога
 
++++Реализация подсистемы лога
При переделках в КодДвижка необходимо переделывать код ПодсистемаЛога и код УтилитаПросмотраЛога. Это главный недостаток подсистемы лога, поэтому делать ее будем в последнюю очередь.
* Для вывода в [Лог] пока можно создать функцию-местодержатель, а после доработки КонцепцияЛога переписать весь код.
* В платформе NET Framework2 есть класс GC, в нем есть статическая функция получения текущего размера кучи. Этой функцией можно пользоваться при *диагностике* в [Лог]е.

+++++Инициализация лога
* МенеджерЛога должен инициализироваться раньше, чем подсистема БазаДанныхСолюшена и вообще лучше самым первым - чтобы в него писать остальные действия.
* Запускается Движок. Если [Лог] удалось открыть, то в него должны быть записаны сведения о начале СеансДвижка. Соответственно, если подсистемы целиком не удалось инициализировать, в [Лог] должно быть записано сообщение об ошибке и о завершении СеансДвижка.
* [Лог] создается при создании объекта [Движок]а, в конструкторе.
Закрывается соотв-но в деструкторе. В [Лог] пишутся все операции, исключения и комменты пользователя (если он пожелает их написать). [Лог] может быть показан в отдельной форме [Навигатор]а.

+++++Общая работа подсистемы лога
ПодсистемаЛога через МенеджерЛога инициализируется при создании объекта [Контейнер]а.
При начале работы открываются ФайлЛогаСолюшена и начинается СеансЛога.
В конце работы файлы закрываются.
Добавление сообщений СообщениеЛога в лог производится функциями соответственными событию СобытиеЛога.
Для каждого типа СобытиеЛога вероятно потребуется свой набор аргументов, и соответственно, свой вариант функции сообщения.
Из этого сообщения формируется ТекстовоеСообщениеЛога для помещения в ТекстовыйФайлЛога и передачи через СобытиеNET, и ЗаписьДвоичногоЛога для ДвоичныйЛог.
Функция, помещающая ТекстовоеСообщениеЛога в текстовый лог, имеет делегат, с помощью которого подключенное к МенеджерЛога приложение может получить текст ТекстовоеСообщениеЛога для показа пользователю. См. КаналСообщенийЛога.

+++++Обработка ошибок подсистемы лога - увязать с КаналСообщенийЛога.
Если в движке возникнут ошибки в ПодсистемаЛога, приводящие к его неработоспособности, то сообщения о этих событиях надо выводить в мессагобоксы на экран или в специальное окно. Вообще все события лога надо бы выводить в ФайлЛогаСолюшена и в специальное окно, для этого надо предусмотреть в коде МенеджерЛога событие нового сообщения лога. Для поддержки мессагобокса критические ошибки лога надо пометить особо, чтобы отличать их от остальных ошибок и выводить только их в мессагобокс - выделить для них класс сообщений. 
Поскольку [Движок] это dll, и у нее нет своего GUI, то эти критические сообщения должно обрабатывать приложение. Наверно, это должен быть тот же механизм, что и для обработки других критических ошибок. Так что тут надо обдумать эту проблему. todo.концепция.лог: Обдумать, как описывать, сигнализировать и обрабатывать критические ошибки ПодсистемаЛога.



++++Выборка ошибок из лога - С2
* Сообщения об ошибках надо извлекать из лога и представлять пользователю.
* Но в них важен контекст, условия при которых произошла ошибка. Поэтому надо показывать ошибку вместе с другими сообщениями лога, которые и описывают этот контекст.
* Получается два способа представления ошибки: 
    * Краткий, только сообщающий пользователю об ошибке в реальном времени.
        * Это типично мессагобокс с текстом сообщения об ошибке.
        * Из него можно кликом по специальной кнопке перейти в Подробное представление об ошибке. 
    * Подробный, включающий в себя контекст и предыдущие события.
        * Это просмотр лога в соответствующем месте. 
        * Можно сделать цветовую подсветку текста лога, чтобы в нем пользователю проще было ориентироваться.
* Поиск сообщений об ошибке в логе предлагается вести автоматически, по [//КодСобытияЛога] сообщений.
* Поскольку лог двоичный, для его просмотра нужен специальный вивер.
* Записывать в лог не может никто, кроме самого Движка во время работы.
* Текущий ФайлЛогаСолюшена должен открываться Движком для чтения и записи, и расшаренным на чтение но не запись. Вивер лога должен открывать любой файл только на расшаренное чтение. Поскольку этот файл может быть использован Движком для чтения, или все еще являться текущим файлом лога Движка и записываться Движком.
    * todo.концепция.лог: Эти режимы доступа надо уточнить в справке по фреймворку - как это можно реализовать.

++++Составление списка кодов событий для лога
Для определения набора кодов событий [//КодСобытияЛога] и формата сообщений [//СообщениеЛога] нужно сначала определить набор функций, которым будут соответствовать эти коды, и набор событий, возможных при работе. Остальное просто.
* Проектировать лог удобно после завершения работы над основными подсистемами. 
todo.вконце: Все функции КодДвижка следует выписать в таблицу и для каждой функции определить класс функции, форматы сообщений, ...
* Каждую функцию каждой подсистемы надо снабдить уникальным идентификатором, ИдентификаторФункцииДвижка состоит из кода подсистемы, кода функции, класса функции, кода формата сообщения, итд.

++++Свойства - С2
+++++Переменные - С2
* Нужен отдельный путь для каталога логов Солюшена, возможно, на другом томе и диске, выделенном для логов только.
* ? Идентификатор текущего сеанса - строка фиксированного формата?
* Bool Вести лог - Вести ли лог вообще.
    * ТранзакцияПользователя нельзя обрабатывать без ПодсистемаЛога.
* Bool Удалять лог по завершении сеанса - После завершения сеанса все ФайлЛогаСолюшена этого сеанса нужно удалить. 
    * Это удобно для некоторой временной работы с Солюшеном, когда сам Солюшен не изменяется. А вот логи нужно удалить, так как они более не потребуются и будут только занимать место в солюшене.  
    * Единицей последовательности лога является СеансЛога, который записывается в один и более ФайлЛогаСолюшена. И лог управляется именно по сеансам, а не по файлам лога.
* СтепеньДетализацииЛога - Насколько подробно следует записывать в лог.
    * Некоторый минимальный уровень детализации необходим для поддержки ТранзакцияСолюшена. Вести лог еще более подробно - не знаю, как это получится.
* Int Ограничение размера одного ФайлЛогаСолюшена, Мб.
    * Размер файла лога не должен превысить это значение.
    * Это значение не может быть менее минимального предела, чтобы не создать тысячи мелких файлов лога при случайной ошибке.
        * Каков этот минимальный предел? Нужно установить или определить его. 
    * Можно предложить установить значение в 0, тогда Лог не ведется совсем (Если это возможно).
    * Если запись лога по размеру превышает размер файла лога, то она должна быть разбита на части и внесена в несколько файлов лога.
        * Надо вычислять общий размер записи лога перед выводом ее в файл лога.
        * Надо предусмотреть отметку в файле лога, что запись лога разбита на фрагменты и предыдущий фрагмент находится в предыдущем файле лога.
        * Надо обеспечить простой переход от текущего файла лога к предыдущему файлу лога и к следующему, если они существуют.
*   Int Ограничить общий размер файлов логов, Мб.
    * Можно предложить установить значение в 0, тогда Лог не ведется совсем (Если это возможно). 
    * Можно предложить установить значение в -1, тогда размер лога не ограничен.
        * В этом режиме, Когда свободного места остается менее максимального размера файла лога, выдается предупреждение о нехватке свободного места для лога.
        * Предупреждение нет возможности выдавать через исключения. Только через специальный КаналСообщенийЛога для сообщений пользователю. Этот КаналСообщенийЛога еще надо организовать и подключить к нему оболочку пользователя - хотя бы мессагобокс навесить. 

+++++Операции - С2
* Удалить все файлы лога - удалить все файлы лога из Солюшена.
* Удалить указанный сеанс лога
    * Сеанс лога должен иметь идентификатор сеанса, по нему можно найти сеанс и удалить его из общей ленты лога. 
* Подсчитать общий размер логов Солюшена
* Создать новый идентификатор сеанса - 
    * Это делает менеджер солюшена, когда открывает сеанс. Подсистеме ПодсистемаЛога просто передается новый идентификатор сеанса.
    * Но это не идентификатор сеанса пользователя - это идентификатор сеанса работы движка.  
    * Сейчас нескольких одновременных сеансов пользователя нет, а если будут, то идентификатор сеанса пользователя надо включать в каждую запись лога. Да и вообще всю концепцию лога придется переделывать, так как сеансы пользователей будут перекрываться. 
        * Тогда надо делить лог на сеансы работы Движка - они точно не перекрываются.
* Открыть существующий ФайлЛогаСолюшена
* Закрыть открытый ФайлЛогаСолюшена
* Создать новый ФайлЛогаСолюшена для текущего сеанса
* Составить список сеансов с их размерами
    * Это для уменьшения размеров лога - лог уменьшается удалением сеансов, а не отдельных файлов.
    * Это можно совместить с Подсчитать общий размер логов Солюшена, хотя теперь медленнее будет выполняться.
* Удалить самый новый сеанс лога - Для возможности вести лог, но удалять его после закрытия сеанса.
* Обеспечить предельный размер логов - Для соответствия минимальному размеру ленты логов.
    * Надо составить хронологический список сеансов, определить последовательность новых сеансов, размер которых укладывается в обозначенные пределы, а остальные сеансы удалить (файлы сеансов удалить, а список сеансов выбросить и создать новый если он нужен) 
+++++Операции новый список - свести воедино с остальными набросками операций.
Не все эти операции потребуются - тут просто список возможных операций, из них потом можно собирать требуемые сложные операции.
* Получить каталог лога - получить путь к КаталогЛоговСолюшена.
* Очистить каталог лога - очистить КаталогЛоговСолюшена от любых файлов и папок 
* Удалить сеанс лога - удалить все файлы и каталог указанного сеанса лога.
* Получить список сеансов лога.
* Создать сеанс лога - создать папку сеанса лога и первый ФайлЛогаСолюшена этого сеанса
* Начать новый сеанс лога движка - то же что создать новый сеанс?
* Завершить сеанс лога движка. 
* Получить список файлов указанного сеанса лога
* Перейти к первому сеансу лога
* Перейти к последнему сеансу лога
* Перейти к предыдущему сеансу лога
* Перейти к следующему сеансу лога
* Перейти к предыдущему файлу лога - внутри сеанса или вообще?
* Перейти к следующему файлу лога
* Перейти к первому файлу сеанса лога
* Перейти к последнему файлу сеанса лога
* Перейти к первой записи файла лога
* Перейти к следующей записи в файле лога
* Перейти к предыдущей записи в файле лога
* Перейти к последней записи файла лога
* Удалить указанный файл лога - Используется в ситуации _Удалить файл лога текущего сеанса в случае нехватки места на диске._
* Вычислить общий размер файлов лога - размер КаталогЛоговСолюшена. Для СтатистикаСолюшена итп.
* Вычислить свободное место для файлов лога - для выдачи предупреждения о нехватке места на дисковом томе для лога.


++++Ситуации и сообщения об ошибках - С2
* Недостаточно места для записи лога - когда на диске недостаточно места для записи записи лога в ФайлЛогаСолюшена.
* todo.концепция.лог: Собрать сюда все сообщения об ошибках в ПодсистемаЛога.
    * Это сложно - возможные ошибки видны только после проектирования алгоритма функции.
    * То есть, сначала надо написать весь код ПодсистемаЛога, а потом собрать из него сообщения об ошибках в этот список и заново перепроектировать код. Чтобы сделать систему более совершенной.
    * Значит, надо сразу выявить некие правила, по которым эти ошибки обрабатываются, чтобы потом меньше переделывать. 

+++ПапкаСеансаЛога
См ПапкаСеансаЛога
См. ОбсуждениеКакРазличатьГраницыСеансовЛога - обсуждение завершено. 
    
+++Файл лога - дополнить
См. КлассФайлЛога.

+++ШапкаФайлаЛога - дополнить
См. ШапкаФайлаЛога.


+++Запись лога - дополнить
См. ЗаписьЛога.

+++ИдентификаторЗаписиЛога - дополнить
См. ИдентификаторЗаписиЛога.
 
+++Номер класса сообщения лога - дополнить
* Это наверно 32-битное число.
* можно выделить несколько классов, подклассов и классификаций вообще для этих кодов, и все они должны быть раздельно и подробно описаны, чтобы назначать их потом не наобум и не вникая опять во всю эту концепцию. Поскольку назначать их функциям придется по мере доработки и дополнения кода движка, в совершенно неподходящих условиях. 
* Все эти наработки в итоге должны быть сведены в один класс, обрабатывающий код сообщения как единственное 32-битное число. 
* Можно даже сделать специальную функцию-конструктор, которая собирает код класса сообщения из указанных пользователем свойств.
* Для собственно функций можно выделить 8-бит пространства. = 256 шт в каждом пространстве.
* Для подсистем выделить 4 бита пространства = 16 шт.
* Для основных классов сообщений выделить 4 бита пространства = 16 шт.
* В целом, надо все организовать так, чтобы разделять записи по этому коду можно было простым выделением по маске вроде 0b1100. Это значительно ускорило бы все эти операции.

++++Классы сообщений
* ошибки SQL
* операции SQL-слоя кода
* транзакции ТранзакцияСолюшена
* чтение ячеек
* изменение ячеек
* чтение, поиск связей
* изменение связей
* ошибки движка
* сеанс движка, SQL
* сериализация
* пользовательские сообщения
* сообщения [Оптимизатор]а




+++Итератор лога
См. ИтераторЛога.
++++Итератор по логам - С2
Для перехода по логам туда и обратно нужен такой специальный ИтераторЛога.
Нужен переход от СеансЛога к сеансу, от ФайлЛогаСолюшена к файлу, от ЗаписьЛога к записи.
И хорошо бы одним объектом итератора.
То есть, лог надо представить в виде хронологической последовательности записей ЗаписьЛога, группированных в файлы ФайлЛогаСолюшена, которые группированы в сеансы СеансЛога.
И вот по такой ленте надо иметь возможность перемещаться определенным образом.
todo.концепция.лог: Как именно - пока неясно, надо выяснить и описать.
И делать это с помощью одного объекта - итератора.
И еще переходить к неким именованным позициям -  ТочкаСохранения - они пока не придуманы.

Хотя предполагается, что эта лента не должна иметь разрывов внутри себя, а обрезаться должна только по краям и строго по границам сеансов, но это может в реальности не соблюдаться ввиду порчи или утери файлов лога.
Тогда правильность общей структуры этих контейнеров нужно контролировать, по мере прохода по ним. Но не заранее.

СообщениеЛога должно быть реализовано как объект ЗаписьЛога с потоком данных.
ФайлЛогаСолюшена можно представить как поток объектов сообщений лога.
Можно создать класс файла лога и в нем реализовать такой итератор по файлу.
Или соединить все файлы сеанса лога в один общий итератор? Это было бы более удобно, так как файлы внутри сеанса представляют один поток сообщений лога, который разбивается на отдельные файлы ограниченного размера. По размеру, а не по любым другим свойствам.
Но вообще-то это зависит от операций с логом. Например, Откатить изменения к  ТочкаСохранения N - это код вроде while(N!=X) { X = getPrevRecord(..); ...} И соответственно потом уже все функции делать под эти требования. Хотя сам базовый набор функций конечно, пригодится. Но не весь.

Записи лога в файле лога надо организовать в двусвязный список, чтобы можно было переходить по этому файлу и вперед и назад. Для этого надо в каждой записи иметь ссылку на предыдущую и следующую?
    * Можно использовать смещения относительно начала файла подобно адресам в памяти.
    * Можно каждую секцию ЗаписьЛога оформлять заголовком, и относительно него считать смещения в файле для передвижения вперед и назад.
    * Для перемещения вперед надо в заголовке секции хранить размер секции для перехода на заголовок следующей секции.
    * Для перемещения назад надо либо в заголовке текущей секции хранить смещение для перехода к заголовку предыдущей секции. Либо в формат секции добавить еще и признак окончания секции - хвостовик секции, и перед ним хранить смещение для перехода на заголовок секции. То есть, это получится действие подобно переходу вперед, симметричное - тоже маркер, но конца, а после него - смещение для перехода на заголовок секции. 
    * Тут проблема в том, что сообщение лога тоже надо читать. Хотя, возможно, не полностью, но чтобы определить что оно содержит. И вот исходя из этого, надо решить, как добыть из сообщения ссылку на предыдущее сообщение лога.
    * todo.концепция.лог: Надо составить диаграмму - строение файла лога. И на ней показать, как реализовать эту навигацию по файлу лога. 

++++Построение классов итераторов - С2
Рассматривается построение классов в части итераторов
* (Объект) Менеджер лога
    * (Набор функций) Итератор сеансов лога - перебирает сеансы лога солюшена
    * (Список <Сеанс лога>) Список сеансов лога  - список путей папок сеансов лога, заполняется при открытии Солюшена.
    * (Сеанс лога) Текущий сеанс лога - экземпляр сеанса лога, в который сейчас ведется запись лога. Работает только на запись.
    * (Сеанс лога) Сеанс лога итератора - экземпляр сеанса лога, в котором сейчас идет чтение или поиск лога итератором. Работает только на чтение. Сейчас это должен быть тот же сеанс, что и текущий сеанс лога? 
    
* (Объект) Сеанс лога
    * (Набор функций) Итератор сеанса лога - перебирает файлы лога внутри сеанса
    * (Список <Файл лога>) Список файлов лога - список путей к файлам лога сеанса, заполняется при инициализации объекта.
    * (Файл лога) Текущий файл лога - экземпляр файла лога, в котором сейчас ведется чтение или запись.
        * todo.концепция.лог: Надо отслеживать, чтобы корректно обрабатывать ситуацию, когда один и тот же файл лога является и читаемым и записываемым - когда он и читается для отката ТранзакцияСолюшена, и является логом, в который выводится ход работы Движка в этот момент.
        * todo.концепция.лог: Если сеансы лога по работе делятся на только запись и только чтение, не следует ли добавить поле Read Only режима, чтобы контролировать такое чтение и запись? Это должно предохранить лог от ошибочной записи.
            * Может быть только один текущий сеанс лога, в котором ведется запись в текущий файл лога. А вот чтение может вестись в любых файлах лога в текущем СеансЛога и в других СеансЛога. С чтением проблем нет, если разрешить расшарить чтение при создании или открытии текущего файла лога.
        
* (Объект) Файл лога
    * (Объект) Заголовок файла лога ШапкаФайлаЛога.
    * прочее
    * (Набор функций) Итератор записей в файле лога
    * (Список <Запись лога>) Список записей лога - не заполняется, виртуальный.
    * Возможно (Stream) Поток файла лога - чтобы иметь раздельные позиции чтения и записи файла    
    
* Итератор сеансов лога перебирает сеансы лога. Записи лога пока перебираются только в пределах текущего сеанса лога. Использует функции итератора из сеанса лога.
    *  todo.концепция.лог: Надо решить, следует ли перебирать записи в соседних с текущим сеансах лога, или нет.
* Итератор файлов лога перебирает файлы сеанса лога, и перебирает записи всех файлов лога этого сеанса. Использует функции итератора из файла лога.
* Итератор записей в файле лога перебирает записи внутри файла лога. Если достигнут конец или начало списка записей, функция возвращает null.



++Тема Организация сеансов для лога
+++Сеанс пользователя - завершить обсуждение
* СеансПользователя это отрезок времени работы некоторого пользователя внутри отрезка времени работы Движка.
* СеансПользователя может вестись одновременно с сеансом другого пользователя, в одном логе сеанса СеансДвижка.
* СеансПользователя имеет начало и конец, которые должны обозначаться записями в файле лога.
* СеансПользователя имеет ИдентификаторСеансаПользователя. Этот идентификатор должен (косвенно, через ТранзакцияПользователя) входить в состав каждой ЗаписьЛога, поскольку одновременно с Солюшеном может работать несколько пользователей в одном СеансДвижка.


+++Обсуждение сеанса пользователя в Логе - разнести по страницам
* todo.концепция.лог: Разнести по страницам тем и сущностей эти выводы из ОбсуждениеСеансаПользователяВЛоге.
* СеансЛога представляет собой совокупность связанных между собой ФайлЛогаСолюшена. Потеря одного из ФайлЛогаСолюшена повредит целостность всего СеансЛога.

++++СеансПользователя - переделать на новые наработки
* СеансПользователя создается при начале работы пользователя с Движок. Отдельной функцией, которая возвращает объект-описатель этого СеансПользователя - КонсольПользователя.
* Объект СеансПользователя передается как аргумент при каждой операции Движка. Код операции передает этот описатель в Лог и другие подсистемы. КонсольПользователя подставляет объект СеансПользователя в вызовы каждой операции Движка, скрывая таким образом детали от пользователя.
* СеансПользователя является ТранзакцияПользователя первого уровня. В него вкладываются остальные операции и транзакции пользователя.
    * Объект-описатель СеансПользователя должен быть представлен классом подобным классу представления ТранзакцияЛога, чтобы единообразно обрабатываться в списке транзакций пользователя.
        * Либо не входить в список транзакций пользователя, а существовать и обрабатываться отдельно.
* Сам объект СеансПользователя тоже дампится в Лог в составе ЗаписьЛога о начале сеанса пользователя.
* Все начинаемые ТранзакцияПользователя описываются в объект-описатель СеансПользователя, так что он для пользовательского кода представляет все начатые кодом транзакции.
* Одновременно в Движок может существовать несколько таких объектов-описателей СеансПользователя. Они хранятся в КоллекцияСеансовПользователей.
* Пользователи различаются по строковому названию ИдентификаторАгента - имени пользователя. Это название нужно только при просмотре лога или свойств СеансПользователя.

++++ИдентификаторСеансаПользователя
* ИдентификаторСеансаПользователя используется только внутри ПодсистемаЛога, внутри текущего СеансЛога.
* ИдентификаторСеансаПользователя назначать как координату ЗаписьЛога о начале СеансПользователя в СеансЛога. Это 64-битное число будет указывать на пользователя только внутри лога.
* ИдентификаторСеансаПользователя для лога приходит снаружи, однажды записывается в лог в начале СеансПользователя и потом используется в каждой ЗаписьЛога для обозначения пользователя-инициатора операции.
* ИдентификаторСеансаПользователя сейчас описывает объект-описатель СеансПользователя, но не может быть представлен целым числом.

++++Идентификатор записи лога - написать больше о нем
* ИдентификаторЗаписиЛога это уникальное 64-битное целое число. 

++++Транзакции Солюшена и пользователя
* ЗаписьЛога о начале ТранзакцияПользователя должна содержать ИдентификаторСеансаПользователя.
* Каждая ЗаписьЛога о начале транзакции описывает Пользователя как координаты ЗаписьЛога о начале СеансПользователя и/или непосредственно текстом с логином пользователя.
* ЗаписьЛога о начале транзакции должна содержать указатель на ЗаписьЛога о начале родительской транзакции. Если это транзакция самого первого уровня, то эта ссылка указывает на псевдотранзакцию СеансПользователя.
    * Таким образом можно по логу определить и пользователя - владельца транзакции, раскрутив всю цепочку вложенных транзакций.  
* Каждая ЗаписьЛога содержит поле Родительская Транзакция. В этом поле хранится ИдентификаторЗаписиЛога записи о начале соответствующей транзакции. Эта запись (о начале) содержит полезную информацию о транзакции.
* При завершении транзакции некоторого уровня должны быть завершены вложенные в нее транзакции. Таким образом, завершение СеансПользователя покажет и завершит также все открытые им транзакции.
    * Тут нужны функции проверки, есть ли вложенные транзакции для указанной транзакции.
    * И функция закрытия транзакции и всех вложенных транзакций.
    * И транзакции должны называться по уникальному строковому имени. И нужны публичные функции для генерации такого имени (возможно, дополнением таймштампом предложенного пользователем названия) и проверки его уникальности.
    * А список транзакций должен находить транзакцию по этому имени, не по индексу в списке.
    * А можно ли автоматически завершать вложенные транзакции? Ведь они должны завершиться в ходе исполнения кода. Это код должен их завершить, или отменить. Из произвольного места кода можно только отменить вложенные транзакции. Таким образом, завершение СеансПользователя потребует отменить все начатые, но не завершенные им транзакции. 
* Все начинаемые ТранзакцияПользователя описываются в объект-описатель СеансПользователя, так что он для пользовательского кода представляет все начатые кодом транзакции.
* Тему с ТранзакцииСолюшена надо еще продумывать на уровне всего Солюшена, а не только на уровне лога.




++++Как получить имя пользователя из лога без Движка
* ЗаписьЛога содержит координаты ЗаписьЛога о Начало последней ТранзакцияПользователя.
    * Перейдя к этой Записи, получаем описание этой транзакции, в том числе ее координаты Родительская Транзакция и координаты Пользователь.
    * Перейдя к ЗаписьЛога о Начало сеанса пользователя, получаем название пользователя.
* А как для всех записей лога показать Пользователя?
    * Придется составить дерево транзакций, начинающееся с СеансПользователя. И по полю  Родительская Транзакция каждой ЗаписьЛога можно высчитать Пользователя по этому Дереву. Причем одновременно с собственно построением дерева транзакций.
    * Это значит, для произвольного места Лога нужно прочитать предыдущие файлы лога.
        * Не все, а только указанные координатами записи в них.
        * Но все файлы лога за СеансЛога должны существовать, их нельзя частично удалять.
        * Значит, нет смысла читать один файл лога отдельно от остальных - они нужны целым СеансЛога сразу.
        * Ну, можно некоторую информацию дублировать в начале каждого ФайлЛогаСолюшена. Но это мало что дает. Все равно транзакции размазаны по всему СеансЛога - один кусок не самодостаточен. 



           
+++Идентификатор сеанса движка - дополнить
См. ИдентификаторСеансаДвижка.
 
+++Сеанс Лога - СеансДвижка - дополнить
См. КлассСеансЛога.

++Тема Транзакции в логе
+++Транзакции - требует существенного обсуждения и переделок
См. [//ТранзакцияЛога]. ТранзакцияСолюшена - новый термин с 06.11.2017 01:16 
18.02.2017 14:16:41
* Транзакции ТранзакцияСолюшена нужны для использования в Методах. Алгоритм метода вызывает  команду АпиСолюшена Движка [//АпиСолюшена/НачатьТранзакцию], потом другие операции - тело транзакции, потом вызывает команды Движка [//АпиСолюшена/ПодтвердитьТранзакцию] или [//АпиСолюшена/ОтменитьТранзакцию].
* Таким образом, внутри СеансЛога располагаются и отдельные операции движка, и группы таких операций, объединенные в ТранзакцияСолюшена. Эти группы могут быть вложены друг в друга, как вложенные транзакции.
* Код ИнтерпретаторЛога, который читает лог, должен распознавать эти группы записей.
* Неудачные транзакции надо бы отмечать в конце их отката. Для этого надо записать флаг Неуспешная транзакция в запись о начале транзакции. Но там есть контрольная сумма, которая будет испорчена, поэтому надо и ее пересчитать и переписать.
* И откат транзакции может быть неудачным. Что можно сделать в этом случае?
* Сейчас ТранзакцияСолюшена не нужны, поскольку нет ИнтерпретаторЛога и нечем делать откат транзакции.
    * Но надо предварительно спроектировать это, чтобы потом меньше разрабатывать и проще внедрять.
    * Сейчас надо обозначить в логе сами транзакции, чтобы можно было анализировать лог.
* Типично транзакция откатывается при возникновении ошибки. Но это не единственный повод. Метод сам может инициализировать откат транзакции, если результат операции ему не подходит. Так можно перебирать варианты и искать решение.
    * Но стоит ли писать весь этот поиск в лог? Лог был бы проще, если такие интенсивные, но бесполезные операции удалить из него.
        * Лог все равно надо вести. А поиск решения можно производить в отдельной СеансДвижка, или сделать ПолныйСнимокСтруктуры перед началом поиска и каждый раз к нему возвращаться.
* Поскольку лог одной транзакции может занять очень много места, он может не поместиться в один ФайлЛогаСолюшена. Поэтому для работы с транзакциями нужен итератор (ИтераторЛога) записей лога в пределах всего СеансЛога. 
* Нужно вести *учет уровня вложенности* ТранзакцияСолюшена. Именно для лога. В БазаДанныхСолюшена свои транзакции на уровне операций Движка. Не надо это путать.
    * Тогда надо в МенеджерЛога хранить список текущих вложенных транзакций. Элемент списка состоит из координат ЗаписьЛога о начале транзакции, идентификатора транзакции.
        * При начале новой транзакции добавлять в конец списка объект ТранзакцияПользователя с данными новой транзакции.
        * При завершении транзакции удалять из списка эту транзакцию. 
    * Можно будет автозавершить транзакции при закрытии [Движок]а.
    * А как быть при аварийном прекращении работы [Движок]а? (См ТемаНеожиданноеПрекращениеРаботыДвижка) Как тогда выявлять эти незавершенные транзакции?
        * Тогда Солюшен надо восстанавливать по логу до некоторой начальной точки - до начала первой незавершенной транзакции. И это должен делать некий механизм восстановления солюшена после аварии.
        * А как этот механизм обнаружит такую аварию? Это надо придумать. Чтобы сразу при старте Солюшена обнаружить его предыдущее некорректное завершение, вывести сообщение пользователю и начать восстановление.
* Хорошо бы в последовательности ЗаписьЛога быстро переходить к началу транзакции от ее тела. И к началу любой из вложенных транзакций.
    * Это не требуется при нормальной работе [Движок]а, поэтому будет использоваться достаточно редко.
        * Но это будет требоваться при анализе лога.   
    * Можно ввести в ЗаписьЛога поле Родительская транзакция. Указатель на родительскую транзакцию. 
    * Но как указать ЗаписьЛога о начале транзакции? 
        * ИдентификаторЗаписиЛога в течение СеансЛога. Тогда надо вести счетчик записей для СеансЛога. Это легко.
        * И ИдентификаторЗаписиЛога должен быть целым числом в 64 бита. 
    * Но в каком ФайлЛогаСолюшена искать эту запись?
        * Идея ввести НомерФайлаЛога в ИдентификаторЗаписиЛога - плохая. См ОбсуждениеСтруктурыИдентификатораЗаписиЛога. 
* Не путать ТранзакцияСолюшена и ТочкаСохранения - это разные сущности. И разные технологии.

++++Транзакции
Транзакции позволяют отметить некоторое состояние процесса, а затем вернуться к нему, откатив все сделанные изменения.
ТранзакцияСолюшена предполагается использовать в алгоритме [Метод]ов движка. В зависимости от алгоритма метода, транзакции в логе могут быть вложенными и повторяющимися.
Если транзакцию обозначать по имени, в логе может оказаться несколько ТранзакцияСолюшена с одинаковым именем, и будет неоднозначно определить необходимую транзакцию для отката.
Если транзакцию определять по произвольному номеру, то то же самое. 
Если транзакцию определить уникальным номером, генерируемым подсистемой ПодсистемаЛога, то такой номер надо будет передавать между функциями в операции - это тоже неудобно. Хотя это хотя бы какой-то способ.
Если транзакцию не идентифицировать, то откатывать или фиксировать можно только последнюю транзакцию. Это тоже неудобно.
Надо сначала сделать прототип лога, посмотреть как он работает на практике, а потом проектировать механизм транзакций Солюшена.
* Все операции фиксируются в [Лог]е проекта, это позволит обеспечить отладку операций и откат изменений в проекте. Откат изменений позволит использовать операции в духе поиска оптимального решения перебором вариантов структуры.
* Для обозначения этапов ТранзакцияСолюшена предлагается использовать ТочкаСохранения. Но эту концепцию транзакций целиком надо переработать - она очень нечеткая сейчас.
    * ТранзакцияСолюшена - это фактически отрезок жизни Солюшена между начальной точкой и конечной точкой, где изменения подтверждены. Но их не нужно подтверждать, поскольку реально они уже сделаны. 
    * И если в некоторый момент внутри этой транзакции некий сторонний пользователь запросил данные, затронутые транзакцией, то после ее отката эти данные не будут соответствовать действительности.
    * Значит, либо в солюшене может быть только один пользователь, либо придется примириться с возможностью ошибок при исполнении методов из-за действий других пользователей.
    * Или можно блокировать изменения в некотором УчастокСтруктурыСущностей для работы с ним. 
        * Тогда пользователи не смогут читать и/или изменять такой УчастокСтруктурыСущностей из-за того, что он заблокирован некоторым пользователем для его собственной работы.
        * Это будет не некий постоянный УчастокСтруктурыСущностей, подобный строительному блоку, а совокупность ячеек СтруктураСущностей, возможно рассеянных по СтруктураСущностей. Их связи и содержимое будут защищены от изменения на время действия блокировки.
        * Такая блокировка это просто список ячеек и связей, привязанных к объекту блокировки и пользователю. Операции других пользователей не могут быть выполнены, пока их ячейки указаны в этом или других списках блокировки.
        * И это можно реализовать с помощью временного перекрытия прав пользователя ячеек и связей. Запрещать другим пользователям доступ к ячейкам и связям, находящимся в блокировке.
            * todo.концепция.лог: Идея многопользовательских блокировок в СтруктураСущностей усложнит всю КонцепцияСтруктурыСущностей. Ее надо перенести на последующие релизы.  
    * Поэтому транзакций собственно нет. Но есть ТочкаСохранения. Это такой более примитивный механизм, чем транзакции.
++++Использование Лога для отката транзакций - старое, освежить под новую концепцию.
* Для *автоматического анализа* нужны *средства чтения и разбора лога* (Сейчас это ИнтерпретаторЛога). Таким образом, МенеджерЛога должен обеспечивать все операции с логом.
* Для автоматического анализа необходимо соответствующим образом спроектировать ПодсистемаЛога и представление данных в логе.
* Для поддержки анализа и отката ТранзакцияСолюшена в логе должны храниться элементы или их части до и после операции. Удобно их хранить в двоичном виде, а пользователю приводить краткое описание. 
* Поскольку все изменения в СтруктураСущностей записываются в [Лог], можно полностью откатить произведенные любой операцией изменения.
* При необходимости отката операций нужно использовать предыдущие ПолныйСнимокСтруктуры или [Лог].
* историю операций выводить в [Лог]. 
* СообщениеЛога должно представлять информацию о типе события, времени события, о ассоциированных событию объектах, о изменениях объектов.
Информация должна быть достаточно полной, чтобы можно было полностью повторить или обратить изменения в [Солюшен]е.
Предположительно, каждая операция будет иметь собственную структуру представления ассоциированных объектов.
Для полного представления об этом необходимо иметь список операций [Движок]а, опеределить для каждой операции участвующие объекты, разработать форматы представления событий, способы их повторения и отката.
* Предлагается сделать собственный *модуль транзакций* на базе [Лог]а.
В [Лог] выводить дамп объекта до и после операции и код операции. 
Это одновременно [Лог] движка и [Лог] ТранзакцияСолюшена.
Объекты должны сериализовываться в компактный дамп для выведения в [Лог] и передачи по сети.
Этот [Лог] будет очень большим. Удалять из него старые записи нежелательно - это не позволит откатывать базу обратно, если потребуется *откатить [Солюшен] на несколько сеансов назад*.
Но [Лог] будет огромным. Тут можно попробовать оптимизацию, но лучше просто писать все в [Лог].
 [Лог]должен содержать еще и *комментарии пользователя* и *комментарии, вставляемые в методах в целях отладки*.
Тогда можно использовать все движки БД, реализуя ТранзакцияСолюшена через [Лог].
Эту ПодсистемаЛога надо сделать слоем между [Контейнер]ом и [АдаптерБД]. Она независима от БазаДанныхСолюшена, поскольку операции [Движок]а одни и те же.
Ей отправляются команды по получению-отправке данных, и она же будет производить [Лог] и откатывать ТранзакцияСолюшена.
Надо это продумать.
* Предлагается выводить дампы объектов ЭлементСтруктурыСущностей до и после операции.
    * не полные дампы, а только изменившиеся свойства. 
* Предлагается создавать для операций ApiSystemLayer [Движок]а функции-обработчики для отката изменений, произведенных сложными функциями.
(Можно предложить для каждой функции ApiSystemLayer [Движок]а создавать парную ей функцию отката, и размещать рядом с основной функцией, чтобы проще было вносить изменения в код.)
Если существуют функции, которые нельзя откатить, их надо перепроектировать, возможно, разбить на этапы.

++++Нужно провести моделирование
Сейчас лог открывается только для записи сообщений.
Для анализа и отката изменений нужно еще читать лог.
todo.концепция.лог: Для отката изменений надо определять в логе текущую СеансДвижка. Например, как последнюю (первую с конца) и незакрытую.
В общем, много работы.
Предлагается для файла лога открывать и Reader и Writer, а файл открывать для чтения и записи.
todo.концепция.лог: Предлагается построить модель (программу-прототип лога) и поэксплуатировать ее, чтобы уточнить реализацию ПодсистемаЛога. Она должна и писать блоки данных, и читать их. И при этом использовать минимум оперативной памяти.
Обкатывать откат ТранзакцияСолюшена лучше на существующем реально логе работы, поэтому надо сначала сделать ведение лога, потом использовать этот лог для отладки новых фич, потом переделать всю ПодсистемаЛога.

++++Транзакции - С2
* Все действия в Солюшене должны быть записаны в Лог. Это надо для отката ТранзакцияСолюшена и для выявления ошибок в работе, в том числе внутри транзакций.
* Если ТранзакцияСолюшена успешная, все действия, записанные в лог, затем могут быть использованы для повтора или отката состояния Солюшена.
* Если ТранзакцияСолюшена неуспешная, этот лог используется для отката операций транзакции. Действия по откату транзакции также записываются в лог.
* В результате, для неудачной транзакции в логе остается записи о ходе транзакции: Операции прямого хода, сообщение об ошибке, операции отката транзакции. Поскольку в итоге транзакция не была выполнена, эти записи полезны только для выявления ошибки. Они бесполезны для отката состояния Солюшена в целом.
* done.концепция.лог: Как бы придумать помечать такие неуспешные ТранзакцияСолюшена и изолировать их границы, чтобы игнорировать их тогда, когда ИнтерпретаторЛога исполняет ОткатСолюшена и НакатСолюшена?
    * ТранзакцияПользователя.ПолеСостояниеТранзакции  в ЗаписьЛога переписывать в логе для неуспешных транзакций? 

+++Интерпретатор лога - наброски
* Сейчас ИнтерпретаторЛога нет, поэтому откат ТранзакцияСолюшена по логу невозможен.
    * Когда я буду делать этот механизм? Сейчас это слишком сложно, даже образцов лога нет.
    * Как будет называться этот механизм исполнения по логу?
        * ИнтерпретаторЛога подходящее название.
        * todo.концепция.лог: Заменить везде упоминания на это новое имя
        * todo.концепция.лог: Создать страницу и внести в глоссарий.
        * todo.концепция.лог: Создать страницу сборки этого в КонцепцияЛога и натаскать туда имеющиеся материалы. Хотя бы ссылками. 
    * Где этот ИнтерпретаторЛога будет располагаться? В какой подсистеме? В каком виде?
        * Как часть МенеджерЛога, возможно, собственным классом. Постоянно работающим.
        * Можно в него же завести и чтение и запись файлов лога, и управление ими. Тогда это просто функционал МенеджерЛога, а не самостоятельный класс.
        * Эту реализацию надо еще будет проработать и выбрать лучшую. 
    * На какой стадии проекта можно будет реализовать ИнтерпретаторЛога?
        * Не знаю. В первом же релизе нельзя - непонятно что и как делать. Механизм выяснится только после опыта работы. То есть, во второй версии ПодсистемаЛога. Которая наверняка потребует внесения изменений в остальные части Движка, так что просто заменить модуль Лога не получится.
        * Сейчас надо заложить основу для всего этого механизма. 
    * Как вообще это все будет выглядеть?
        * Пока точно не известно. Надо составить диаграмму функций подсистем [Контейнер]-[Лог]-АдаптерБД. Но пока нет функций [Контейнер]а и АдаптерБД, тут ничего нельзя сказать.
        * Вопрос [//ОТЛОЖИТЬ ДО]: готовности ИнтерфейсАдаптераБД.  
    * А что сейчас будет в ПодсистемаЛога?
        * Вывод в лог всяких сообщений, без анализа лога.
        * Обработка отката ТранзакцияСолюшена с помощью вызова отдельных функций-обработчиков. А не совмещенно с основным кодом, как раньше. Так проще будет потом эти откатчики анализировать и превращать в что-то более удобное. 
* ОткатСолюшена по логу - это когда ИнтерпретаторЛога проводит операции, возвращающие состояние Солюшена к некоторой начальной точке. Это полезно при экспериментах. Назначил именованную ТочкаСохранения, начал эксперимент. Если эксперимент неудался, по логу можно откатить Солюшен к этой именованной точке.
    * Для таких ТочкаСохранения предполагался ПолныйСнимокСтруктуры. А это еще один способ? Для более мелких шагов вперед?
* НакатСолюшена по Логу - Это когда ИнтерпретаторЛога проводит операции по логу как по уже пройденному пути, возвращая Солюшен после отката, обратно вперед.
    * Это типа сначала откат произвели, потом мелкими шагами накатываемся обратно по ранее пройденному пути. А зачем это надо?

+++Точка сохранения - наброски
* Именованная ТочкаСохранения это позиция в логе, к которой можно вернуться через ОткатСолюшена. С помощью ИнтерпретаторЛога.
* todo.концепция.лог: В настоящее время работа с ТочкаСохранения не продумана, ее надо отложить на следующие релизы.
* ТочкаСохранения должна иметь уникальное имя, по которому ее можно было бы найти в логе.
    * Уникальное в пределах текущего СеансДвижка? или в пределах всего лога? И искать соответственно?
    * Как проверять такую уникальность? Просматривать весь лог - это очень медленно.
        * Если ТочкаСохранения будет использоваться внутри скриптов и методов - как такие имена делать уникальными? 
* Пользователь может установить некоторую ТочкаСохранения перед началом некоторой сложной работы. А после любых действий вернуть Солюшен обратно к этому состоянию с помощью ИнтерпретаторЛога.
    * Это позволило бы откатывать состояние Солюшена после неудачных операций.
    *
* Для таких ТочкаСохранения предполагался ПолныйСнимокСтруктуры. А это еще один способ? Для более мелких шагов назад?
    * Для отката операций Движка предназначается код обработчика отката операций. Он может откатить отдельную операцию. Но он не может откатить ТранзакцияСолюшена как комбинацию операций. То есть, он не может откатить [Метод].
    * Для отката [Метод]ов предназначен механизм транзакций через лог - ИнтерпретаторЛога. Откат последовательности методов - это очень существенная работа. ТочкаСохранения при этом обозначает начало этой последовательности методов - начало транзакции. В сущности, ТочкаСохранения - это начало или некий промежуточный этап транзакции. К нему можно откатиться в любой момент внутри транзакции.
    * Собственно, в СтруктураСущностей смысл транзакции вообще исчезает - нет таких копий СтруктураСущностей Солюшена, с которыми бы в рамках транзакции можно было проводить работы, а при завершении транзакции записывать получившееся в основную СтруктураСущностей. Это потому, что вся СтруктураСущностей связана между собой. 
    * Транзакция же, как общая стандартная концепция, предполагает временные копии обособленных записей, которые потом либо замещают собой старые их версии при подтверждении транзакции, либо уничтожаются при отмене транзакции. Такие транзакции пригодны только в рамках одной операции Движка.
    * Поэтому введены лог и ИнтерпретаторЛога, ОткатСолюшена и НакатСолюшена.
        * НакатСолюшена предполагается как часть механизма адаптации и самообучения системы - это надо еще придумать, но сначала нужен опыт работы.
* ТочкаСохранения может располагаться внутри ТранзакцияСолюшена, но тогда она имеет смысл только внутри этой транзакции. Так как снаружи транзакции теряется ее смысл - транзакцию уже нельзя провести повторно (? или что?).
* ТочкаСохранения хороша вне транзакции - как место для безопасного возврата.
    * Это подобно сохранению в играх. Транзакция - это начатая миссия. Соответственно, и внутри транзакции действовать придется как внутри миссии - допроходить ее. Эта аналогия должна помочь представить себе эту проблему.  
    * Если ТочкаСохранения окажется неудобной внутри транзакций, что с такими точками делать?
        * Постараться не назначать им одинаковые имена?

++Материалы
* 05.02.2017 4:21:48 ДиаграммаВерсийСолюшена - добавить и в КонцепцияСнимков тоже. И для КонцепцияРесурсов возможно тоже пригодится. Сложно все же будет это дерево версий Солюшена разгребать.
* 05.12.2016 07:28 См. [//ИдеяУбратьТаймШтампыЯчеекИСвязей] использует лог для нахождения таймштампов.









 



  

















